"use strict";
var FDT = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/extensions/Extensions.mjs
  var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
  var init_Extensions = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
      "use strict";
      ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
        ExtensionType2["Application"] = "application";
        ExtensionType2["WebGLPipes"] = "webgl-pipes";
        ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
        ExtensionType2["WebGLSystem"] = "webgl-system";
        ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
        ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
        ExtensionType2["WebGPUSystem"] = "webgpu-system";
        ExtensionType2["CanvasSystem"] = "canvas-system";
        ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
        ExtensionType2["CanvasPipes"] = "canvas-pipes";
        ExtensionType2["Asset"] = "asset";
        ExtensionType2["LoadParser"] = "load-parser";
        ExtensionType2["ResolveParser"] = "resolve-parser";
        ExtensionType2["CacheParser"] = "cache-parser";
        ExtensionType2["DetectionParser"] = "detection-parser";
        ExtensionType2["MaskEffect"] = "mask-effect";
        ExtensionType2["BlendMode"] = "blend-mode";
        ExtensionType2["TextureSource"] = "texture-source";
        ExtensionType2["Environment"] = "environment";
        ExtensionType2["ShapeBuilder"] = "shape-builder";
        ExtensionType2["Batcher"] = "batcher";
        return ExtensionType2;
      })(ExtensionType || {});
      normalizeExtension = (ext) => {
        if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
          if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
          }
          const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
          ext = { ...metadata, ref: ext };
        }
        if (typeof ext === "object") {
          ext = { ...ext };
        } else {
          throw new Error("Invalid extension type");
        }
        if (typeof ext.type === "string") {
          ext.type = [ext.type];
        }
        return ext;
      };
      normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
      extensions = {
        /** @ignore */
        _addHandlers: {},
        /** @ignore */
        _removeHandlers: {},
        /** @ignore */
        _queue: {},
        /**
         * Remove extensions from PixiJS.
         * @param extensions - Extensions to be removed.
         * @returns {extensions} For chaining.
         */
        remove(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
          });
          return this;
        },
        /**
         * Register new extensions with PixiJS.
         * @param extensions - The spread of extensions to add to PixiJS.
         * @returns {extensions} For chaining.
         */
        add(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              const handlers = this._addHandlers;
              const queue = this._queue;
              if (!handlers[type]) {
                queue[type] = queue[type] || [];
                queue[type]?.push(ext);
              } else {
                handlers[type]?.(ext);
              }
            });
          });
          return this;
        },
        /**
         * Internal method to handle extensions by name.
         * @param type - The extension type.
         * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
         * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
         * @returns {extensions} For chaining.
         */
        handle(type, onAdd, onRemove) {
          const addHandlers = this._addHandlers;
          const removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
          }
          addHandlers[type] = onAdd;
          removeHandlers[type] = onRemove;
          const queue = this._queue;
          if (queue[type]) {
            queue[type]?.forEach((ext) => onAdd(ext));
            delete queue[type];
          }
          return this;
        },
        /**
         * Handle a type, but using a map by `name` property.
         * @param type - Type of extension to handle.
         * @param map - The object map of named extensions.
         * @returns {extensions} For chaining.
         */
        handleByMap(type, map) {
          return this.handle(
            type,
            (extension) => {
              if (extension.name) {
                map[extension.name] = extension.ref;
              }
            },
            (extension) => {
              if (extension.name) {
                delete map[extension.name];
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions with a `name` property.
         * @param type - Type of extension to handle.
         * @param map - The array of named extensions.
         * @param defaultPriority - Fallback priority if none is defined.
         * @returns {extensions} For chaining.
         */
        handleByNamedList(type, map, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              const index = map.findIndex((item) => item.name === extension.name);
              if (index >= 0)
                return;
              map.push({ name: extension.name, value: extension.ref });
              map.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
            },
            (extension) => {
              const index = map.findIndex((item) => item.name === extension.name);
              if (index !== -1) {
                map.splice(index, 1);
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions.
         * @param type - Type of extension to handle.
         * @param list - The list of extensions.
         * @param defaultPriority - The default priority to use if none is specified.
         * @returns {extensions} For chaining.
         */
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              if (list.includes(extension.ref)) {
                return;
              }
              list.push(extension.ref);
              list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
            },
            (extension) => {
              const index = list.indexOf(extension.ref);
              if (index !== -1) {
                list.splice(index, 1);
              }
            }
          );
        }
      };
    }
  });

  // node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context4, once) {
        this.fn = fn;
        this.context = context4;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context4, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context4 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i3 = 0, l2 = handlers.length, ee = new Array(l2); i3 < l2; i3++) {
          ee[i3] = handlers[i3].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i3;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
            args[i3 - 1] = arguments[i3];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i3 = 0; i3 < length; i3++) {
            if (listeners[i3].once)
              this.removeListener(event, listeners[i3].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i3].fn.call(listeners[i3].context);
                break;
              case 2:
                listeners[i3].fn.call(listeners[i3].context, a1);
                break;
              case 3:
                listeners[i3].fn.call(listeners[i3].context, a1, a2);
                break;
              case 4:
                listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i3].fn.apply(listeners[i3].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context4) {
        return addListener(this, event, fn, context4, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context4) {
        return addListener(this, event, fn, context4, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context4, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context4 || listeners.context === context4)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
            if (listeners[i3].fn !== fn || once && !listeners[i3].once || context4 && listeners[i3].context !== context4) {
              events.push(listeners[i3]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
  var import_index, eventemitter3_default;
  var init_eventemitter3 = __esm({
    "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs"() {
      import_index = __toESM(require_eventemitter3(), 1);
      eventemitter3_default = import_index.default;
    }
  });

  // node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs
  var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t2 = r2.toString(16);
        return t2.length < 2 ? "0" + t2 : t2;
      };
      h = function(r2) {
        var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i3 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
        return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i3 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i3, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i3, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i3][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
        var t2, n2, e2;
      };
      c = function(r2) {
        return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
        var t2, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t2 = i.exec(r2);
        return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t2 = v.exec(r2) || m.exec(r2);
        return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t2) {
        var n2 = l.exec(t2) || p.exec(t2);
        if (!n2)
          return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i3 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i3) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2))
          return null;
        var i3 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i3);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i3 = r2.a, s2 = void 0 === i3 ? 1 : i3;
        if (!t(n2) || !t(a2) || !t(o2))
          return null;
        var h2 = function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var e2 = t2[n2][0](r2);
          if (e2)
            return [e2, t2[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
      };
      j = function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i3 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i3;
          var r3, t2, e2, u2, a2, i3;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
          var t2;
        }, r2.prototype.hue = function(r3) {
          var t2 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      }();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d2 in a2)
      r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d3, i3, n2 = r2[this.toHex()];
      if (n2)
        return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length)
          for (var c2 in a2)
            l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i3 = l2[g2], Math.pow(d3.r - i3.r, 2) + Math.pow(d3.g - i3.g, 2) + Math.pow(d3.b - i3.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs"() {
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/color/Color.mjs
  var _Color, Color;
  var init_Color = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/color/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color = class _Color2 {
        /**
         * @param {ColorSource} value - Optional value to use, if not provided, white is used.
         */
        constructor(value = 16777215) {
          this._value = null;
          this._components = new Float32Array(4);
          this._components.fill(1);
          this._int = 16777215;
          this.value = value;
        }
        /** Get red component (0 - 1) */
        get red() {
          return this._components[0];
        }
        /** Get green component (0 - 1) */
        get green() {
          return this._components[1];
        }
        /** Get blue component (0 - 1) */
        get blue() {
          return this._components[2];
        }
        /** Get alpha component (0 - 1) */
        get alpha() {
          return this._components[3];
        }
        /**
         * Set the value, suitable for chaining
         * @param value
         * @see Color.value
         */
        setValue(value) {
          this.value = value;
          return this;
        }
        /**
         * The current color source.
         *
         * When setting:
         * - Setting to an instance of `Color` will copy its color source and components.
         * - Otherwise, `Color` will try to normalize the color source and set the components.
         *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
         *
         * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
         * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
         *
         * When getting:
         * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
         *   {@link Color.premultiply premultiply} or {@link Color.round round}).
         * - Otherwise, the color source used when setting is returned.
         */
        set value(value) {
          if (value instanceof _Color2) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
          } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
          } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._value = this._cloneSource(value);
            this._normalize(this._value);
          }
        }
        get value() {
          return this._value;
        }
        /**
         * Copy a color source internally.
         * @param value - Color source
         */
        _cloneSource(value) {
          if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
          } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
          } else if (typeof value === "object" && value !== null) {
            return { ...value };
          }
          return value;
        }
        /**
         * Equality check for color sources.
         * @param value1 - First color source
         * @param value2 - Second color source
         * @returns `true` if the color sources are equal, `false` otherwise.
         */
        _isSourceEqual(value1, value2) {
          const type1 = typeof value1;
          const type2 = typeof value2;
          if (type1 !== type2) {
            return false;
          } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
          } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
              return false;
            }
            return value1.every((v2, i3) => v2 === value2[i3]);
          } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            return keys1.every((key) => value1[key] === value2[key]);
          }
          return value1 === value2;
        }
        /**
         * Convert to a RGBA color object.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
         */
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        /**
         * Convert to a RGB color object.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
         */
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          out2[0] = Math.round(r2 * 255);
          out2[1] = Math.round(g2 * 255);
          out2[2] = Math.round(b2 * 255);
          return out2;
        }
        toArray(out2) {
          if (!this._arrayRgba) {
            this._arrayRgba = [];
          }
          out2 = out2 || this._arrayRgba;
          const [r2, g2, b2, a2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          out2[3] = a2;
          return out2;
        }
        toRgbArray(out2) {
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          const [r2, g2, b2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          return out2;
        }
        /**
         * Convert to a hexadecimal number.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toNumber(); // returns 16777215
         */
        toNumber() {
          return this._int;
        }
        /**
         * Convert to a BGR number
         * @example
         * import { Color } from 'pixi.js';
         * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
         */
        toBgrNumber() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return (b2 << 16) + (g2 << 8) + r2;
        }
        /**
         * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
         * @example
         * import { Color } from 'pixi.js';
         * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
         * @returns {number} - The color as a number in little endian format.
         */
        toLittleEndianNumber() {
          const value = this._int;
          return (value >> 16) + (value & 65280) + ((value & 255) << 16);
        }
        /**
         * Multiply with another color. This action is destructive, and will
         * override the previous `value` property to be `null`.
         * @param {ColorSource} value - The color to multiply by.
         */
        multiply(value) {
          const [r2, g2, b2, a2] = _Color2._temp.setValue(value)._components;
          this._components[0] *= r2;
          this._components[1] *= g2;
          this._components[2] *= b2;
          this._components[3] *= a2;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Converts color to a premultiplied alpha format. This action is destructive, and will
         * override the previous `value` property to be `null`.
         * @param alpha - The alpha to multiply by.
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
         * @returns {Color} - Itself.
         */
        premultiply(alpha, applyToRGB = true) {
          if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
          }
          this._components[3] = alpha;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Premultiplies alpha with current color.
         * @param {number} alpha - The alpha to multiply by.
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
         * @returns {number} tint multiplied by alpha
         */
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1) {
            return (255 << 24) + this._int;
          }
          if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
          }
          let r2 = this._int >> 16 & 255;
          let g2 = this._int >> 8 & 255;
          let b2 = this._int & 255;
          if (applyToRGB) {
            r2 = r2 * alpha + 0.5 | 0;
            g2 = g2 * alpha + 0.5 | 0;
            b2 = b2 * alpha + 0.5 | 0;
          }
          return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        /**
         * Convert to a hexadecimal string.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toHex(); // returns "#ffffff"
         */
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        /**
         * Convert to a hexadecimal string with alpha.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toHexa(); // returns "#ffffffff"
         */
        toHexa() {
          const alphaValue = Math.round(this._components[3] * 255);
          const alphaString = alphaValue.toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        /**
         * Set alpha, suitable for chaining.
         * @param alpha
         */
        setAlpha(alpha) {
          this._components[3] = this._clamp(alpha);
          return this;
        }
        /**
         * Normalize the input value into rgba
         * @param value - Input value
         */
        _normalize(value) {
          let r2;
          let g2;
          let b2;
          let a2;
          if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r2 = (int >> 16 & 255) / 255;
            g2 = (int >> 8 & 255) / 255;
            b2 = (int & 255) / 255;
            a2 = 1;
          } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r2, g2, b2, a2 = 1] = value;
          } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r2, g2, b2, a2 = 255] = value;
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
            a2 /= 255;
          } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
              const match = _Color2.HEX_PATTERN.exec(value);
              if (match) {
                value = `#${match[2]}`;
              }
            }
            const color = w(value);
            if (color.isValid()) {
              ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
              r2 /= 255;
              g2 /= 255;
              b2 /= 255;
            }
          }
          if (r2 !== void 0) {
            this._components[0] = r2;
            this._components[1] = g2;
            this._components[2] = b2;
            this._components[3] = a2;
            this._refreshInt();
          } else {
            throw new Error(`Unable to convert color ${value}`);
          }
        }
        /** Refresh the internal color rgb number */
        _refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        /**
         * Clamps values to a range. Will override original values
         * @param value - Value(s) to clamp
         * @param min - Minimum value
         * @param max - Maximum value
         */
        _clamp(value, min = 0, max = 1) {
          if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
          }
          value.forEach((v2, i3) => {
            value[i3] = Math.min(Math.max(v2, min), max);
          });
          return value;
        }
        /**
         * Check if the value is a color-like object
         * @param value - Value to check
         * @returns True if the value is a color-like object
         * @static
         * @example
         * import { Color } from 'pixi.js';
         * Color.isColorLike('white'); // returns true
         * Color.isColorLike(0xffffff); // returns true
         * Color.isColorLike([1, 1, 1]); // returns true
         */
        static isColorLike(value) {
          return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
        }
      };
      _Color.shared = new _Color();
      _Color._temp = new _Color();
      _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
      Color = _Color;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/culling/cullingMixin.mjs
  var cullingMixin;
  var init_cullingMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
      "use strict";
      cullingMixin = {
        cullArea: null,
        cullable: false,
        cullableChildren: true
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/misc/const.mjs
  var PI_2, RAD_TO_DEG, DEG_TO_RAD;
  var init_const = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/misc/const.mjs"() {
      "use strict";
      PI_2 = Math.PI * 2;
      RAD_TO_DEG = 180 / Math.PI;
      DEG_TO_RAD = Math.PI / 180;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/point/Point.mjs
  var Point, tempPoint;
  var init_Point = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/point/Point.mjs"() {
      "use strict";
      Point = class {
        /**
         * Creates a new `Point`
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(x2 = 0, y2 = 0) {
          this.x = 0;
          this.y = 0;
          this.x = x2;
          this.y = y2;
        }
        /**
         * Creates a clone of this point
         * @returns A clone of this point
         */
        clone() {
          return new Point(this.x, this.y);
        }
        /**
         * Copies `x` and `y` from the given point into this point
         * @param p - The point to copy from
         * @returns The point instance itself
         */
        copyFrom(p3) {
          this.set(p3.x, p3.y);
          return this;
        }
        /**
         * Copies this point's x and y into the given point (`p`).
         * @param p - The point to copy to. Can be any of type that is or extends `PointData`
         * @returns The point (`p`) with values updated
         */
        copyTo(p3) {
          p3.set(this.x, this.y);
          return p3;
        }
        /**
         * Accepts another point (`p`) and returns `true` if the given point is equal to this point
         * @param p - The point to check
         * @returns Returns `true` if both `x` and `y` are equal
         */
        equals(p3) {
          return p3.x === this.x && p3.y === this.y;
        }
        /**
         * Sets the point to a new `x` and `y` position.
         * If `y` is omitted, both `x` and `y` will be set to `x`.
         * @param {number} [x=0] - position of the point on the `x` axis
         * @param {number} [y=x] - position of the point on the `y` axis
         * @returns The point instance itself
         */
        set(x2 = 0, y2 = x2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        /**
         * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
         * @readonly
         */
        static get shared() {
          tempPoint.x = 0;
          tempPoint.y = 0;
          return tempPoint;
        }
      };
      tempPoint = new Point();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
  var Matrix, tempMatrix, identityMatrix;
  var init_Matrix = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
      init_const();
      init_Point();
      Matrix = class {
        /**
         * @param a - x scale
         * @param b - y skew
         * @param c - x skew
         * @param d - y scale
         * @param tx - x translation
         * @param ty - y translation
         */
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null;
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
        }
        /**
         * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
         *
         * a = array[0]
         * b = array[1]
         * c = array[3]
         * d = array[4]
         * tx = array[2]
         * ty = array[5]
         * @param array - The array that the matrix will be populated from.
         */
        fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        }
        /**
         * Sets the matrix properties.
         * @param a - Matrix component
         * @param b - Matrix component
         * @param c - Matrix component
         * @param d - Matrix component
         * @param tx - Matrix component
         * @param ty - Matrix component
         * @returns This matrix. Good for chaining method calls.
         */
        set(a2, b2, c2, d2, tx, ty) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
          return this;
        }
        /**
         * Creates an array from the current Matrix object.
         * @param transpose - Whether we need to transpose the matrix or not
         * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
         * @returns The newly created array which contains the matrix
         */
        toArray(transpose, out2) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }
          const array = out2 || this.array;
          if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }
          return array;
        }
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         * @param pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @returns {Point} The new point, transformed through this matrix
         */
        apply(pos, newPos) {
          newPos = newPos || new Point();
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = this.a * x2 + this.c * y2 + this.tx;
          newPos.y = this.b * x2 + this.d * y2 + this.ty;
          return newPos;
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         * @param pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @returns {Point} The new point, inverse-transformed through this matrix
         */
        applyInverse(pos, newPos) {
          newPos = newPos || new Point();
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const tx = this.tx;
          const ty = this.ty;
          const id = 1 / (a2 * d2 + c2 * -b2);
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
          newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
          return newPos;
        }
        /**
         * Translates the matrix on the x and y.
         * @param x - How much to translate x by
         * @param y - How much to translate y by
         * @returns This matrix. Good for chaining method calls.
         */
        translate(x2, y2) {
          this.tx += x2;
          this.ty += y2;
          return this;
        }
        /**
         * Applies a scale transformation to the matrix.
         * @param x - The amount to scale horizontally
         * @param y - The amount to scale vertically
         * @returns This matrix. Good for chaining method calls.
         */
        scale(x2, y2) {
          this.a *= x2;
          this.d *= y2;
          this.c *= x2;
          this.b *= y2;
          this.tx *= x2;
          this.ty *= y2;
          return this;
        }
        /**
         * Applies a rotation transformation to the matrix.
         * @param angle - The angle in radians.
         * @returns This matrix. Good for chaining method calls.
         */
        rotate(angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const a1 = this.a;
          const c1 = this.c;
          const tx1 = this.tx;
          this.a = a1 * cos - this.b * sin;
          this.b = a1 * sin + this.b * cos;
          this.c = c1 * cos - this.d * sin;
          this.d = c1 * sin + this.d * cos;
          this.tx = tx1 * cos - this.ty * sin;
          this.ty = tx1 * sin + this.ty * cos;
          return this;
        }
        /**
         * Appends the given Matrix to this Matrix.
         * @param matrix - The matrix to append.
         * @returns This matrix. Good for chaining method calls.
         */
        append(matrix) {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;
          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
          return this;
        }
        /**
         * Appends two matrix's and sets the result to this matrix. AB = A * B
         * @param a - The matrix to append.
         * @param b - The matrix to append.
         * @returns This matrix. Good for chaining method calls.
         */
        appendFrom(a2, b2) {
          const a1 = a2.a;
          const b1 = a2.b;
          const c1 = a2.c;
          const d1 = a2.d;
          const tx = a2.tx;
          const ty = a2.ty;
          const a22 = b2.a;
          const b22 = b2.b;
          const c2 = b2.c;
          const d2 = b2.d;
          this.a = a1 * a22 + b1 * c2;
          this.b = a1 * b22 + b1 * d2;
          this.c = c1 * a22 + d1 * c2;
          this.d = c1 * b22 + d1 * d2;
          this.tx = tx * a22 + ty * c2 + b2.tx;
          this.ty = tx * b22 + ty * d2 + b2.ty;
          return this;
        }
        /**
         * Sets the matrix based on all the available properties
         * @param x - Position on the x axis
         * @param y - Position on the y axis
         * @param pivotX - Pivot on the x axis
         * @param pivotY - Pivot on the y axis
         * @param scaleX - Scale on the x axis
         * @param scaleY - Scale on the y axis
         * @param rotation - Rotation in radians
         * @param skewX - Skew on the x axis
         * @param skewY - Skew on the y axis
         * @returns This matrix. Good for chaining method calls.
         */
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;
          this.tx = x2 - (pivotX * this.a + pivotY * this.c);
          this.ty = y2 - (pivotX * this.b + pivotY * this.d);
          return this;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         * @param matrix - The matrix to prepend
         * @returns This matrix. Good for chaining method calls.
         */
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }
          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
          return this;
        }
        /**
         * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
         * @param transform - The transform to apply the properties to.
         * @returns The transform with the newly applied properties
         */
        decompose(transform2) {
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const pivot = transform2.pivot;
          const skewX = -Math.atan2(-c2, d2);
          const skewY = Math.atan2(b2, a2);
          const delta = Math.abs(skewX + skewY);
          if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
            transform2.rotation = skewY;
            transform2.skew.x = transform2.skew.y = 0;
          } else {
            transform2.rotation = 0;
            transform2.skew.x = skewX;
            transform2.skew.y = skewY;
          }
          transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
          transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
          transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
          transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
          return transform2;
        }
        /**
         * Inverts this matrix
         * @returns This matrix. Good for chaining method calls.
         */
        invert() {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          const tx1 = this.tx;
          const n2 = a1 * d1 - b1 * c1;
          this.a = d1 / n2;
          this.b = -b1 / n2;
          this.c = -c1 / n2;
          this.d = a1 / n2;
          this.tx = (c1 * this.ty - d1 * tx1) / n2;
          this.ty = -(a1 * this.ty - b1 * tx1) / n2;
          return this;
        }
        /** Checks if this matrix is an identity matrix */
        isIdentity() {
          return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        /**
         * Resets this Matrix to an identity (default) matrix.
         * @returns This matrix. Good for chaining method calls.
         */
        identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;
          return this;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         * @returns A copy of this matrix. Good for chaining method calls.
         */
        clone() {
          const matrix = new Matrix();
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         * @param matrix - The matrix to copy to.
         * @returns The matrix given in parameter with its values updated.
         */
        copyTo(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the matrix to be the same as the ones in given matrix
         * @param matrix - The matrix to copy from.
         * @returns this
         */
        copyFrom(matrix) {
          this.a = matrix.a;
          this.b = matrix.b;
          this.c = matrix.c;
          this.d = matrix.d;
          this.tx = matrix.tx;
          this.ty = matrix.ty;
          return this;
        }
        /**
         * check to see if two matrices are the same
         * @param matrix - The matrix to compare to.
         */
        equals(matrix) {
          return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        /**
         * A default (identity) matrix.
         *
         * This is a shared object, if you want to modify it consider creating a new `Matrix`
         * @readonly
         */
        static get IDENTITY() {
          return identityMatrix.identity();
        }
        /**
         * A static Matrix that can be used to avoid creating new objects.
         * Will always ensure the matrix is reset to identity when requested.
         * Use this object for fast but temporary calculations, as it may be mutated later on.
         * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
         * @readonly
         */
        static get shared() {
          return tempMatrix.identity();
        }
      };
      tempMatrix = new Matrix();
      identityMatrix = new Matrix();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
  var ObservablePoint;
  var init_ObservablePoint = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
      "use strict";
      ObservablePoint = class {
        /**
         * Creates a new `ObservablePoint`
         * @param observer - Observer to pass to listen for change events.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(observer, x2, y2) {
          this._x = x2 || 0;
          this._y = y2 || 0;
          this._observer = observer;
        }
        /**
         * Creates a clone of this point.
         * @param observer - Optional observer to pass to the new observable point.
         * @returns a copy of this observable point
         */
        clone(observer) {
          return new ObservablePoint(observer ?? this._observer, this._x, this._y);
        }
        /**
         * Sets the point to a new `x` and `y` position.
         * If `y` is omitted, both `x` and `y` will be set to `x`.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=x] - position of the point on the y axis
         * @returns The observable point instance itself
         */
        set(x2 = 0, y2 = x2) {
          if (this._x !== x2 || this._y !== y2) {
            this._x = x2;
            this._y = y2;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies x and y from the given point (`p`)
         * @param p - The point to copy from. Can be any of type that is or extends `PointData`
         * @returns The observable point instance itself
         */
        copyFrom(p3) {
          if (this._x !== p3.x || this._y !== p3.y) {
            this._x = p3.x;
            this._y = p3.y;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies this point's x and y into that of the given point (`p`)
         * @param p - The point to copy to. Can be any of type that is or extends `PointData`
         * @returns The point (`p`) with values updated
         */
        copyTo(p3) {
          p3.set(this._x, this._y);
          return p3;
        }
        /**
         * Accepts another point (`p`) and returns `true` if the given point is equal to this point
         * @param p - The point to check
         * @returns Returns `true` if both `x` and `y` are equal
         */
        equals(p3) {
          return p3.x === this._x && p3.y === this._y;
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
        }
        /** Position of the observable point on the x axis. */
        get x() {
          return this._x;
        }
        set x(value) {
          if (this._x !== value) {
            this._x = value;
            this._observer._onUpdate(this);
          }
        }
        /** Position of the observable point on the y axis. */
        get y() {
          return this._y;
        }
        set y(value) {
          if (this._y !== value) {
            this._y = value;
            this._observer._onUpdate(this);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/uid.mjs
  function uid(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }
  function resetUids() {
    for (const key in uidCache) {
      delete uidCache[key];
    }
  }
  var uidCache;
  var init_uid = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/uid.mjs"() {
      "use strict";
      uidCache = {
        default: -1
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/deprecation.mjs
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed(
          "%cPixiJS Deprecation Warning: %c%s",
          "color:#614108;background:#fffbe6",
          "font-weight:normal;color:#614108;background:#fffbe6",
          `${message}
Deprecated since v${version}`
        );
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings[message] = true;
  }
  var warnings, v8_0_0, v8_3_4;
  var init_deprecation = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
      "use strict";
      warnings = {};
      v8_0_0 = "8.0.0";
      v8_3_4 = "8.3.4";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/pool/Pool.mjs
  var Pool;
  var init_Pool = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
      "use strict";
      Pool = class {
        /**
         * Constructs a new Pool.
         * @param ClassType - The constructor of the items in the pool.
         * @param {number} [initialSize] - The initial size of the pool.
         */
        constructor(ClassType, initialSize) {
          this._pool = [];
          this._count = 0;
          this._index = 0;
          this._classType = ClassType;
          if (initialSize) {
            this.prepopulate(initialSize);
          }
        }
        /**
         * Prepopulates the pool with a given number of items.
         * @param total - The number of items to add to the pool.
         */
        prepopulate(total) {
          for (let i3 = 0; i3 < total; i3++) {
            this._pool[this._index++] = new this._classType();
          }
          this._count += total;
        }
        /**
         * Gets an item from the pool. Calls the item's `init` method if it exists.
         * If there are no items left in the pool, a new one will be created.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(data) {
          let item;
          if (this._index > 0) {
            item = this._pool[--this._index];
          } else {
            item = new this._classType();
          }
          item.init?.(data);
          return item;
        }
        /**
         * Returns an item to the pool. Calls the item's `reset` method if it exists.
         * @param {T} item - The item to return to the pool.
         */
        return(item) {
          item.reset?.();
          this._pool[this._index++] = item;
        }
        /**
         * Gets the number of items in the pool.
         * @readonly
         * @member {number}
         */
        get totalSize() {
          return this._count;
        }
        /**
         * Gets the number of items in the pool that are free to use without needing to create more.
         * @readonly
         * @member {number}
         */
        get totalFree() {
          return this._index;
        }
        /**
         * Gets the number of items in the pool that are currently in use.
         * @readonly
         * @member {number}
         */
        get totalUsed() {
          return this._count - this._index;
        }
        /** clears the pool - mainly used for debugging! */
        clear() {
          this._pool.length = 0;
          this._index = 0;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass, BigPool;
  var init_PoolGroup = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
      init_Pool();
      PoolGroupClass = class {
        constructor() {
          this._poolsByClass = /* @__PURE__ */ new Map();
        }
        /**
         * Prepopulates a specific pool with a given number of items.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {number} total - The number of items to add to the pool.
         */
        prepopulate(Class, total) {
          const classPool = this.getPool(Class);
          classPool.prepopulate(total);
        }
        /**
         * Gets an item from a specific pool.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(Class, data) {
          const pool = this.getPool(Class);
          return pool.get(data);
        }
        /**
         * Returns an item to its respective pool.
         * @param {PoolItem} item - The item to return to the pool.
         */
        return(item) {
          const pool = this.getPool(item.constructor);
          pool.return(item);
        }
        /**
         * Gets a specific pool based on the class type.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
         * @returns {Pool<T>} The pool of the given class type.
         */
        getPool(ClassType) {
          if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new Pool(ClassType));
          }
          return this._poolsByClass.get(ClassType);
        }
        /** gets the usage stats of each pool in the system */
        stats() {
          const stats = {};
          this._poolsByClass.forEach((pool) => {
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
              free: pool.totalFree,
              used: pool.totalUsed,
              size: pool.totalSize
            };
          });
          return stats;
        }
      };
      BigPool = new PoolGroupClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i3;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i3 = startIdx; i3 < len; ++i3) {
      arr[i3] = arr[i3 + removeCount];
    }
    arr.length = len;
  }
  var init_removeItems = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin;
  var init_childrenHelperMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
      init_removeItems();
      init_deprecation();
      childrenHelperMixin = {
        allowChildren: true,
        /**
         * Removes all children from this container that are within the begin and end indexes.
         * @param beginIndex - The beginning position.
         * @param endIndex - The ending position. Default value is size of the container.
         * @returns - List of removed children
         * @memberof scene.Container#
         */
        removeChildren(beginIndex = 0, endIndex) {
          const end = endIndex ?? this.children.length;
          const range = end - beginIndex;
          const removed = [];
          if (range > 0 && range <= end) {
            for (let i3 = end - 1; i3 >= beginIndex; i3--) {
              const child = this.children[i3];
              if (!child)
                continue;
              removed.push(child);
              child.parent = null;
            }
            removeItems(this.children, beginIndex, end);
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
              renderGroup.removeChildren(removed);
            }
            for (let i3 = 0; i3 < removed.length; ++i3) {
              this.emit("childRemoved", removed[i3], this, i3);
              removed[i3].emit("removed", this);
            }
            return removed;
          } else if (range === 0 && this.children.length === 0) {
            return removed;
          }
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        /**
         * Removes a child from the specified index position.
         * @param index - The index to get the child from
         * @returns The child that was removed.
         * @memberof scene.Container#
         */
        removeChildAt(index) {
          const child = this.getChildAt(index);
          return this.removeChild(child);
        },
        /**
         * Returns the child at the specified index
         * @param index - The index to get the child at
         * @returns - The child at the given index, if any.
         * @memberof scene.Container#
         */
        getChildAt(index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
          }
          return this.children[index];
        },
        /**
         * Changes the position of an existing child in the container container
         * @param child - The child Container instance for which you want to change the index number
         * @param index - The resulting index number for the child container
         * @memberof scene.Container#
         */
        setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
          }
          this.getChildIndex(child);
          this.addChildAt(child, index);
        },
        /**
         * Returns the index position of a child Container instance
         * @param child - The Container instance to identify
         * @returns - The index position of the child container to identify
         * @memberof scene.Container#
         */
        getChildIndex(child) {
          const index = this.children.indexOf(child);
          if (index === -1) {
            throw new Error("The supplied Container must be a child of the caller");
          }
          return index;
        },
        /**
         * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
         * If the child is already in this container, it will be moved to the specified index.
         * @param {Container} child - The child to add.
         * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
         * @returns {Container} The child that was added.
         * @memberof scene.Container#
         */
        addChildAt(child, index) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
          }
          const { children } = this;
          if (index < 0 || index > children.length) {
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
          }
          if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index) {
              return child;
            }
            if (currentIndex !== -1) {
              child.parent.children.splice(currentIndex, 1);
            }
          }
          if (index === children.length) {
            children.push(child);
          } else {
            children.splice(index, 0, child);
          }
          child.parent = this;
          child.didChange = true;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          if (this.sortableChildren)
            this.sortDirty = true;
          this.emit("childAdded", child, this, index);
          child.emit("added", this);
          return child;
        },
        /**
         * Swaps the position of 2 Containers within this container.
         * @param child - First container to swap
         * @param child2 - Second container to swap
         * @memberof scene.Container#
         */
        swapChildren(child, child2) {
          if (child === child2) {
            return;
          }
          const index1 = this.getChildIndex(child);
          const index2 = this.getChildIndex(child2);
          this.children[index1] = child2;
          this.children[index2] = child;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._didContainerChangeTick++;
        },
        /**
         * Remove the Container from its parent Container. If the Container has no parent, do nothing.
         * @memberof scene.Container#
         */
        removeFromParent() {
          this.parent?.removeChild(this);
        },
        /**
         * Reparent the child to this container, keeping the same worldTransform.
         * @param child - The child to reparent
         * @returns The first child that was reparented.
         * @memberof scene.Container#
         */
        reparentChild(...child) {
          if (child.length === 1) {
            return this.reparentChildAt(child[0], this.children.length);
          }
          child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
          return child[0];
        },
        /**
         * Reparent the child to this container at the specified index, keeping the same worldTransform.
         * @param child - The child to reparent
         * @param index - The index to reparent the child to
         * @memberof scene.Container#
         */
        reparentChildAt(child, index) {
          if (child.parent === this) {
            this.setChildIndex(child, index);
            return child;
          }
          const childMat = child.worldTransform.clone();
          child.removeFromParent();
          this.addChildAt(child, index);
          const newMatrix = this.worldTransform.clone();
          newMatrix.invert();
          childMat.prepend(newMatrix);
          child.setFromMatrix(childMat);
          return child;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/FilterEffect.mjs
  var FilterEffect;
  var init_FilterEffect = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
      "use strict";
      FilterEffect = class {
        constructor() {
          this.pipe = "filter";
          this.priority = 1;
        }
        destroy() {
          for (let i3 = 0; i3 < this.filters.length; i3++) {
            this.filters[i3].destroy();
          }
          this.filters = null;
          this.filterArea = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass, MaskEffectManager;
  var init_MaskEffectManager = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
      init_Extensions();
      init_PoolGroup();
      MaskEffectManagerClass = class {
        constructor() {
          this._effectClasses = [];
          this._tests = [];
          this._initialized = false;
        }
        init() {
          if (this._initialized)
            return;
          this._initialized = true;
          this._effectClasses.forEach((test) => {
            this.add({
              test: test.test,
              maskClass: test
            });
          });
        }
        add(test) {
          this._tests.push(test);
        }
        getMaskEffect(item) {
          if (!this._initialized)
            this.init();
          for (let i3 = 0; i3 < this._tests.length; i3++) {
            const test = this._tests[i3];
            if (test.test(item)) {
              return BigPool.get(test.maskClass, item);
            }
          }
          return item;
        }
        returnMaskEffect(effect) {
          BigPool.return(effect);
        }
      };
      MaskEffectManager = new MaskEffectManagerClass();
      extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin;
  var init_effectsMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
      init_FilterEffect();
      init_MaskEffectManager();
      effectsMixin = {
        _maskEffect: null,
        _maskOptions: {
          inverse: false
        },
        _filterEffect: null,
        /**
         * @todo Needs docs.
         * @memberof scene.Container#
         * @type {Array<Effect>}
         */
        effects: [],
        /**
         * @todo Needs docs.
         * @param effect - The effect to add.
         * @memberof scene.Container#
         * @ignore
         */
        addEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index !== -1)
            return;
          this.effects.push(effect);
          this.effects.sort((a2, b2) => a2.priority - b2.priority);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        /**
         * @todo Needs docs.
         * @param effect - The effect to remove.
         * @memberof scene.Container#
         * @ignore
         */
        removeEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index === -1)
            return;
          this.effects.splice(index, 1);
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        set mask(value) {
          const effect = this._maskEffect;
          if (effect?.mask === value)
            return;
          if (effect) {
            this.removeEffect(effect);
            MaskEffectManager.returnMaskEffect(effect);
            this._maskEffect = null;
          }
          if (value === null || value === void 0)
            return;
          this._maskEffect = MaskEffectManager.getMaskEffect(value);
          this.addEffect(this._maskEffect);
        },
        /**
         * Used to set mask and control mask options.
         * @param options
         * @example
         * import { Graphics, Sprite } from 'pixi.js';
         *
         * const graphics = new Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new Sprite(texture);
         * sprite.setMask({
         *     mask: graphics,
         *     inverse: true,
         * });
         * @memberof scene.Container#
         */
        setMask(options) {
          this._maskOptions = {
            ...this._maskOptions,
            ...options
          };
          if (options.mask) {
            this.mask = options.mask;
          }
        },
        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
         * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
         * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
         * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
         * To remove a mask, set this property to `null`.
         *
         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
         * @example
         * import { Graphics, Sprite } from 'pixi.js';
         *
         * const graphics = new Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new Sprite(texture);
         * sprite.mask = graphics;
         * @memberof scene.Container#
         */
        get mask() {
          return this._maskEffect?.mask;
        },
        set filters(value) {
          if (!Array.isArray(value) && value)
            value = [value];
          const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
          value = value;
          const hasFilters = value?.length > 0;
          const hadFilters = effect.filters?.length > 0;
          const didChange = hasFilters !== hadFilters;
          value = Array.isArray(value) ? value.slice(0) : value;
          effect.filters = Object.freeze(value);
          if (didChange) {
            if (hasFilters) {
              this.addEffect(effect);
            } else {
              this.removeEffect(effect);
              effect.filters = value ?? null;
            }
          }
        },
        /**
         * Sets the filters for the displayObject.
         * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         * @memberof scene.Container#
         */
        get filters() {
          return this._filterEffect?.filters;
        },
        set filterArea(value) {
          this._filterEffect || (this._filterEffect = new FilterEffect());
          this._filterEffect.filterArea = value;
        },
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         * @memberof scene.Container#
         */
        get filterArea() {
          return this._filterEffect?.filterArea;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin;
  var init_findMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
      init_deprecation();
      findMixin = {
        /**
         * The instance label of the object.
         * @memberof scene.Container#
         * @member {string} label
         */
        label: null,
        /**
         * The instance name of the object.
         * @deprecated since 8.0.0
         * @see scene.Container#label
         * @member {string} name
         * @memberof scene.Container#
         */
        get name() {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          return this.label;
        },
        set name(value) {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          this.label = value;
        },
        /**
         * @method getChildByName
         * @deprecated since 8.0.0
         * @param {string} name - Instance name.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @returns {Container} The child with the specified name.
         * @see scene.Container#getChildByLabel
         * @memberof scene.Container#
         */
        getChildByName(name, deep = false) {
          return this.getChildByLabel(name, deep);
        },
        /**
         * Returns the first child in the container with the specified label.
         *
         * Recursive searches are done in a pre-order traversal.
         * @memberof scene.Container#
         * @param {string|RegExp} label - Instance label.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @returns {Container} The child with the specified label.
         */
        getChildByLabel(label, deep = false) {
          const children = this.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            if (child.label === label || label instanceof RegExp && label.test(child.label))
              return child;
          }
          if (deep) {
            for (let i3 = 0; i3 < children.length; i3++) {
              const child = children[i3];
              const found = child.getChildByLabel(label, true);
              if (found) {
                return found;
              }
            }
          }
          return null;
        },
        /**
         * Returns all children in the container with the specified label.
         * @memberof scene.Container#
         * @param {string|RegExp} label - Instance label.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @param {Container[]} [out=[]] - The array to store matching children in.
         * @returns {Container[]} An array of children with the specified label.
         */
        getChildrenByLabel(label, deep = false, out2 = []) {
          const children = this.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) {
              out2.push(child);
            }
          }
          if (deep) {
            for (let i3 = 0; i3 < children.length; i3++) {
              children[i3].getChildrenByLabel(label, true, out2);
            }
          }
          return out2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
  var tempPoints, Rectangle;
  var init_Rectangle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
      init_Point();
      tempPoints = [new Point(), new Point(), new Point(), new Point()];
      Rectangle = class {
        /**
         * @param x - The X coordinate of the upper-left corner of the rectangle
         * @param y - The Y coordinate of the upper-left corner of the rectangle
         * @param width - The overall width of the rectangle
         * @param height - The overall height of the rectangle
         */
        constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
          this.type = "rectangle";
          this.x = Number(x2);
          this.y = Number(y2);
          this.width = Number(width);
          this.height = Number(height);
        }
        /** Returns the left edge of the rectangle. */
        get left() {
          return this.x;
        }
        /** Returns the right edge of the rectangle. */
        get right() {
          return this.x + this.width;
        }
        /** Returns the top edge of the rectangle. */
        get top() {
          return this.y;
        }
        /** Returns the bottom edge of the rectangle. */
        get bottom() {
          return this.y + this.height;
        }
        /** Determines whether the Rectangle is empty. */
        isEmpty() {
          return this.left === this.right || this.top === this.bottom;
        }
        /** A constant empty rectangle. This is a new object every time the property is accessed */
        static get EMPTY() {
          return new Rectangle(0, 0, 0, 0);
        }
        /**
         * Creates a clone of this Rectangle
         * @returns a copy of the rectangle
         */
        clone() {
          return new Rectangle(this.x, this.y, this.width, this.height);
        }
        /**
         * Converts a Bounds object to a Rectangle object.
         * @param bounds - The bounds to copy and convert to a rectangle.
         * @returns Returns itself.
         */
        copyFromBounds(bounds) {
          this.x = bounds.minX;
          this.y = bounds.minY;
          this.width = bounds.maxX - bounds.minX;
          this.height = bounds.maxY - bounds.minY;
          return this;
        }
        /**
         * Copies another rectangle to this one.
         * @param rectangle - The rectangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @param rectangle - The rectangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Rectangle
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 < this.x + this.width) {
            if (y2 >= this.y && y2 < this.y + this.height) {
              return true;
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this rectangle
         */
        strokeContains(x2, y2, strokeWidth) {
          const { width, height } = this;
          if (width <= 0 || height <= 0)
            return false;
          const _x = this.x;
          const _y = this.y;
          const outerLeft = _x - strokeWidth / 2;
          const outerRight = _x + width + strokeWidth / 2;
          const outerTop = _y - strokeWidth / 2;
          const outerBottom = _y + height + strokeWidth / 2;
          const innerLeft = _x + strokeWidth / 2;
          const innerRight = _x + width - strokeWidth / 2;
          const innerTop = _y + strokeWidth / 2;
          const innerBottom = _y + height - strokeWidth / 2;
          return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
        }
        /**
         * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
         * Returns true only if the area of the intersection is >0, this means that Rectangles
         * sharing a side are not overlapping. Another side effect is that an arealess rectangle
         * (width or height equal to zero) can't intersect any other rectangle.
         * @param {Rectangle} other - The Rectangle to intersect with `this`.
         * @param {Matrix} transform - The transformation matrix of `other`.
         * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
         */
        intersects(other, transform2) {
          if (!transform2) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
              return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
          }
          const x0 = this.left;
          const x1 = this.right;
          const y0 = this.top;
          const y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0) {
            return false;
          }
          const lt = tempPoints[0].set(other.left, other.top);
          const lb = tempPoints[1].set(other.left, other.bottom);
          const rt = tempPoints[2].set(other.right, other.top);
          const rb = tempPoints[3].set(other.right, other.bottom);
          if (rt.x <= lt.x || lb.y <= lt.y) {
            return false;
          }
          const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
          if (s2 === 0) {
            return false;
          }
          transform2.apply(lt, lt);
          transform2.apply(lb, lb);
          transform2.apply(rt, rt);
          transform2.apply(rb, rb);
          if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
          }
          const nx = s2 * (lb.y - lt.y);
          const ny = s2 * (lt.x - lb.x);
          const n00 = nx * x0 + ny * y0;
          const n10 = nx * x1 + ny * y0;
          const n01 = nx * x0 + ny * y1;
          const n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
          }
          const mx = s2 * (lt.y - rt.y);
          const my = s2 * (rt.x - lt.x);
          const m00 = mx * x0 + my * y0;
          const m10 = mx * x1 + my * y0;
          const m01 = mx * x0 + my * y1;
          const m11 = mx * x1 + my * y1;
          if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
          }
          return true;
        }
        /**
         * Pads the rectangle making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @param paddingX - The horizontal padding amount.
         * @param paddingY - The vertical padding amount.
         * @returns Returns itself.
         */
        pad(paddingX = 0, paddingY = paddingX) {
          this.x -= paddingX;
          this.y -= paddingY;
          this.width += paddingX * 2;
          this.height += paddingY * 2;
          return this;
        }
        /**
         * Fits this rectangle around the passed one.
         * @param rectangle - The rectangle to fit.
         * @returns Returns itself.
         */
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x);
          const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.max(this.y, rectangle.y);
          const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
          return this;
        }
        /**
         * Enlarges rectangle that way its corners lie on grid
         * @param resolution - resolution
         * @param eps - precision
         * @returns Returns itself.
         */
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;
          this.width = x2 - this.x;
          this.height = y2 - this.y;
          return this;
        }
        /**
         * Enlarges this rectangle to include the passed rectangle.
         * @param rectangle - The rectangle to include.
         * @returns Returns itself.
         */
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x);
          const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.min(this.y, rectangle.y);
          const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
          return this;
        }
        /**
         * Returns the framing rectangle of the rectangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.copyFrom(this);
          return out2;
        }
        toString() {
          return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
  var defaultMatrix, Bounds;
  var init_Bounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
      init_Matrix();
      init_Rectangle();
      defaultMatrix = new Matrix();
      Bounds = class {
        constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if bounds are empty.
         * @returns - True if empty.
         */
        isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }
        /** The bounding rectangle of the bounds. */
        get rectangle() {
          if (!this._rectangle) {
            this._rectangle = new Rectangle();
          }
          const rectangle = this._rectangle;
          if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
          } else {
            rectangle.copyFromBounds(this);
          }
          return rectangle;
        }
        /** Clears the bounds and resets. */
        clear() {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          return this;
        }
        /**
         * Sets the bounds.
         * @param x0 - left X of frame
         * @param y0 - top Y of frame
         * @param x1 - right X of frame
         * @param y1 - bottom Y of frame
         */
        set(x0, y0, x1, y1) {
          this.minX = x0;
          this.minY = y0;
          this.maxX = x1;
          this.maxY = y1;
        }
        /**
         * Adds sprite frame
         * @param x0 - left X of frame
         * @param y0 - top Y of frame
         * @param x1 - right X of frame
         * @param y1 - bottom Y of frame
         * @param matrix
         */
        addFrame(x0, y0, x1, y1, matrix) {
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          let x2 = a2 * x0 + c2 * y0 + tx;
          let y2 = b2 * x0 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y0 + tx;
          y2 = b2 * x1 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x0 + c2 * y1 + tx;
          y2 = b2 * x0 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y1 + tx;
          y2 = b2 * x1 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Adds a rectangle to the bounds.
         * @param rect - The rectangle to be added.
         * @param matrix - The matrix to apply to the bounds.
         */
        addRect(rect, matrix) {
          this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
        }
        /**
         * Adds other {@link Bounds}.
         * @param bounds - The Bounds to be added
         * @param matrix
         */
        addBounds(bounds, matrix) {
          this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
        }
        /**
         * Adds other Bounds, masked with Bounds.
         * @param mask - The Bounds to be added.
         */
        addBoundsMask(mask) {
          this.minX = this.minX > mask.minX ? this.minX : mask.minX;
          this.minY = this.minY > mask.minY ? this.minY : mask.minY;
          this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
          this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
        }
        /**
         * Adds other Bounds, multiplied with matrix.
         * @param matrix - The matrix to apply to the bounds.
         */
        applyMatrix(matrix) {
          const minX = this.minX;
          const minY = this.minY;
          const maxX = this.maxX;
          const maxY = this.maxY;
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
          let x2 = a2 * minX + c2 * minY + tx;
          let y2 = b2 * minX + d2 * minY + ty;
          this.minX = x2;
          this.minY = y2;
          this.maxX = x2;
          this.maxY = y2;
          x2 = a2 * maxX + c2 * minY + tx;
          y2 = b2 * maxX + d2 * minY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * minX + c2 * maxY + tx;
          y2 = b2 * minX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * maxX + c2 * maxY + tx;
          y2 = b2 * maxX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
        }
        /**
         * Resizes the bounds object to include the given rectangle.
         * @param rect - The rectangle to be included.
         */
        fit(rect) {
          if (this.minX < rect.left)
            this.minX = rect.left;
          if (this.maxX > rect.right)
            this.maxX = rect.right;
          if (this.minY < rect.top)
            this.minY = rect.top;
          if (this.maxY > rect.bottom)
            this.maxY = rect.bottom;
          return this;
        }
        /**
         * Resizes the bounds object to include the given bounds.
         * @param left - The left value of the bounds.
         * @param right - The right value of the bounds.
         * @param top - The top value of the bounds.
         * @param bottom - The bottom value of the bounds.
         */
        fitBounds(left, right, top, bottom) {
          if (this.minX < left)
            this.minX = left;
          if (this.maxX > right)
            this.maxX = right;
          if (this.minY < top)
            this.minY = top;
          if (this.maxY > bottom)
            this.maxY = bottom;
          return this;
        }
        /**
         * Pads bounds object, making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @param paddingX - The horizontal padding amount.
         * @param paddingY - The vertical padding amount.
         */
        pad(paddingX, paddingY = paddingX) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
          return this;
        }
        /** Ceils the bounds. */
        ceil() {
          this.minX = Math.floor(this.minX);
          this.minY = Math.floor(this.minY);
          this.maxX = Math.ceil(this.maxX);
          this.maxY = Math.ceil(this.maxY);
          return this;
        }
        /** Clones the bounds. */
        clone() {
          return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
        }
        /**
         * Scales the bounds by the given values
         * @param x - The X value to scale by.
         * @param y - The Y value to scale by.
         */
        scale(x2, y2 = x2) {
          this.minX *= x2;
          this.minY *= y2;
          this.maxX *= x2;
          this.maxY *= y2;
          return this;
        }
        /** the x value of the bounds. */
        get x() {
          return this.minX;
        }
        set x(value) {
          const width = this.maxX - this.minX;
          this.minX = value;
          this.maxX = value + width;
        }
        /** the y value of the bounds. */
        get y() {
          return this.minY;
        }
        set y(value) {
          const height = this.maxY - this.minY;
          this.minY = value;
          this.maxY = value + height;
        }
        /** the width value of the bounds. */
        get width() {
          return this.maxX - this.minX;
        }
        set width(value) {
          this.maxX = this.minX + value;
        }
        /** the height value of the bounds. */
        get height() {
          return this.maxY - this.minY;
        }
        set height(value) {
          this.maxY = this.minY + value;
        }
        /** the left value of the bounds. */
        get left() {
          return this.minX;
        }
        /** the right value of the bounds. */
        get right() {
          return this.maxX;
        }
        /** the top value of the bounds. */
        get top() {
          return this.minY;
        }
        /** the bottom value of the bounds. */
        get bottom() {
          return this.maxY;
        }
        /** Is the bounds positive. */
        get isPositive() {
          return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
          return this.minX + this.minY !== Infinity;
        }
        /**
         * Adds screen vertices from array
         * @param vertexData - calculated vertices
         * @param beginOffset - begin offset
         * @param endOffset - end offset, excluded
         * @param matrix
         */
        addVertexData(vertexData, beginOffset, endOffset, matrix) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          for (let i3 = beginOffset; i3 < endOffset; i3 += 2) {
            const localX = vertexData[i3];
            const localY = vertexData[i3 + 1];
            const x2 = a2 * localX + c2 * localY + tx;
            const y2 = b2 * localX + d2 * localY + ty;
            minX = x2 < minX ? x2 : minX;
            minY = y2 < minY ? y2 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if the point is contained within the bounds.
         * @param x - x coordinate
         * @param y - y coordinate
         */
        containsPoint(x2, y2) {
          if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
            return true;
          }
          return false;
        }
        toString() {
          return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
  var matrixPool, boundsPool;
  var init_matrixAndBoundsPool = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
      init_Matrix();
      init_Pool();
      init_Bounds();
      matrixPool = new Pool(Matrix);
      boundsPool = new Pool(Bounds);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target, pooledMatrix);
      } else {
        parentTransform = target.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, worldTransform);
    } else {
      if (target.addBounds) {
        bounds.matrix = worldTransform;
        target.addBounds(bounds);
      }
      for (let i3 = 0; i3 < target.children.length; i3++) {
        _getGlobalBounds(target.children[i3], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i3 = 0; i3 < target.effects.length; i3++) {
        target.effects[i3].addBounds?.(bounds);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      parent.updateLocalTransform();
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }
  var init_getGlobalBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/warn.mjs
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }
  var warnCount, maxWarnings;
  var init_warn = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
      "use strict";
      warnCount = 0;
      maxWarnings = 500;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    let relativeTransform;
    if (!isRoot) {
      if (!target.visible || !target.measurable)
        return;
      target.updateLocalTransform();
      const localTransform = target.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, relativeTransform);
    } else {
      if (target.renderPipeId) {
        bounds.matrix = relativeTransform;
        target.addBounds(bounds);
      }
      const children = target.children;
      for (let i3 = 0; i3 < children.length; i3++) {
        _getLocalBounds(children[i3], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i3 = 0; i3 < target.effects.length; i3++) {
        target.effects[i3].addLocalBounds?.(bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }
  function getParent(target, root, matrix) {
    const parent = target.parent;
    if (!parent) {
      warn("Item is not inside the root container");
      return;
    }
    if (parent !== root) {
      getParent(parent, root, matrix);
      parent.updateLocalTransform();
      matrix.append(parent.localTransform);
    }
  }
  var init_getLocalBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
      init_Matrix();
      init_warn();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
  function checkChildrenDidChange(container, previousData) {
    const children = container.children;
    for (let i3 = 0; i3 < children.length; i3++) {
      const child = children[i3];
      const uid3 = child.uid;
      const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
      const index = previousData.index;
      if (previousData.data[index] !== uid3 || previousData.data[index + 1] !== didChange) {
        previousData.data[previousData.index] = uid3;
        previousData.data[previousData.index + 1] = didChange;
        previousData.didChange = true;
      }
      previousData.index = index + 2;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }
  var init_checkChildrenDidChange = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
  var tempMatrix2, measureMixin;
  var init_measureMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
      init_Matrix();
      init_Bounds();
      init_getGlobalBounds();
      init_getLocalBounds();
      init_checkChildrenDidChange();
      tempMatrix2 = new Matrix();
      measureMixin = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(value, localWidth) {
          const sign = Math.sign(this.scale.x) || 1;
          if (localWidth !== 0) {
            this.scale.x = value / localWidth * sign;
          } else {
            this.scale.x = sign;
          }
        },
        _setHeight(value, localHeight) {
          const sign = Math.sign(this.scale.y) || 1;
          if (localHeight !== 0) {
            this.scale.y = value / localHeight * sign;
          } else {
            this.scale.y = sign;
          }
        },
        /**
         * Retrieves the local bounds of the container as a Bounds object.
         * @returns - The bounding area.
         * @memberof scene.Container#
         */
        getLocalBounds() {
          if (!this._localBoundsCacheData) {
            this._localBoundsCacheData = {
              data: [],
              index: 1,
              didChange: false,
              localBounds: new Bounds()
            };
          }
          const localBoundsCacheData = this._localBoundsCacheData;
          localBoundsCacheData.index = 1;
          localBoundsCacheData.didChange = false;
          if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
            localBoundsCacheData.didChange = true;
            localBoundsCacheData.data[0] = this._didViewChangeTick;
          }
          checkChildrenDidChange(this, localBoundsCacheData);
          if (localBoundsCacheData.didChange) {
            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix2);
          }
          return localBoundsCacheData.localBounds;
        },
        /**
         * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
         * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
         *  being updated. This means the calculation returned MAY be out of date BUT will give you a
         *  nice performance boost.
         * @param bounds - Optional bounds to store the result of the bounds calculation.
         * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
         * @memberof scene.Container#
         */
        getBounds(skipUpdate, bounds) {
          return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
  var onRenderMixin;
  var init_onRenderMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
      "use strict";
      onRenderMixin = {
        _onRender: null,
        set onRender(func) {
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (!func) {
            if (this._onRender) {
              renderGroup?.removeOnRender(this);
            }
            this._onRender = null;
            return;
          }
          if (!this._onRender) {
            renderGroup?.addOnRender(this);
          }
          this._onRender = func;
        },
        /**
         * This callback is used when the container is rendered. This is where you should add your custom
         * logic that is needed to be run every frame.
         *
         * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
         * and "updateTransform" is no longer called every frame
         * @example
         * const container = new Container();
         * container.onRender = () => {
         *    container.rotation += 0.01;
         * };
         * @memberof scene.Container#
         */
        get onRender() {
          return this._onRender;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
  function sortChildren(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }
  var sortMixin;
  var init_sortMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
      "use strict";
      sortMixin = {
        _zIndex: 0,
        /**
         * Should children be sorted by zIndex at the next render call.
         *
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         * @type {boolean}
         * @memberof scene.Container#
         */
        sortDirty: false,
        /**
         * If set to true, the container will sort its children by `zIndex` value
         * when the next render is called, or manually if `sortChildren()` is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as {@link https://github.com/pixijs/layers PixiJS Layers}
         *
         * Also be aware of that this may not work nicely with the `addChildAt()` function,
         * as the `zIndex` sorting may cause the child to automatically sorted to another position.
         * @type {boolean}
         * @memberof scene.Container#
         */
        sortableChildren: false,
        /**
         * The zIndex of the container.
         *
         * Setting this value, will automatically set the parent to be sortable. Children will be automatically
         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
         * and thus rendered on top of other display objects within the same container.
         * @see scene.Container#sortableChildren
         * @memberof scene.Container#
         */
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(value) {
          if (this._zIndex === value)
            return;
          this._zIndex = value;
          this.depthOfChildModified();
        },
        depthOfChildModified() {
          if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
          }
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
        },
        /**
         * Sorts children by zIndex.
         * @memberof scene.Container#
         */
        sortChildren() {
          if (!this.sortDirty)
            return;
          this.sortDirty = false;
          this.children.sort(sortChildren);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin;
  var init_toLocalGlobalMixin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
      init_Matrix();
      init_Point();
      init_getGlobalBounds();
      toLocalGlobalMixin = {
        /**
         * Returns the global position of the container.
         * @param point - The optional point to write the global value to.
         * @param skipUpdate - Should we skip the update transform.
         * @returns - The updated point.
         * @memberof scene.Container#
         */
        getGlobalPosition(point = new Point(), skipUpdate = false) {
          if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
          } else {
            point.x = this._position.x;
            point.y = this._position.y;
          }
          return point;
        },
        /**
         * Calculates the global position of the container.
         * @param position - The world origin to calculate from.
         * @param point - A Point object in which to store the value, optional
         *  (otherwise will create a new Point).
         * @param skipUpdate - Should we skip the update transform.
         * @returns - A point object representing the position of this object.
         * @memberof scene.Container#
         */
        toGlobal(position, point, skipUpdate = false) {
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.apply(position, point);
          }
          return this.worldTransform.apply(position, point);
        },
        /**
         * Calculates the local position of the container relative to another point.
         * @param position - The world origin to calculate from.
         * @param from - The Container to calculate the global position from.
         * @param point - A Point object in which to store the value, optional
         *  (otherwise will create a new Point).
         * @param skipUpdate - Should we skip the update transform
         * @returns - A point object representing the position of this object
         * @memberof scene.Container#
         */
        toLocal(position, from, point, skipUpdate) {
          if (from) {
            position = from.toGlobal(position, point, skipUpdate);
          }
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.applyInverse(position, point);
          }
          return this.worldTransform.applyInverse(position, point);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var _tick, InstructionSet;
  var init_InstructionSet = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
      init_uid();
      _tick = 0;
      InstructionSet = class {
        constructor() {
          this.uid = uid("instructionSet");
          this.instructions = [];
          this.instructionSize = 0;
          this.renderables = [];
          this.tick = 0;
        }
        /** reset the instruction set so it can be reused set size back to 0 */
        reset() {
          this.instructionSize = 0;
          this.tick = _tick++;
        }
        /**
         * Add an instruction to the set
         * @param instruction - add an instruction to the set
         */
        add(instruction) {
          this.instructions[this.instructionSize++] = instruction;
        }
        /**
         * Log the instructions to the console (for debugging)
         * @internal
         * @ignore
         */
        log() {
          this.instructions.length = this.instructionSize;
          console.table(this.instructions, ["type", "action"]);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
  var RenderGroup;
  var init_RenderGroup = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
      init_Matrix();
      init_InstructionSet();
      RenderGroup = class {
        constructor() {
          this.renderPipeId = "renderGroup";
          this.root = null;
          this.canBundle = false;
          this.renderGroupParent = null;
          this.renderGroupChildren = [];
          this.worldTransform = new Matrix();
          this.worldColorAlpha = 4294967295;
          this.worldColor = 16777215;
          this.worldAlpha = 1;
          this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
          this.updateTick = 0;
          this.childrenRenderablesToUpdate = { list: [], index: 0 };
          this.structureDidChange = true;
          this.instructionSet = new InstructionSet();
          this._onRenderContainers = [];
        }
        init(root) {
          this.root = root;
          if (root._onRender)
            this.addOnRender(root);
          root.didChange = true;
          const children = root.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.addChild(children[i3]);
          }
        }
        reset() {
          this.renderGroupChildren.length = 0;
          for (const i3 in this.childrenToUpdate) {
            const childrenAtDepth = this.childrenToUpdate[i3];
            childrenAtDepth.list.fill(null);
            childrenAtDepth.index = 0;
          }
          this.childrenRenderablesToUpdate.index = 0;
          this.childrenRenderablesToUpdate.list.fill(null);
          this.root = null;
          this.updateTick = 0;
          this.structureDidChange = true;
          this._onRenderContainers.length = 0;
          this.renderGroupParent = null;
        }
        get localTransform() {
          return this.root.localTransform;
        }
        addRenderGroupChild(renderGroupChild) {
          if (renderGroupChild.renderGroupParent) {
            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
          }
          renderGroupChild.renderGroupParent = this;
          this.renderGroupChildren.push(renderGroupChild);
        }
        _removeRenderGroupChild(renderGroupChild) {
          const index = this.renderGroupChildren.indexOf(renderGroupChild);
          if (index > -1) {
            this.renderGroupChildren.splice(index, 1);
          }
          renderGroupChild.renderGroupParent = null;
        }
        addChild(child) {
          this.structureDidChange = true;
          child.parentRenderGroup = this;
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeRenderGroupDepth = 1;
          } else {
            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
          }
          child.didChange = true;
          this.onChildUpdate(child);
          if (child.renderGroup) {
            this.addRenderGroupChild(child.renderGroup);
            return;
          }
          if (child._onRender)
            this.addOnRender(child);
          const children = child.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.addChild(children[i3]);
          }
        }
        removeChild(child) {
          this.structureDidChange = true;
          if (child._onRender) {
            if (!child.renderGroup) {
              this.removeOnRender(child);
            }
          }
          child.parentRenderGroup = null;
          if (child.renderGroup) {
            this._removeRenderGroupChild(child.renderGroup);
            return;
          }
          const children = child.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
        }
        removeChildren(children) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
        }
        onChildUpdate(child) {
          let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
          if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
              index: 0,
              list: []
            };
          }
          childrenToUpdate.list[childrenToUpdate.index++] = child;
        }
        updateRenderable(renderable) {
          if (renderable.globalDisplayStatus < 7)
            return;
          this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
          renderable.didViewUpdate = false;
        }
        onChildViewUpdate(child) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        /**
         * adding a container to the onRender list will make sure the user function
         * passed in to the user defined 'onRender` callBack
         * @param container - the container to add to the onRender list
         */
        addOnRender(container) {
          this._onRenderContainers.push(container);
        }
        removeOnRender(container) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
        }
        runOnRender() {
          for (let i3 = 0; i3 < this._onRenderContainers.length; i3++) {
            this._onRenderContainers[i3]._onRender();
          }
        }
        destroy() {
          this.renderGroupParent = null;
          this.root = null;
          this.childrenRenderablesToUpdate = null;
          this.childrenToUpdate = null;
          this.renderGroupChildren = null;
          this._onRenderContainers = null;
          this.instructionSet = null;
        }
        getChildren(out2 = []) {
          const children = this.root.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this._getChildren(children[i3], out2);
          }
          return out2;
        }
        _getChildren(container, out2 = []) {
          out2.push(container);
          if (container.renderGroup)
            return out2;
          const children = container.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this._getChildren(children[i3], out2);
          }
          return out2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
  function assignWithIgnore(target, options, ignore = {}) {
    for (const key in options) {
      if (!ignore[key] && options[key] !== void 0) {
        target[key] = options[key];
      }
    }
  }
  var init_assignWithIgnore = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/Container.mjs
  var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, UPDATE_TRANSFORM, Container;
  var init_Container = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/Container.mjs"() {
      init_eventemitter3();
      init_Color();
      init_cullingMixin();
      init_Matrix();
      init_const();
      init_ObservablePoint();
      init_uid();
      init_deprecation();
      init_PoolGroup();
      init_childrenHelperMixin();
      init_effectsMixin();
      init_findMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_RenderGroup();
      init_assignWithIgnore();
      defaultSkew = new ObservablePoint(null);
      defaultPivot = new ObservablePoint(null);
      defaultScale = new ObservablePoint(null, 1, 1);
      UPDATE_COLOR = 1;
      UPDATE_BLEND = 2;
      UPDATE_VISIBLE = 4;
      UPDATE_TRANSFORM = 8;
      Container = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.uid = uid("renderable");
          this._updateFlags = 15;
          this.renderGroup = null;
          this.parentRenderGroup = null;
          this.parentRenderGroupIndex = 0;
          this.didChange = false;
          this.didViewUpdate = false;
          this.relativeRenderGroupDepth = 0;
          this.children = [];
          this.parent = null;
          this.includeInBuild = true;
          this.measurable = true;
          this.isSimple = true;
          this.updateTick = -1;
          this.localTransform = new Matrix();
          this.relativeGroupTransform = new Matrix();
          this.groupTransform = this.relativeGroupTransform;
          this.destroyed = false;
          this._position = new ObservablePoint(this, 0, 0);
          this._scale = defaultScale;
          this._pivot = defaultPivot;
          this._skew = defaultSkew;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
          this._rotation = 0;
          this.localColor = 16777215;
          this.localAlpha = 1;
          this.groupAlpha = 1;
          this.groupColor = 16777215;
          this.groupColorAlpha = 4294967295;
          this.localBlendMode = "inherit";
          this.groupBlendMode = "normal";
          this.localDisplayStatus = 7;
          this.globalDisplayStatus = 7;
          this._didContainerChangeTick = 0;
          this._didViewChangeTick = 0;
          this._didLocalTransformChangeId = -1;
          this.effects = [];
          assignWithIgnore(this, options, {
            children: true,
            parent: true,
            effects: true
          });
          options.children?.forEach((child) => this.addChild(child));
          options.parent?.addChild(this);
        }
        /**
         * Mixes all enumerable properties and methods from a source object to Container.
         * @param source - The source of properties and methods to mix in.
         */
        static mixin(source7) {
          Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source7));
        }
        /**
         * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
         * @deprecated since 8.2.6
         * @ignore
         */
        set _didChangeId(value) {
          this._didViewChangeTick = value >> 12 & 4095;
          this._didContainerChangeTick = value & 4095;
        }
        get _didChangeId() {
          return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        /**
         * Adds one or more children to the container.
         *
         * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
         * @param {...Container} children - The Container(s) to add to the container
         * @returns {Container} - The first child that was added.
         */
        addChild(...children) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
          }
          if (children.length > 1) {
            for (let i3 = 0; i3 < children.length; i3++) {
              this.addChild(children[i3]);
            }
            return children[0];
          }
          const child = children[0];
          if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (this.parentRenderGroup) {
              this.parentRenderGroup.structureDidChange = true;
            }
            return child;
          }
          if (child.parent) {
            child.parent.removeChild(child);
          }
          this.children.push(child);
          if (this.sortableChildren)
            this.sortDirty = true;
          child.parent = this;
          child.didChange = true;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
          this._didViewChangeTick++;
          if (child._zIndex !== 0) {
            child.depthOfChildModified();
          }
          return child;
        }
        /**
         * Removes one or more children from the container.
         * @param {...Container} children - The Container(s) to remove
         * @returns {Container} The first child that was removed.
         */
        removeChild(...children) {
          if (children.length > 1) {
            for (let i3 = 0; i3 < children.length; i3++) {
              this.removeChild(children[i3]);
            }
            return children[0];
          }
          const child = children[0];
          const index = this.children.indexOf(child);
          if (index > -1) {
            this._didViewChangeTick++;
            this.children.splice(index, 1);
            if (this.renderGroup) {
              this.renderGroup.removeChild(child);
            } else if (this.parentRenderGroup) {
              this.parentRenderGroup.removeChild(child);
            }
            child.parent = null;
            this.emit("childRemoved", child, this, index);
            child.emit("removed", this);
          }
          return child;
        }
        /** @ignore */
        _onUpdate(point) {
          if (point) {
            if (point === this._skew) {
              this._updateSkew();
            }
          }
          this._didContainerChangeTick++;
          if (this.didChange)
            return;
          this.didChange = true;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.onChildUpdate(this);
          }
        }
        set isRenderGroup(value) {
          if (!!this.renderGroup === value)
            return;
          if (value) {
            this.enableRenderGroup();
          } else {
            this.disableRenderGroup();
          }
        }
        /**
         * Returns true if this container is a render group.
         * This means that it will be rendered as a separate pass, with its own set of instructions
         */
        get isRenderGroup() {
          return !!this.renderGroup;
        }
        /**
         * Calling this enables a render group for this container.
         * This means it will be rendered as a separate set of instructions.
         * The transform of the container will also be handled on the GPU rather than the CPU.
         */
        enableRenderGroup() {
          if (this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup?.removeChild(this);
          this.renderGroup = BigPool.get(RenderGroup, this);
          this.groupTransform = Matrix.IDENTITY;
          parentRenderGroup?.addChild(this);
          this._updateIsSimple();
        }
        /** This will disable the render group for this container. */
        disableRenderGroup() {
          if (!this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup?.removeChild(this);
          BigPool.return(this.renderGroup);
          this.renderGroup = null;
          this.groupTransform = this.relativeGroupTransform;
          parentRenderGroup?.addChild(this);
          this._updateIsSimple();
        }
        /** @ignore */
        _updateIsSimple() {
          this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        /**
         * Current transform of the object based on world (parent) factors.
         * @readonly
         */
        get worldTransform() {
          this._worldTransform || (this._worldTransform = new Matrix());
          if (this.renderGroup) {
            this._worldTransform.copyFrom(this.renderGroup.worldTransform);
          } else if (this.parentRenderGroup) {
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
          }
          return this._worldTransform;
        }
        // / ////// transform related stuff
        /**
         * The position of the container on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         */
        get x() {
          return this._position.x;
        }
        set x(value) {
          this._position.x = value;
        }
        /**
         * The position of the container on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         */
        get y() {
          return this._position.y;
        }
        set y(value) {
          this._position.y = value;
        }
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * @since 4.0.0
         */
        get position() {
          return this._position;
        }
        set position(value) {
          this._position.copyFrom(value);
        }
        /**
         * The rotation of the object in radians.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this._skew);
          }
        }
        /**
         * The angle of the object in degrees.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get angle() {
          return this.rotation * RAD_TO_DEG;
        }
        set angle(value) {
          this.rotation = value * DEG_TO_RAD;
        }
        /**
         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
         * is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         * @since 4.0.0
         */
        get pivot() {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          return this._pivot;
        }
        set pivot(value) {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
        }
        /**
         * The skew factor for the object in radians.
         * @since 4.0.0
         */
        get skew() {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          return this._skew;
        }
        set skew(value) {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          this._skew.copyFrom(value);
        }
        /**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         * @since 4.0.0
         */
        get scale() {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 1, 1);
          }
          return this._scale;
        }
        set scale(value) {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 0, 0);
          }
          typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
        }
        /**
         * The width of the Container, setting this will actually modify the scale to achieve the value set.
         * @memberof scene.Container#
         */
        get width() {
          return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(value) {
          const localWidth = this.getLocalBounds().width;
          this._setWidth(value, localWidth);
        }
        /**
         * The height of the Container, setting this will actually modify the scale to achieve the value set.
         * @memberof scene.Container#
         */
        get height() {
          return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(value) {
          const localHeight = this.getLocalBounds().height;
          this._setHeight(value, localHeight);
        }
        /**
         * Retrieves the size of the container as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the container.
         * @memberof scene.Container#
         */
        getSize(out2) {
          if (!out2) {
            out2 = {};
          }
          const bounds = this.getLocalBounds();
          out2.width = Math.abs(this.scale.x * bounds.width);
          out2.height = Math.abs(this.scale.y * bounds.height);
          return out2;
        }
        /**
         * Sets the size of the container to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         * @memberof scene.Container#
         */
        setSize(value, height) {
          const size = this.getLocalBounds();
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          } else {
            height ?? (height = value);
          }
          value !== void 0 && this._setWidth(value, size.width);
          height !== void 0 && this._setHeight(height, size.height);
        }
        /** Called when the skew or the rotation changes. */
        _updateSkew() {
          const rotation = this._rotation;
          const skew = this._skew;
          this._cx = Math.cos(rotation + skew._y);
          this._sx = Math.sin(rotation + skew._y);
          this._cy = -Math.sin(rotation - skew._x);
          this._sy = Math.cos(rotation - skew._x);
        }
        /**
         * Updates the transform properties of the container (accepts partial values).
         * @param {object} opts - The options for updating the transform.
         * @param {number} opts.x - The x position of the container.
         * @param {number} opts.y - The y position of the container.
         * @param {number} opts.scaleX - The scale factor on the x-axis.
         * @param {number} opts.scaleY - The scale factor on the y-axis.
         * @param {number} opts.rotation - The rotation of the container, in radians.
         * @param {number} opts.skewX - The skew factor on the x-axis.
         * @param {number} opts.skewY - The skew factor on the y-axis.
         * @param {number} opts.pivotX - The x coordinate of the pivot point.
         * @param {number} opts.pivotY - The y coordinate of the pivot point.
         */
        updateTransform(opts) {
          this.position.set(
            typeof opts.x === "number" ? opts.x : this.position.x,
            typeof opts.y === "number" ? opts.y : this.position.y
          );
          this.scale.set(
            typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
            typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
          );
          this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
          this.skew.set(
            typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
            typeof opts.skewY === "number" ? opts.skewY : this.skew.y
          );
          this.pivot.set(
            typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
            typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
          );
          return this;
        }
        /**
         * Updates the local transform using the given matrix.
         * @param matrix - The matrix to use for updating the transform.
         */
        setFromMatrix(matrix) {
          matrix.decompose(this);
        }
        /** Updates the local transform. */
        updateLocalTransform() {
          const localTransformChangeId = this._didContainerChangeTick;
          if (this._didLocalTransformChangeId === localTransformChangeId)
            return;
          this._didLocalTransformChangeId = localTransformChangeId;
          const lt = this.localTransform;
          const scale = this._scale;
          const pivot = this._pivot;
          const position = this._position;
          const sx = scale._x;
          const sy = scale._y;
          const px = pivot._x;
          const py = pivot._y;
          lt.a = this._cx * sx;
          lt.b = this._sx * sx;
          lt.c = this._cy * sy;
          lt.d = this._sy * sy;
          lt.tx = position._x - (px * lt.a + py * lt.c);
          lt.ty = position._y - (px * lt.b + py * lt.d);
        }
        // / ///// color related stuff
        set alpha(value) {
          if (value === this.localAlpha)
            return;
          this.localAlpha = value;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /** The opacity of the object. */
        get alpha() {
          return this.localAlpha;
        }
        set tint(value) {
          const tempColor = Color.shared.setValue(value ?? 16777215);
          const bgr = tempColor.toBgrNumber();
          if (bgr === this.localColor)
            return;
          this.localColor = bgr;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /**
         * The tint applied to the sprite. This is a hex value.
         *
         * A value of 0xFFFFFF will remove any tint effect.
         * @default 0xFFFFFF
         */
        get tint() {
          const bgr = this.localColor;
          return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
        }
        // / //////////////// blend related stuff
        set blendMode(value) {
          if (this.localBlendMode === value)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_BLEND;
          this.localBlendMode = value;
          this._onUpdate();
        }
        /**
         * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
         * @default 'normal'
         */
        get blendMode() {
          return this.localBlendMode;
        }
        // / ///////// VISIBILITY / RENDERABLE /////////////////
        /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
        get visible() {
          return !!(this.localDisplayStatus & 2);
        }
        set visible(value) {
          const valueNumber = value ? 2 : 0;
          if ((this.localDisplayStatus & 2) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 2;
          this._onUpdate();
        }
        /** @ignore */
        get culled() {
          return !(this.localDisplayStatus & 4);
        }
        /** @ignore */
        set culled(value) {
          const valueNumber = value ? 0 : 4;
          if ((this.localDisplayStatus & 4) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 4;
          this._onUpdate();
        }
        /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
        get renderable() {
          return !!(this.localDisplayStatus & 1);
        }
        set renderable(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localDisplayStatus & 1) === valueNumber)
            return;
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 1;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._onUpdate();
        }
        /** Whether or not the object should be rendered. */
        get isRenderable() {
          return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        /**
         * Removes all internal references and listeners as well as removes children from the display list.
         * Do not use a Container after calling `destroy`.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *  method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
         * is set to true it should destroy the texture of the child sprite
         * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
         * If options.children is set to true it should destroy the texture source of the child sprite
         * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
         * If options.children is set to true it should destroy the context of the child graphics
         */
        destroy(options = false) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          let oldChildren;
          if (this.children.length) {
            oldChildren = this.removeChildren(0, this.children.length);
          }
          this.removeFromParent();
          this.parent = null;
          this._maskEffect = null;
          this._filterEffect = null;
          this.effects = null;
          this._position = null;
          this._scale = null;
          this._pivot = null;
          this._skew = null;
          this.emit("destroyed", this);
          this.removeAllListeners();
          const destroyChildren = typeof options === "boolean" ? options : options?.children;
          if (destroyChildren && oldChildren) {
            for (let i3 = 0; i3 < oldChildren.length; ++i3) {
              oldChildren[i3].destroy(options);
            }
          }
          this.renderGroup?.destroy();
          this.renderGroup = null;
        }
      };
      Container.mixin(childrenHelperMixin);
      Container.mixin(toLocalGlobalMixin);
      Container.mixin(onRenderMixin);
      Container.mixin(measureMixin);
      Container.mixin(effectsMixin);
      Container.mixin(findMixin);
      Container.mixin(sortMixin);
      Container.mixin(cullingMixin);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedEvent.mjs
  var FederatedEvent;
  var init_FederatedEvent = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
      init_Point();
      FederatedEvent = class {
        /**
         * @param manager - The event boundary which manages this event. Propagation can only occur
         *  within the boundary's jurisdiction.
         */
        constructor(manager) {
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.composed = false;
          this.defaultPrevented = false;
          this.eventPhase = FederatedEvent.prototype.NONE;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point();
          this.page = new Point();
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        /** @readonly */
        get layerX() {
          return this.layer.x;
        }
        /** @readonly */
        get layerY() {
          return this.layer.y;
        }
        /** @readonly */
        get pageX() {
          return this.page.x;
        }
        /** @readonly */
        get pageY() {
          return this.page.y;
        }
        /**
         * Fallback for the deprecated @code{InteractionEvent.data}.
         * @deprecated since 7.0.0
         */
        get data() {
          return this;
        }
        /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
        composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
        /**
         * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
         * @deprecated
         * @param _type
         * @param _bubbles
         * @param _cancelable
         */
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /**
         * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
         * @deprecated
         * @param _typeArg
         * @param _bubblesArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         */
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /** Prevent default behavior of PixiJS and the user agent. */
        preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
        }
        /**
         * Stop this event from propagating to any addition listeners, including on the
         * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
         * event targets on the propagation path.
         */
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        /**
         * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
         * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
         */
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
  var init_isMobile = __esm({
    "node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js"() {
      appleIphone = /iPhone/i;
      appleIpod = /iPod/i;
      appleTablet = /iPad/i;
      appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
      androidPhone = /\bAndroid(?:.+)Mobile\b/i;
      androidTablet = /Android/i;
      amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
      amazonTablet = /Silk/i;
      windowsPhone = /Windows Phone/i;
      windowsTablet = /\bWindows(?:.+)ARM\b/i;
      otherBlackBerry = /BlackBerry/i;
      otherBlackBerry10 = /BB10/i;
      otherOpera = /Opera Mini/i;
      otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
      otherFirefox = /Mobile(?:.+)Firefox\b/i;
      isAppleTabletOnIos13 = function(navigator2) {
        return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
      };
    }
  });

  // node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/index.js
  var init_esm = __esm({
    "node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/index.js"() {
      init_isMobile();
      init_isMobile();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isMobile.mjs
  var isMobileCall, isMobile2;
  var init_isMobile2 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
      init_esm();
      isMobileCall = isMobile.default ?? isMobile;
      isMobile2 = isMobileCall(globalThis.navigator);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
  var init_AccessibilitySystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
      init_FederatedEvent();
      init_Extensions();
      init_isMobile2();
      init_removeItems();
      KEY_CODE_TAB = 9;
      DIV_TOUCH_SIZE = 100;
      DIV_TOUCH_POS_X = 0;
      DIV_TOUCH_POS_Y = 0;
      DIV_TOUCH_ZINDEX = 2;
      DIV_HOOK_SIZE = 1;
      DIV_HOOK_POS_X = -1e3;
      DIV_HOOK_POS_Y = -1e3;
      DIV_HOOK_ZINDEX = 2;
      AccessibilitySystem = class {
        // 2fps
        // eslint-disable-next-line jsdoc/require-param
        /**
         * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
         */
        constructor(renderer, _mobileInfo = isMobile2) {
          this._mobileInfo = _mobileInfo;
          this.debug = false;
          this._isActive = false;
          this._isMobileAccessibility = false;
          this._pool = [];
          this._renderId = 0;
          this._children = [];
          this._androidUpdateCount = 0;
          this._androidUpdateFrequency = 500;
          this._hookDiv = null;
          if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
          }
          const div = document.createElement("div");
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.position = "absolute";
          div.style.top = `${DIV_TOUCH_POS_X}px`;
          div.style.left = `${DIV_TOUCH_POS_Y}px`;
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          this._div = div;
          this._renderer = renderer;
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onMouseMove = this._onMouseMove.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        /**
         * Value of `true` if accessibility is currently active and accessibility layers are showing.
         * @member {boolean}
         * @readonly
         */
        get isActive() {
          return this._isActive;
        }
        /**
         * Value of `true` if accessibility is enabled for touch devices.
         * @member {boolean}
         * @readonly
         */
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        get hookDiv() {
          return this._hookDiv;
        }
        /**
         * Creates the touch hooks.
         * @private
         */
        _createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.position = "absolute";
          hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
          hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "select to enable accessibility for this content";
          hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
          });
          document.body.appendChild(hookDiv);
          this._hookDiv = hookDiv;
        }
        /**
         * Destroys the touch hooks.
         * @private
         */
        _destroyTouchHook() {
          if (!this._hookDiv) {
            return;
          }
          document.body.removeChild(this._hookDiv);
          this._hookDiv = null;
        }
        /**
         * Activating will cause the Accessibility layer to be shown.
         * This is called when a user presses the tab key.
         * @private
         */
        _activate() {
          if (this._isActive) {
            return;
          }
          this._isActive = true;
          globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.add(this);
          this._renderer.view.canvas.parentNode?.appendChild(this._div);
        }
        /**
         * Deactivating will cause the Accessibility layer to be hidden.
         * This is called when a user moves the mouse.
         * @private
         */
        _deactivate() {
          if (!this._isActive || this._isMobileAccessibility) {
            return;
          }
          this._isActive = false;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.remove(this);
          this._div.parentNode?.removeChild(this._div);
        }
        /**
         * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
         * @private
         * @param {Container} container - The Container to check.
         */
        _updateAccessibleObjects(container) {
          if (!container.visible || !container.accessibleChildren) {
            return;
          }
          if (container.accessible && container.isInteractive()) {
            if (!container._accessibleActive) {
              this._addChild(container);
            }
            container._renderId = this._renderId;
          }
          const children = container.children;
          if (children) {
            for (let i3 = 0; i3 < children.length; i3++) {
              this._updateAccessibleObjects(children[i3]);
            }
          }
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options) {
          this.debug = options?.debug ?? this.debug;
          this._renderer.runners.postrender.remove(this);
        }
        /**
         * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.
         * Only fires while active.
         * @ignore
         */
        postrender() {
          const now = performance.now();
          if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
            return;
          }
          this._androidUpdateCount = now + this._androidUpdateFrequency;
          if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
            return;
          }
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          }
          const { x: x2, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
          const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
          const sx = width / viewWidth * resolution;
          const sy = height / viewHeight * resolution;
          let div = this._div;
          div.style.left = `${x2}px`;
          div.style.top = `${y2}px`;
          div.style.width = `${viewWidth}px`;
          div.style.height = `${viewHeight}px`;
          for (let i3 = 0; i3 < this._children.length; i3++) {
            const child = this._children[i3];
            if (child._renderId !== this._renderId) {
              child._accessibleActive = false;
              removeItems(this._children, i3, 1);
              this._div.removeChild(child._accessibleDiv);
              this._pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
              i3--;
            } else {
              div = child._accessibleDiv;
              let hitArea = child.hitArea;
              const wt = child.worldTransform;
              if (child.hitArea) {
                div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
                div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
                div.style.width = `${hitArea.width * wt.a * sx}px`;
                div.style.height = `${hitArea.height * wt.d * sy}px`;
              } else {
                hitArea = child.getBounds().rectangle;
                this._capHitArea(hitArea);
                div.style.left = `${hitArea.x * sx}px`;
                div.style.top = `${hitArea.y * sy}px`;
                div.style.width = `${hitArea.width * sx}px`;
                div.style.height = `${hitArea.height * sy}px`;
                if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                  div.title = child.accessibleTitle || "";
                }
                if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                  div.setAttribute("aria-label", child.accessibleHint || "");
                }
              }
              if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
                div.title = child.accessibleTitle || "";
                div.tabIndex = child.tabIndex;
                if (this.debug) {
                  this._updateDebugHTML(div);
                }
              }
            }
          }
          this._renderId++;
        }
        /**
         * private function that will visually add the information to the
         * accessibility div
         * @param {HTMLElement} div -
         */
        _updateDebugHTML(div) {
          div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
        }
        /**
         * Adjust the hit area based on the bounds of a display object
         * @param {Rectangle} hitArea - Bounds of the child
         */
        _capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }
          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }
          const { width: viewWidth, height: viewHeight } = this._renderer;
          if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
          }
          if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
          }
        }
        /**
         * Adds a Container to the accessibility manager
         * @private
         * @param {Container} container - The child to make accessible.
         */
        _addChild(container) {
          let div = this._pool.pop();
          if (!div) {
            div = document.createElement("button");
            div.style.width = `${DIV_TOUCH_SIZE}px`;
            div.style.height = `${DIV_TOUCH_SIZE}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
              div.setAttribute("aria-live", "off");
            } else {
              div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              div.setAttribute("aria-relevant", "additions");
            } else {
              div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
          }
          div.style.pointerEvents = container.accessiblePointerEvents;
          div.type = container.accessibleType;
          if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
          } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
          }
          if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
          }
          if (this.debug) {
            this._updateDebugHTML(div);
          }
          container._accessibleActive = true;
          container._accessibleDiv = div;
          div.container = container;
          this._children.push(container);
          this._div.appendChild(container._accessibleDiv);
          container._accessibleDiv.tabIndex = container.tabIndex;
        }
        /**
         * Dispatch events with the EventSystem.
         * @param e
         * @param type
         * @private
         */
        _dispatchEvent(e2, type) {
          const { container: target } = e2.target;
          const boundary = this._renderer.events.rootBoundary;
          const event = Object.assign(new FederatedEvent(boundary), { target });
          boundary.rootTarget = this._renderer.lastObjectRendered;
          type.forEach((type2) => boundary.dispatchEvent(event, type2));
        }
        /**
         * Maps the div button press to pixi's EventSystem (click)
         * @private
         * @param {MouseEvent} e - The click event.
         */
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseover)
         * @private
         * @param {FocusEvent} e - The focus event.
         */
        _onFocus(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "assertive");
          }
          this._dispatchEvent(e2, ["mouseover"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseout)
         * @private
         * @param {FocusEvent} e - The focusout event.
         */
        _onFocusOut(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "polite");
          }
          this._dispatchEvent(e2, ["mouseout"]);
        }
        /**
         * Is called when a key is pressed
         * @private
         * @param {KeyboardEvent} e - The keydown event.
         */
        _onKeyDown(e2) {
          if (e2.keyCode !== KEY_CODE_TAB) {
            return;
          }
          this._activate();
        }
        /**
         * Is called when the mouse moves across the renderer element
         * @private
         * @param {MouseEvent} e - The mouse event.
         */
        _onMouseMove(e2) {
          if (e2.movementX === 0 && e2.movementY === 0) {
            return;
          }
          this._deactivate();
        }
        /** Destroys the accessibility manager */
        destroy() {
          this._destroyTouchHook();
          this._div = null;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown);
          this._pool = null;
          this._children = null;
          this._renderer = null;
        }
      };
      AccessibilitySystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "accessibility"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
  var accessibilityTarget;
  var init_accessibilityTarget = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
      "use strict";
      accessibilityTarget = {
        /**
         * Flag for if the object is accessible. If true AccessibilityManager will overlay a
         * shadow div with attributes set
         * @member {boolean}
         * @memberof scene.Container#
         */
        accessible: false,
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
         * @member {string}
         * @memberof scene.Container#
         */
        accessibleTitle: null,
        /**
         * Sets the aria-label attribute of the shadow div
         * @member {string}
         * @memberof scene.Container#
         */
        accessibleHint: null,
        /**
         * @member {number}
         * @memberof scene.Container#
         * @todo Needs docs.
         */
        tabIndex: 0,
        /**
         * @member {boolean}
         * @memberof scene.Container#
         * @private
         */
        _accessibleActive: false,
        /**
         * @memberof scene.Container#
         * @private
         */
        _accessibleDiv: null,
        /**
         * Specify the type of div the accessible layer is. Screen readers treat the element differently
         * depending on this type. Defaults to button.
         * @member {string}
         * @memberof scene.Container#
         * @default 'button'
         */
        accessibleType: "button",
        /**
         * Specify the pointer-events the accessible div will use
         * Defaults to auto.
         * @type {PointerEvents}
         * @memberof scene.Container#
         * @default 'auto'
         */
        accessiblePointerEvents: "auto",
        /**
         * Setting to false will prevent any children inside this container to
         * be accessible. Defaults to true.
         * @member {boolean}
         * @memberof scene.Container#
         * @default true
         */
        accessibleChildren: true,
        /**
         * @member {number}
         * @memberof scene.Container#
         * @private
         */
        _renderId: -1
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/accessibility/init.mjs
  var init_init = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/accessibility/init.mjs"() {
      init_Extensions();
      init_Container();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      extensions.add(AccessibilitySystem);
      Container.mixin(accessibilityTarget);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/ResizePlugin.mjs
  var ResizePlugin;
  var init_ResizePlugin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
      init_Extensions();
      ResizePlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @static
         * @private
         * @param {object} [options] - See application options
         */
        static init(options) {
          Object.defineProperty(
            this,
            "resizeTo",
            /**
             * The HTML element or window to automatically resize the
             * renderer's view element to match width and height.
             * @member {Window|HTMLElement}
             * @name resizeTo
             * @memberof app.Application#
             */
            {
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                  globalThis.addEventListener("resize", this.queueResize);
                  this.resize();
                }
              },
              get() {
                return this._resizeTo;
              }
            }
          );
          this.queueResize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(() => this.resize());
          };
          this._cancelResize = () => {
            if (this._resizeId) {
              cancelAnimationFrame(this._resizeId);
              this._resizeId = null;
            }
          };
          this.resize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
              width = globalThis.innerWidth;
              height = globalThis.innerHeight;
            } else {
              const { clientWidth, clientHeight } = this._resizeTo;
              width = clientWidth;
              height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
          };
          this._resizeId = null;
          this._resizeTo = null;
          this.resizeTo = options.resizeTo || null;
        }
        /**
         * Clean up the ticker, scoped to application
         * @static
         * @private
         */
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize);
          this._cancelResize();
          this._cancelResize = null;
          this.queueResize = null;
          this.resizeTo = null;
          this.resize = null;
        }
      };
      ResizePlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/ticker/const.mjs
  var UPDATE_PRIORITY;
  var init_const2 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/ticker/const.mjs"() {
      "use strict";
      UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
        return UPDATE_PRIORITY2;
      })(UPDATE_PRIORITY || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/ticker/TickerListener.mjs
  var TickerListener;
  var init_TickerListener = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
      "use strict";
      TickerListener = class {
        /**
         * Constructor
         * @private
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param priority - The priority for emitting
         * @param once - If the handler should fire once
         */
        constructor(fn, context4 = null, priority = 0, once = false) {
          this.next = null;
          this.previous = null;
          this._destroyed = false;
          this._fn = fn;
          this._context = context4;
          this.priority = priority;
          this._once = once;
        }
        /**
         * Simple compare function to figure out if a function and context match.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @returns `true` if the listener match the arguments
         */
        match(fn, context4 = null) {
          return this._fn === fn && this._context === context4;
        }
        /**
         * Emit by calling the current function.
         * @param ticker - The ticker emitting.
         * @returns Next ticker
         */
        emit(ticker) {
          if (this._fn) {
            if (this._context) {
              this._fn.call(this._context, ticker);
            } else {
              this._fn(ticker);
            }
          }
          const redirect = this.next;
          if (this._once) {
            this.destroy(true);
          }
          if (this._destroyed) {
            this.next = null;
          }
          return redirect;
        }
        /**
         * Connect to the list.
         * @param previous - Input node, previous listener
         */
        connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        }
        /**
         * Destroy and don't use after this.
         * @param hard - `true` to remove the `next` reference, this
         *        is considered a hard destroy. Soft destroy maintains the next reference.
         * @returns The listener to redirect while emitting or removing.
         */
        destroy(hard = false) {
          this._destroyed = true;
          this._fn = null;
          this._context = null;
          if (this.previous) {
            this.previous.next = this.next;
          }
          if (this.next) {
            this.next.previous = this.previous;
          }
          const redirect = this.next;
          this.next = hard ? null : redirect;
          this.previous = null;
          return redirect;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/ticker/Ticker.mjs
  var _Ticker, Ticker;
  var init_Ticker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
      init_const2();
      init_TickerListener();
      _Ticker = class _Ticker2 {
        constructor() {
          this.autoStart = false;
          this.deltaTime = 1;
          this.lastTime = -1;
          this.speed = 1;
          this.started = false;
          this._requestId = null;
          this._maxElapsedMS = 100;
          this._minElapsedMS = 0;
          this._protected = false;
          this._lastFrame = -1;
          this._head = new TickerListener(null, null, Infinity);
          this.deltaMS = 1 / _Ticker2.targetFPMS;
          this.elapsedMS = 1 / _Ticker2.targetFPMS;
          this._tick = (time) => {
            this._requestId = null;
            if (this.started) {
              this.update(time);
              if (this.started && this._requestId === null && this._head.next) {
                this._requestId = requestAnimationFrame(this._tick);
              }
            }
          };
        }
        /**
         * Conditionally requests a new animation frame.
         * If a frame has not already been requested, and if the internal
         * emitter has listeners, a new frame is requested.
         * @private
         */
        _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
        /**
         * Conditionally cancels a pending animation frame.
         * @private
         */
        _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        }
        /**
         * Conditionally requests a new animation frame.
         * If the ticker has been started it checks if a frame has not already
         * been requested, and if the internal emitter has listeners. If these
         * conditions are met, a new frame is requested. If the ticker has not
         * been started, but autoStart is `true`, then the ticker starts now,
         * and continues with the previous conditions to request a new frame.
         * @private
         */
        _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        }
        /**
         * Register a handler for tick events. Calls continuously unless
         * it is removed or the ticker is stopped.
         * @param fn - The listener function to be added for updates
         * @param context - The listener context
         * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns This instance of a ticker
         */
        add(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context4, priority));
        }
        /**
         * Add a handler for the tick event which is only execute once.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns This instance of a ticker
         */
        addOnce(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context4, priority, true));
        }
        /**
         * Internally adds the event handler so that it can be sorted by priority.
         * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
         * before the rendering.
         * @private
         * @param listener - Current listener being added.
         * @returns This instance of a ticker
         */
        _addListener(listener) {
          let current = this._head.next;
          let previous = this._head;
          if (!current) {
            listener.connect(previous);
          } else {
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }
            if (!listener.previous) {
              listener.connect(previous);
            }
          }
          this._startIfPossible();
          return this;
        }
        /**
         * Removes any handlers matching the function and context parameters.
         * If no handlers are left after removing, then it cancels the animation frame.
         * @param fn - The listener function to be removed
         * @param context - The listener context to be removed
         * @returns This instance of a ticker
         */
        remove(fn, context4) {
          let listener = this._head.next;
          while (listener) {
            if (listener.match(fn, context4)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }
          if (!this._head.next) {
            this._cancelIfNeeded();
          }
          return this;
        }
        /**
         * The number of listeners on this ticker, calculated by walking through linked list
         * @readonly
         * @member {number}
         */
        get count() {
          if (!this._head) {
            return 0;
          }
          let count2 = 0;
          let current = this._head;
          while (current = current.next) {
            count2++;
          }
          return count2;
        }
        /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
        start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        }
        /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
        stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        }
        /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while (listener) {
              listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
          }
        }
        /**
         * Triggers an update. An update entails setting the
         * current {@link ticker.Ticker#elapsedMS|elapsedMS},
         * the current {@link ticker.Ticker#deltaTime|deltaTime},
         * invoking all listeners with current deltaTime,
         * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
         * with the value of currentTime that was provided.
         * This method will be called automatically by animation
         * frame callbacks if the ticker instance has been started
         * and listeners are added.
         * @param {number} [currentTime=performance.now()] - the current time of execution
         */
        update(currentTime = performance.now()) {
          let elapsedMS;
          if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
              const delta = currentTime - this._lastFrame | 0;
              if (delta < this._minElapsedMS) {
                return;
              }
              this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while (listener) {
              listener = listener.emit(this);
            }
            if (!head.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          }
          this.lastTime = currentTime;
        }
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link ticker.Ticker#speed|speed}, which is specific
         * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
         * @member {number}
         * @readonly
         */
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link ticker.Ticker#update|update}.
         * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
         * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `Ticker.targetFPMS * 1000`.
         * @member {number}
         * @default 10
         */
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps);
          const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        /**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link ticker.Ticker#update|update}.
         * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         * @member {number}
         * @default 0
         */
        get maxFPS() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        }
        set maxFPS(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        /**
         * The shared ticker instance used by {@link AnimatedSprite} and by
         * {@link VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         * @example
         * import { Ticker } from 'pixi.js';
         *
         * const ticker = Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the Ticker.shared instance.
         * ticker.autoStart = false;
         *
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         *
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         * @example
         * import { autoDetectRenderer, Container } from 'pixi.js';
         *
         * // You may use the shared ticker to render...
         * const renderer = autoDetectRenderer();
         * const stage = new Container();
         * document.body.appendChild(renderer.view);
         * ticker.add((time) => renderer.render(stage));
         *
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * const animate = (time) => {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * };
         * animate(performance.now());
         * @member {ticker.Ticker}
         * @readonly
         * @static
         */
        static get shared() {
          if (!_Ticker2._shared) {
            const shared = _Ticker2._shared = new _Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return _Ticker2._shared;
        }
        /**
         * The system ticker instance used by {@link BasePrepare} for core timing
         * functionality that shouldn't usually need to be paused, unlike the `shared`
         * ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
         * @member {ticker.Ticker}
         * @readonly
         * @static
         */
        static get system() {
          if (!_Ticker2._system) {
            const system = _Ticker2._system = new _Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return _Ticker2._system;
        }
      };
      _Ticker.targetFPMS = 0.06;
      Ticker = _Ticker;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/TickerPlugin.mjs
  var TickerPlugin;
  var init_TickerPlugin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
      init_Extensions();
      init_const2();
      init_Ticker();
      TickerPlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @static
         * @private
         * @param {object} [options] - See application options
         */
        static init(options) {
          options = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options);
          Object.defineProperty(
            this,
            "ticker",
            {
              set(ticker) {
                if (this._ticker) {
                  this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                  ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
                }
              },
              get() {
                return this._ticker;
              }
            }
          );
          this.stop = () => {
            this._ticker.stop();
          };
          this.start = () => {
            this._ticker.start();
          };
          this._ticker = null;
          this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
          if (options.autoStart) {
            this.start();
          }
        }
        /**
         * Clean up the ticker, scoped to application.
         * @static
         * @private
         */
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
          }
        }
      };
      TickerPlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/init.mjs
  var init_init2 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/init.mjs"() {
      init_Extensions();
      init_ResizePlugin();
      init_TickerPlugin();
      extensions.add(ResizePlugin);
      extensions.add(TickerPlugin);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/EventTicker.mjs
  var EventsTickerClass, EventsTicker;
  var init_EventTicker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/EventTicker.mjs"() {
      init_const2();
      init_Ticker();
      EventsTickerClass = class {
        constructor() {
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /**
         * Initializes the event ticker.
         * @param events - The event system.
         */
        init(events) {
          this.removeTickerListener();
          this.events = events;
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /** Whether to pause the update checks or not. */
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused) {
          this._pauseUpdate = paused;
        }
        /** Adds the ticker listener. */
        addTickerListener() {
          if (this._tickerAdded || !this.domElement) {
            return;
          }
          Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
          this._tickerAdded = true;
        }
        /** Removes the ticker listener. */
        removeTickerListener() {
          if (!this._tickerAdded) {
            return;
          }
          Ticker.system.remove(this._tickerUpdate, this);
          this._tickerAdded = false;
        }
        /** Sets flag to not fire extra events when the user has already moved there mouse */
        pointerMoved() {
          this._didMove = true;
        }
        /** Updates the state of interactive objects. */
        _update() {
          if (!this.domElement || this._pauseUpdate) {
            return;
          }
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events["_rootPointerEvent"];
          if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
          }
          globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY,
            pointerType: rootPointerEvent.pointerType,
            pointerId: rootPointerEvent.pointerId
          }));
        }
        /**
         * Updates the state of interactive objects if at least {@link interactionFrequency}
         * milliseconds have passed since the last invocation.
         *
         * Invoked by a throttled ticker update from {@link Ticker.system}.
         * @param ticker - The throttled ticker.
         */
        _tickerUpdate(ticker) {
          this._deltaTime += ticker.deltaTime;
          if (this._deltaTime < this.interactionFrequency) {
            return;
          }
          this._deltaTime = 0;
          this._update();
        }
      };
      EventsTicker = new EventsTickerClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent;
  var init_FederatedMouseEvent = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
      init_Point();
      init_FederatedEvent();
      FederatedMouseEvent = class extends FederatedEvent {
        constructor() {
          super(...arguments);
          this.client = new Point();
          this.movement = new Point();
          this.offset = new Point();
          this.global = new Point();
          this.screen = new Point();
        }
        /** @readonly */
        get clientX() {
          return this.client.x;
        }
        /** @readonly */
        get clientY() {
          return this.client.y;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
         * @readonly
         */
        get x() {
          return this.clientX;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
         * @readonly
         */
        get y() {
          return this.clientY;
        }
        /** @readonly */
        get movementX() {
          return this.movement.x;
        }
        /** @readonly */
        get movementY() {
          return this.movement.y;
        }
        /** @readonly */
        get offsetX() {
          return this.offset.x;
        }
        /** @readonly */
        get offsetY() {
          return this.offset.y;
        }
        /** @readonly */
        get globalX() {
          return this.global.x;
        }
        /** @readonly */
        get globalY() {
          return this.global.y;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
         * @readonly
         */
        get screenX() {
          return this.screen.x;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
         * @readonly
         */
        get screenY() {
          return this.screen.y;
        }
        /**
         * This will return the local coordinates of the specified container for this InteractionData
         * @param {Container} container - The Container that you would like the local
         *  coords off
         * @param {PointData} point - A Point object in which to store the value, optional (otherwise
         *  will create a new point)
         * @param {PointData} globalPos - A Point object containing your custom global coords, optional
         *  (otherwise will use the current global coords)
         * @returns - A point containing the coordinates of the InteractionData position relative
         *  to the Container
         */
        getLocalPosition(container, point, globalPos) {
          return container.worldTransform.applyInverse(globalPos || this.global, point);
        }
        /**
         * Whether the modifier key was pressed when this event natively occurred.
         * @param key - The modifier key.
         */
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        /**
         * Not supported.
         * @param _typeArg
         * @param _canBubbleArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         * @param _screenXArg
         * @param _screenYArg
         * @param _clientXArg
         * @param _clientYArg
         * @param _ctrlKeyArg
         * @param _altKeyArg
         * @param _shiftKeyArg
         * @param _metaKeyArg
         * @param _buttonArg
         * @param _relatedTargetArg
         * @deprecated since 7.0.0
         */
        // eslint-disable-next-line max-params
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent;
  var init_FederatedPointerEvent = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedPointerEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.width = 0;
          this.height = 0;
          this.isPrimary = false;
        }
        // Only included for completeness for now
        getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
        // Only included for completeness for now
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent;
  var init_FederatedWheelEvent = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedWheelEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.DOM_DELTA_PIXEL = 0;
          this.DOM_DELTA_LINE = 1;
          this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
      FederatedWheelEvent.DOM_DELTA_LINE = 1;
      FederatedWheelEvent.DOM_DELTA_PAGE = 2;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
  var init_EventBoundary = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
      init_eventemitter3();
      init_Point();
      init_warn();
      init_EventTicker();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      PROPAGATION_LIMIT = 2048;
      tempHitLocation = new Point();
      tempLocalMapping = new Point();
      EventBoundary = class {
        /**
         * @param rootTarget - The holder of the event boundary.
         */
        constructor(rootTarget) {
          this.dispatch = new eventemitter3_default();
          this.moveOnAll = false;
          this.enableGlobalMoveEvents = true;
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this._allInteractiveElements = [];
          this._hitElements = [];
          this._isPointerMoveEvent = false;
          this.rootTarget = rootTarget;
          this.hitPruneFn = this.hitPruneFn.bind(this);
          this.hitTestFn = this.hitTestFn.bind(this);
          this.mapPointerDown = this.mapPointerDown.bind(this);
          this.mapPointerMove = this.mapPointerMove.bind(this);
          this.mapPointerOut = this.mapPointerOut.bind(this);
          this.mapPointerOver = this.mapPointerOver.bind(this);
          this.mapPointerUp = this.mapPointerUp.bind(this);
          this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
          this.mapWheel = this.mapWheel.bind(this);
          this.mappingTable = {};
          this.addEventMapping("pointerdown", this.mapPointerDown);
          this.addEventMapping("pointermove", this.mapPointerMove);
          this.addEventMapping("pointerout", this.mapPointerOut);
          this.addEventMapping("pointerleave", this.mapPointerOut);
          this.addEventMapping("pointerover", this.mapPointerOver);
          this.addEventMapping("pointerup", this.mapPointerUp);
          this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
          this.addEventMapping("wheel", this.mapWheel);
        }
        /**
         * Adds an event mapping for the event `type` handled by `fn`.
         *
         * Event mappings can be used to implement additional or custom events. They take an event
         * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
         * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
         *
         * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
         * instead.
         * @param type - The type of upstream event to map.
         * @param fn - The mapping method. The context of this function must be bound manually, if desired.
         */
        addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
            fn,
            priority: 0
          });
          this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        /**
         * Dispatches the given event
         * @param e - The event to dispatch.
         * @param type - The type of event to dispatch. Defaults to `e.type`.
         */
        dispatchEvent(e2, type) {
          e2.propagationStopped = false;
          e2.propagationImmediatelyStopped = false;
          this.propagate(e2, type);
          this.dispatch.emit(type || e2.type, e2);
        }
        /**
         * Maps the given upstream event through the event boundary and propagates it downstream.
         * @param e - The event to map.
         */
        mapEvent(e2) {
          if (!this.rootTarget) {
            return;
          }
          const mappers = this.mappingTable[e2.type];
          if (mappers) {
            for (let i3 = 0, j2 = mappers.length; i3 < j2; i3++) {
              mappers[i3].fn(e2);
            }
          } else {
            warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
          }
        }
        /**
         * Finds the Container that is the target of a event at the given coordinates.
         *
         * The passed (x,y) coordinates are in the world space above this event boundary.
         * @param x - The x coordinate of the event.
         * @param y - The y coordinate of the event.
         */
        hitTest(x2, y2) {
          EventsTicker.pauseUpdate = true;
          const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
          const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
          const invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        /**
         * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
         * target {@code e.target}.
         * @param e - The event to propagate.
         * @param type - The type of event to propagate. Defaults to `e.type`.
         */
        propagate(e2, type) {
          if (!e2.target) {
            return;
          }
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i3 = 0, j2 = composedPath.length - 1; i3 < j2; i3++) {
            e2.currentTarget = composedPath[i3];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
          e2.eventPhase = e2.AT_TARGET;
          e2.currentTarget = e2.target;
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          for (let i3 = composedPath.length - 2; i3 >= 0; i3--) {
            e2.currentTarget = composedPath[i3];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
        }
        /**
         * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
         *
         * This is used in the `globalpointermove` event.
         * @param e - The emitted event.
         * @param type - The listeners to notify.
         * @param targets - The targets to notify.
         */
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i3 = targets.length - 1; i3 >= 0; i3--) {
            events.forEach((event) => {
              e2.currentTarget = targets[i3];
              this.notifyTarget(e2, event);
            });
          }
        }
        /**
         * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
         * {@code target}. The last element in the path is {@code target}.
         * @param target - The target to find the propagation path to.
         */
        propagationPath(target) {
          const propagationPath = [target];
          for (let i3 = 0; i3 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i3++) {
            if (!target.parent) {
              throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
          }
          propagationPath.reverse();
          return propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for (let i3 = children.length - 1; i3 >= 0; i3--) {
              const child = children[i3];
              const nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive) {
                  if (isInteractive)
                    this._allInteractiveElements.push(currentTarget);
                  nestedHit.push(currentTarget);
                }
                if (this._hitElements.length === 0)
                  this._hitElements = nestedHit;
                shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveTarget && isInteractiveTarget)
            this._allInteractiveElements.push(currentTarget);
          if (ignore || this._hitElements.length > 0)
            return null;
          if (shouldReturn)
            return this._hitElements;
          if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        /**
         * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
         * @param currentTarget - The Container that is to be hit tested.
         * @param eventMode - The event mode for the `currentTarget` or one of its parents.
         * @param location - The location that is being tested for overlap.
         * @param testFn - Callback that determines whether the target passes hit testing. This callback
         *  can assume that `pruneFn` failed to prune the container.
         * @param pruneFn - Callback that determiness whether the target and all of its children
         *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
         *  of the scene graph.
         * @returns An array holding the hit testing target and all its ancestors in order. The first element
         *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
         *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
         */
        hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
          }
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            const relativeLocation = location;
            for (let i3 = children.length - 1; i3 >= 0; i3--) {
              const child = children[i3];
              const nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                relativeLocation,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive)
                  nestedHit.push(currentTarget);
                return nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(container) {
          if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable) {
            return true;
          }
          if (container.eventMode === "none") {
            return true;
          }
          if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
          }
          return false;
        }
        /**
         * Checks whether the container or any of its children cannot pass the hit test at all.
         *
         * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
         * and {@link Container._maskEffect} for pruning.
         * @param container - The container to prune.
         * @param location - The location to test for overlap.
         */
        hitPruneFn(container, location) {
          if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
              return true;
            }
          }
          if (container.effects && container.effects.length) {
            for (let i3 = 0; i3 < container.effects.length; i3++) {
              const effect = container.effects[i3];
              if (effect.containsPoint) {
                const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                if (!effectContainsPoint) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the container passes hit testing for the given location.
         * @param container - The container to test.
         * @param location - The location to test for overlap.
         * @returns - Whether `container` passes hit testing for `location`.
         */
        hitTestFn(container, location) {
          if (container.hitArea) {
            return true;
          }
          if (container?.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping);
            return container.containsPoint(tempLocalMapping);
          }
          return false;
        }
        /**
         * Notify all the listeners to the event's `currentTarget`.
         *
         * If the `currentTarget` contains the property `on<type>`, then it is called here,
         * simulating the behavior from version 6.x and prior.
         * @param e - The event passed to the target.
         * @param type - The type of event to notify. Defaults to `e.type`.
         */
        notifyTarget(e2, type) {
          if (!e2.currentTarget.isInteractive()) {
            return;
          }
          type = type ?? e2.type;
          const handlerKey = `on${type}`;
          e2.currentTarget[handlerKey]?.(e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this._notifyListeners(e2, key);
          if (e2.eventPhase === e2.AT_TARGET) {
            this._notifyListeners(e2, type);
          }
        }
        /**
         * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
         *
         * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
         * @param from - The upstream `pointerdown` event.
         */
        mapPointerDown(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerdown");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchstart");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
         *
         * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
         * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
         * @param from - The upstream `pointermove` event.
         */
        mapPointerMove(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          const trackingData = this.trackingData(from.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            if (!e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse)
                  this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
              }
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
              if (overTargetAncestor === e2.target)
                break;
              overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse)
                  this.notifyTarget(enterEvent, "mouseenter");
                enterEvent.target = enterEvent.target.parent;
              }
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [];
          const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
          allowGlobalPointerEvents && allMethods.push("globalpointermove");
          if (e2.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
          }
          if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e2.target?.cursor;
          }
          if (allMethods.length > 0) {
            this.all(e2, allMethods);
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
         *
         * The tracking data for the specific pointer gets a new `overTarget`.
         * @param from - The upstream `pointerover` event.
         */
        mapPointerOver(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const e2 = this.createPointerEvent(from);
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover");
          if (isMouse)
            this.dispatchEvent(e2, "mouseover");
          if (e2.pointerType === "mouse")
            this.cursor = e2.target?.cursor;
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
          this.freeEvent(enterEvent);
        }
        /**
         * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
         *
         * The tracking data for the specific pointer is cleared of a `overTarget`.
         * @param from - The upstream `pointerout` event.
         */
        mapPointerOut(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        /**
         * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
         * and `click`/`rightclick`/`pointertap` events, in that order.
         *
         * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
         * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
         * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
         * specific pointer types.
         * @param from - The upstream `pointerup` event.
         */
        mapPointerUp(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now = performance.now();
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerup");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchend");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while (currentTarget && !e2.composedPath().includes(currentTarget)) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from.button]) {
              trackingData.clicksByButton[from.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now
              };
            }
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
              this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
         * `pointerdown` target to `rootTarget`.
         *
         * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
         * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
         *
         * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
         * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
         * @param from - The upstream `pointerupoutside` event.
         */
        mapPointerUpOutside(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          const e2 = this.createPointerEvent(from);
          if (pressTarget) {
            let currentTarget = pressTarget;
            while (currentTarget) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `wheel` event to a downstream `wheel` event.
         * @param from - The upstream `wheel` event.
         */
        mapWheel(from) {
          if (!(from instanceof FederatedWheelEvent)) {
            warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
        }
        /**
         * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
         *
         * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
         * or `pointerover` target was unmounted from the scene graph.
         * @param propagationPath - The propagation path was valid in the past.
         * @returns - The most specific event-target still mounted at the same location in the scene graph.
         */
        findMountedTarget(propagationPath) {
          if (!propagationPath) {
            return null;
          }
          let currentTarget = propagationPath[0];
          for (let i3 = 1; i3 < propagationPath.length; i3++) {
            if (propagationPath[i3].parent === currentTarget) {
              currentTarget = propagationPath[i3];
            } else {
              break;
            }
          }
          return currentTarget;
        }
        /**
         * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The {@code originalEvent} for the returned event.
         * @param [type=from.type] - The type of the returned event.
         * @param target - The target of the returned event.
         */
        createPointerEvent(from, type, target) {
          const event = this.allocateEvent(FederatedPointerEvent);
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
          if (typeof type === "string") {
            event.type = type;
          }
          return event;
        }
        /**
         * Creates a wheel event whose {@code originalEvent} is {@code from}.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The upstream wheel event.
         */
        createWheelEvent(from) {
          const event = this.allocateEvent(FederatedWheelEvent);
          this.copyWheelData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = this.hitTest(event.global.x, event.global.y);
          return event;
        }
        /**
         * Clones the event {@code from}, with an optional {@code type} override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The event to clone.
         * @param [type=from.type] - The type of the returned event.
         */
        clonePointerEvent(from, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from.originalEvent;
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.target = from.target;
          event.path = from.composedPath().slice();
          event.type = type ?? event.type;
          return event;
        }
        /**
         * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + deltaMode
         * + deltaX
         * + deltaY
         * + deltaZ
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyWheelData(from, to) {
          to.deltaMode = from.deltaMode;
          to.deltaX = from.deltaX;
          to.deltaY = from.deltaY;
          to.deltaZ = from.deltaZ;
        }
        /**
         * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + pointerId
         * + width
         * + height
         * + isPrimary
         * + pointerType
         * + pressure
         * + tangentialPressure
         * + tiltX
         * + tiltY
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyPointerData(from, to) {
          if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
            return;
          to.pointerId = from.pointerId;
          to.width = from.width;
          to.height = from.height;
          to.isPrimary = from.isPrimary;
          to.pointerType = from.pointerType;
          to.pressure = from.pressure;
          to.tangentialPressure = from.tangentialPressure;
          to.tiltX = from.tiltX;
          to.tiltY = from.tiltY;
          to.twist = from.twist;
        }
        /**
         * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
         *
         * The following properties are copied:
         * + altKey
         * + button
         * + buttons
         * + clientX
         * + clientY
         * + metaKey
         * + movementX
         * + movementY
         * + pageX
         * + pageY
         * + x
         * + y
         * + screen
         * + shiftKey
         * + global
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyMouseData(from, to) {
          if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
            return;
          to.altKey = from.altKey;
          to.button = from.button;
          to.buttons = from.buttons;
          to.client.copyFrom(from.client);
          to.ctrlKey = from.ctrlKey;
          to.metaKey = from.metaKey;
          to.movement.copyFrom(from.movement);
          to.screen.copyFrom(from.screen);
          to.shiftKey = from.shiftKey;
          to.global.copyFrom(from.global);
        }
        /**
         * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + isTrusted
         * + srcElement
         * + timeStamp
         * + type
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyData(from, to) {
          to.isTrusted = from.isTrusted;
          to.srcElement = from.srcElement;
          to.timeStamp = performance.now();
          to.type = from.type;
          to.detail = from.detail;
          to.view = from.view;
          to.which = from.which;
          to.layer.copyFrom(from.layer);
          to.page.copyFrom(from.page);
        }
        /**
         * @param id - The pointer ID.
         * @returns The tracking data stored for the given pointer. If no data exists, a blank
         *  state will be created.
         */
        trackingData(id) {
          if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            };
          }
          return this.mappingState.trackingData[id];
        }
        /**
         * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
         *
         * This allocation is constructor-agnostic, as long as it only takes one argument - this event
         * boundary.
         * @param constructor - The event's constructor.
         */
        allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.defaultPrevented = false;
          event.path = null;
          event.target = null;
          return event;
        }
        /**
         * Frees the event and puts it back into the event pool.
         *
         * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
         *
         * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
         * not be freed. This is because of the possibility that the same event is freed twice, which can cause
         * it to be allocated twice & result in overwriting.
         * @param event - The event to be freed.
         * @throws Error if the event is managed by another event boundary.
         */
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor).push(event);
        }
        /**
         * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
         * is set on the event.
         * @param e - The event to call each listener with.
         * @param type - The event key.
         */
        _notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (!listeners)
            return;
          if ("fn" in listeners) {
            if (listeners.once)
              e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e2);
          } else {
            for (let i3 = 0, j2 = listeners.length; i3 < j2 && !e2.propagationImmediatelyStopped; i3++) {
              if (listeners[i3].once)
                e2.currentTarget.removeListener(type, listeners[i3].fn, void 0, true);
              listeners[i3].fn.call(listeners[i3].context, e2);
            }
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
  var init_EventSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/EventSystem.mjs"() {
      init_Extensions();
      init_EventBoundary();
      init_EventTicker();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      MOUSE_POINTER_ID = 1;
      TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem = class _EventSystem2 {
        /**
         * @param {Renderer} renderer
         */
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis;
          this.supportsPointerEvents = !!globalThis.PointerEvent;
          this.domElement = null;
          this.resolution = 1;
          this.renderer = renderer;
          this.rootBoundary = new EventBoundary(null);
          EventsTicker.init(this);
          this.autoPreventDefault = true;
          this._eventsAdded = false;
          this._rootPointerEvent = new FederatedPointerEvent(null);
          this._rootWheelEvent = new FederatedWheelEvent(null);
          this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          };
          this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
            set: (target, key, value) => {
              if (key === "globalMove") {
                this.rootBoundary.enableGlobalMoveEvents = value;
              }
              target[key] = value;
              return true;
            }
          });
          this._onPointerDown = this._onPointerDown.bind(this);
          this._onPointerMove = this._onPointerMove.bind(this);
          this._onPointerUp = this._onPointerUp.bind(this);
          this._onPointerOverOut = this._onPointerOverOut.bind(this);
          this.onWheel = this.onWheel.bind(this);
        }
        /**
         * The default interaction mode for all display objects.
         * @see Container.eventMode
         * @type {EventMode}
         * @readonly
         * @since 7.2.0
         */
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options) {
          const { canvas, resolution } = this.renderer;
          this.setTargetElement(canvas);
          this.resolution = resolution;
          _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
          Object.assign(this.features, options.eventFeatures ?? {});
          this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        /**
         * Handle changing resolution.
         * @ignore
         */
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        /** Destroys all event listeners and detaches the renderer. */
        destroy() {
          this.setTargetElement(null);
          this.renderer = null;
          this._currentCursor = null;
        }
        /**
         * Sets the current cursor mode, handling any callbacks or CSS style changes.
         * @param mode - cursor mode, a key from the cursorStyles dictionary
         */
        setCursor(mode) {
          mode = mode || "default";
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
          }
          if (this._currentCursor === mode) {
            return;
          }
          this._currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style) {
            switch (typeof style) {
              case "string":
                if (applyStyles) {
                  this.domElement.style.cursor = style;
                }
                break;
              case "function":
                style(mode);
                break;
              case "object":
                if (applyStyles) {
                  Object.assign(this.domElement.style, style);
                }
                break;
            }
          } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
          }
        }
        /**
         * The global pointer event.
         * Useful for getting the pointer position without listening to events.
         * @since 7.2.0
         */
        get pointer() {
          return this._rootPointerEvent;
        }
        /**
         * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this._normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          for (let i3 = 0, j2 = events.length; i3 < j2; i3++) {
            const nativeEvent2 = events[i3];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch events.
         */
        _onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          EventsTicker.pointerMoved();
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
          }
          const outside = target !== this.domElement ? "outside" : "";
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
         * @param nativeEvent - The native wheel event.
         */
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          this.rootBoundary.mapEvent(wheelEvent);
        }
        /**
         * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
         *
         * To deregister the current DOM element without setting a new one, pass {@code null}.
         * @param element - The new DOM element.
         */
        setTargetElement(element) {
          this._removeEvents();
          this.domElement = element;
          EventsTicker.domElement = element;
          this._addEvents();
        }
        /** Register event listeners on {@link Renderer#domElement this.domElement}. */
        _addEvents() {
          if (this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.addTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "none";
              style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "none";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.addEventListener("touchstart", this._onPointerDown, true);
              this.domElement.addEventListener("touchend", this._onPointerUp, true);
              this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          });
          this._eventsAdded = true;
        }
        /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.removeTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "";
              style.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
              this.domElement.removeEventListener("touchend", this._onPointerUp, true);
              this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.removeEventListener("wheel", this.onWheel, true);
          this.domElement = null;
          this._eventsAdded = false;
        }
        /**
         * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
         * resulting value is stored in the point. This takes into account the fact that the DOM
         * element could be scaled and positioned anywhere on the screen.
         * @param  {PointData} point - the point that the result will be stored in
         * @param  {number} x - the x coord of the position to map
         * @param  {number} y - the y coord of the position to map
         */
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          };
          const resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
          point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        /**
         * Ensures that the original event object contains all data that a regular pointer event would have
         * @param event - The original event data from a touch or mouse event
         * @returns An array containing a single normalized pointer event, in the case of a pointer
         *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
         */
        _normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i3 = 0, li = event.changedTouches.length; i3 < li; i3++) {
              const touch = event.changedTouches[i3];
              if (typeof touch.button === "undefined")
                touch.button = 0;
              if (typeof touch.buttons === "undefined")
                touch.buttons = 1;
              if (typeof touch.isPrimary === "undefined") {
                touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
              }
              if (typeof touch.width === "undefined")
                touch.width = touch.radiusX || 1;
              if (typeof touch.height === "undefined")
                touch.height = touch.radiusY || 1;
              if (typeof touch.tiltX === "undefined")
                touch.tiltX = 0;
              if (typeof touch.tiltY === "undefined")
                touch.tiltY = 0;
              if (typeof touch.pointerType === "undefined")
                touch.pointerType = "touch";
              if (typeof touch.pointerId === "undefined")
                touch.pointerId = touch.identifier || 0;
              if (typeof touch.pressure === "undefined")
                touch.pressure = touch.force || 0.5;
              if (typeof touch.twist === "undefined")
                touch.twist = 0;
              if (typeof touch.tangentialPressure === "undefined")
                touch.tangentialPressure = 0;
              if (typeof touch.layerX === "undefined")
                touch.layerX = touch.offsetX = touch.clientX;
              if (typeof touch.layerY === "undefined")
                touch.layerY = touch.offsetY = touch.clientY;
              touch.isNormalized = true;
              touch.type = event.type;
              normalizedEvents.push(touch);
            }
          } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined")
              tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined")
              tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined")
              tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined")
              tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined")
              tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined")
              tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined")
              tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined")
              tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined")
              tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined")
              tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
          } else {
            normalizedEvents.push(event);
          }
          return normalizedEvents;
        }
        /**
         * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
         *
         * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
         * multiple native wheel events.
         * @param nativeEvent - The native wheel event that occurred on the canvas.
         * @returns A federated wheel event.
         */
        normalizeWheelEvent(nativeEvent) {
          const event = this._rootWheelEvent;
          this._transferMouseData(event, nativeEvent);
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          event.deltaMode = nativeEvent.deltaMode;
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
        }
        /**
         * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
         * @param event
         * @param nativeEvent
         */
        _bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this._transferMouseData(event, nativeEvent);
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === "pointerleave") {
            event.type = "pointerout";
          }
          if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
          }
          if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
          }
          return event;
        }
        /**
         * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
         * @param event
         * @param nativeEvent
         */
        _transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = performance.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
          event.shiftKey = nativeEvent.shiftKey;
        }
      };
      _EventSystem.extension = {
        name: "events",
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.CanvasSystem,
          ExtensionType.WebGPUSystem
        ],
        priority: -1
      };
      _EventSystem.defaultEventFeatures = {
        /** Enables pointer events associated with pointer movement. */
        move: true,
        /** Enables global pointer move events. */
        globalMove: true,
        /** Enables pointer events associated with clicking. */
        click: true,
        /** Enables wheel events. */
        wheel: true
      };
      EventSystem = _EventSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
  var FederatedContainer;
  var init_FederatedEventTarget = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
      init_EventSystem();
      init_FederatedEvent();
      FederatedContainer = {
        /**
         * Property-based event handler for the `click` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onclick = (event) => {
         *  //some function here that happens on click
         * }
         */
        onclick: null,
        /**
         * Property-based event handler for the `mousedown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmousedown = (event) => {
         *  //some function here that happens on mousedown
         * }
         */
        onmousedown: null,
        /**
         * Property-based event handler for the `mouseenter` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseenter = (event) => {
         *  //some function here that happens on mouseenter
         * }
         */
        onmouseenter: null,
        /**
         * Property-based event handler for the `mouseleave` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseleave = (event) => {
         *  //some function here that happens on mouseleave
         * }
         */
        onmouseleave: null,
        /**
         * Property-based event handler for the `mousemove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmousemove = (event) => {
         *  //some function here that happens on mousemove
         * }
         */
        onmousemove: null,
        /**
         * Property-based event handler for the `globalmousemove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobalmousemove = (event) => {
         *  //some function here that happens on globalmousemove
         * }
         */
        onglobalmousemove: null,
        /**
         * Property-based event handler for the `mouseout` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseout = (event) => {
         *  //some function here that happens on mouseout
         * }
         */
        onmouseout: null,
        /**
         * Property-based event handler for the `mouseover` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseover = (event) => {
         *  //some function here that happens on mouseover
         * }
         */
        onmouseover: null,
        /**
         * Property-based event handler for the `mouseup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseup = (event) => {
         *  //some function here that happens on mouseup
         * }
         */
        onmouseup: null,
        /**
         * Property-based event handler for the `mouseupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseupoutside = (event) => {
         *  //some function here that happens on mouseupoutside
         * }
         */
        onmouseupoutside: null,
        /**
         * Property-based event handler for the `pointercancel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointercancel = (event) => {
         *  //some function here that happens on pointercancel
         * }
         */
        onpointercancel: null,
        /**
         * Property-based event handler for the `pointerdown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerdown = (event) => {
         *  //some function here that happens on pointerdown
         * }
         */
        onpointerdown: null,
        /**
         * Property-based event handler for the `pointerenter` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerenter = (event) => {
         *  //some function here that happens on pointerenter
         * }
         */
        onpointerenter: null,
        /**
         * Property-based event handler for the `pointerleave` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerleave = (event) => {
         *  //some function here that happens on pointerleave
         * }
         */
        onpointerleave: null,
        /**
         * Property-based event handler for the `pointermove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointermove = (event) => {
         *  //some function here that happens on pointermove
         * }
         */
        onpointermove: null,
        /**
         * Property-based event handler for the `globalpointermove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobalpointermove = (event) => {
         *  //some function here that happens on globalpointermove
         * }
         */
        onglobalpointermove: null,
        /**
         * Property-based event handler for the `pointerout` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerout = (event) => {
         *  //some function here that happens on pointerout
         * }
         */
        onpointerout: null,
        /**
         * Property-based event handler for the `pointerover` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerover = (event) => {
         *  //some function here that happens on pointerover
         * }
         */
        onpointerover: null,
        /**
         * Property-based event handler for the `pointertap` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointertap = (event) => {
         *  //some function here that happens on pointertap
         * }
         */
        onpointertap: null,
        /**
         * Property-based event handler for the `pointerup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerup = (event) => {
         *  //some function here that happens on pointerup
         * }
         */
        onpointerup: null,
        /**
         * Property-based event handler for the `pointerupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerupoutside = (event) => {
         *  //some function here that happens on pointerupoutside
         * }
         */
        onpointerupoutside: null,
        /**
         * Property-based event handler for the `rightclick` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightclick = (event) => {
         *  //some function here that happens on rightclick
         * }
         */
        onrightclick: null,
        /**
         * Property-based event handler for the `rightdown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightdown = (event) => {
         *  //some function here that happens on rightdown
         * }
         */
        onrightdown: null,
        /**
         * Property-based event handler for the `rightup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightup = (event) => {
         *  //some function here that happens on rightup
         * }
         */
        onrightup: null,
        /**
         * Property-based event handler for the `rightupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightupoutside = (event) => {
         *  //some function here that happens on rightupoutside
         * }
         */
        onrightupoutside: null,
        /**
         * Property-based event handler for the `tap` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontap = (event) => {
         *  //some function here that happens on tap
         * }
         */
        ontap: null,
        /**
         * Property-based event handler for the `touchcancel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchcancel = (event) => {
         *  //some function here that happens on touchcancel
         * }
         */
        ontouchcancel: null,
        /**
         * Property-based event handler for the `touchend` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchend = (event) => {
         *  //some function here that happens on touchend
         * }
         */
        ontouchend: null,
        /**
         * Property-based event handler for the `touchendoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchendoutside = (event) => {
         *  //some function here that happens on touchendoutside
         * }
         */
        ontouchendoutside: null,
        /**
         * Property-based event handler for the `touchmove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchmove = (event) => {
         *  //some function here that happens on touchmove
         * }
         */
        ontouchmove: null,
        /**
         * Property-based event handler for the `globaltouchmove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobaltouchmove = (event) => {
         *  //some function here that happens on globaltouchmove
         * }
         */
        onglobaltouchmove: null,
        /**
         * Property-based event handler for the `touchstart` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchstart = (event) => {
         *  //some function here that happens on touchstart
         * }
         */
        ontouchstart: null,
        /**
         * Property-based event handler for the `wheel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onwheel = (event) => {
         *  //some function here that happens on wheel
         * }
         */
        onwheel: null,
        /**
         * Enable interaction events for the Container. Touch, pointer and mouse
         * @memberof scene.Container#
         */
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static";
        },
        set interactive(value) {
          this.eventMode = value ? "static" : "passive";
        },
        /**
         * @ignore
         */
        _internalEventMode: void 0,
        /**
         * Enable interaction events for the Container. Touch, pointer and mouse.
         * There are 5 types of interaction settings:
         * - `'none'`: Ignores all interaction events, even on its children.
         * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
         * Interactive children will still emit events.
         * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
         * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
         * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
         * allow for interaction when the mouse isn't moving
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.eventMode = 'static';
         * sprite.on('tap', (event) => {
         *     // Handle event
         * });
         * @memberof scene.Container#
         * @since 7.2.0
         */
        get eventMode() {
          return this._internalEventMode ?? EventSystem.defaultEventMode;
        },
        set eventMode(value) {
          this._internalEventMode = value;
        },
        /**
         * Determines if the container is interactive or not
         * @returns {boolean} Whether the container is interactive or not
         * @memberof scene.Container#
         * @since 7.2.0
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.eventMode = 'static';
         * sprite.isInteractive(); // true
         *
         * sprite.eventMode = 'dynamic';
         * sprite.isInteractive(); // true
         *
         * sprite.eventMode = 'none';
         * sprite.isInteractive(); // false
         *
         * sprite.eventMode = 'passive';
         * sprite.isInteractive(); // false
         *
         * sprite.eventMode = 'auto';
         * sprite.isInteractive(); // false
         */
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        /**
         * Determines if the children to the container can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         * @memberof scene.Container#
         */
        interactiveChildren: true,
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
         * @example
         * import { Rectangle, Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new Rectangle(0, 0, 100, 100);
         * @member {IHitArea}
         * @memberof scene.Container#
         */
        hitArea: null,
        /**
         * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
         * seeks to be compatible with the DOM's `addEventListener` with support for options.
         * @memberof scene.Container
         * @param type - The type of event to listen to.
         * @param listener - The listener callback or object.
         * @param options - Listener options, used for capture phase.
         * @example
         * // Tell the user whether they did a single, double, triple, or nth click.
         * button.addEventListener('click', {
         *     handleEvent(e): {
         *         let prefix;
         *
         *         switch (e.detail) {
         *             case 1: prefix = 'single'; break;
         *             case 2: prefix = 'double'; break;
         *             case 3: prefix = 'triple'; break;
         *             default: prefix = e.detail + 'th'; break;
         *         }
         *
         *         console.log('That was a ' + prefix + 'click');
         *     }
         * });
         *
         * // But skip the first click!
         * button.parent.addEventListener('click', function blockClickOnce(e) {
         *     e.stopImmediatePropagation();
         *     button.parent.removeEventListener('click', blockClickOnce, true);
         * }, {
         *     capture: true,
         * });
         */
        addEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const signal = typeof options === "object" ? options.signal : void 0;
          const once = typeof options === "object" ? options.once === true : false;
          const context4 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
          const emitter = this;
          if (signal) {
            signal.addEventListener("abort", () => {
              emitter.off(type, listenerFn, context4);
            });
          }
          if (once) {
            emitter.once(type, listenerFn, context4);
          } else {
            emitter.on(type, listenerFn, context4);
          }
        },
        /**
         * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
         * seeks to be compatible with the DOM's `removeEventListener` with support for options.
         * @memberof scene.Container
         * @param type - The type of event the listener is bound to.
         * @param listener - The listener callback or object.
         * @param options - The original listener options. This is required to deregister a capture phase listener.
         */
        removeEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const context4 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.off(type, listener, context4);
        },
        /**
         * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
         *
         * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
         * @memberof scene.Container
         * @param e - The event to dispatch.
         * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
         * @example
         * // Reuse a click event!
         * button.dispatchEvent(clickEvent);
         */
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent)) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
          }
          e2.defaultPrevented = false;
          e2.path = null;
          e2.target = this;
          e2.manager.dispatchEvent(e2);
          return !e2.defaultPrevented;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/init.mjs
  var init_init3 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/events/init.mjs"() {
      init_Extensions();
      init_Container();
      init_EventSystem();
      init_FederatedEventTarget();
      extensions.add(EventSystem);
      Container.mixin(FederatedContainer);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority;
  var init_LoaderParser = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
      "use strict";
      LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
        LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
        LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
        LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
        return LoaderParserPriority2;
      })(LoaderParserPriority || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
  var BrowserAdapter;
  var init_BrowserAdapter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
      "use strict";
      BrowserAdapter = {
        createCanvas: (width, height) => {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          return canvas;
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (url, options) => fetch(url, options),
        parseXML: (xml) => {
          const parser = new DOMParser();
          return parser.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment/adapter.mjs
  var currentAdapter, DOMAdapter;
  var init_adapter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment/adapter.mjs"() {
      init_BrowserAdapter();
      currentAdapter = BrowserAdapter;
      DOMAdapter = {
        /**
         * Returns the current adapter.
         * @returns {environment.Adapter} The current adapter.
         */
        get() {
          return currentAdapter;
        },
        /**
         * Sets the current adapter.
         * @param adapter - The new adapter.
         */
        set(adapter) {
          currentAdapter = adapter;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    const re = url.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i3 = 0; i3 <= path2.length; ++i3) {
      if (i3 < path2.length) {
        code = path2.charCodeAt(i3);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i3 - 1 || dots === 1) {
        } else if (lastSlash !== i3 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i3;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i3;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i3)}`;
          } else {
            res = path2.slice(lastSlash + 1, i3);
          }
          lastSegmentLength = i3 - lastSlash - 1;
        }
        lastSlash = i3;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path;
  var init_path = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/path.mjs"() {
      init_adapter();
      path = {
        /**
         * Converts a path to posix format.
         * @param path - The path to convert to posix
         */
        toPosix(path2) {
          return replaceAll(path2, "\\", "/");
        },
        /**
         * Checks if the path is a URL e.g. http://, https://
         * @param path - The path to check
         */
        isUrl(path2) {
          return /^https?:/.test(this.toPosix(path2));
        },
        /**
         * Checks if the path is a data URL
         * @param path - The path to check
         */
        isDataUrl(path2) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
        },
        /**
         * Checks if the path is a blob URL
         * @param path - The path to check
         */
        isBlobUrl(path2) {
          return path2.startsWith("blob:");
        },
        /**
         * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
         * This will return true for windows file paths
         * @param path - The path to check
         */
        hasProtocol(path2) {
          return /^[^/:]+:/.test(this.toPosix(path2));
        },
        /**
         * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
         * @param path - The path to get the protocol from
         */
        getProtocol(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          const matchFile = /^file:\/\/\//.exec(path2);
          if (matchFile) {
            return matchFile[0];
          }
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
          if (matchProtocol) {
            return matchProtocol[0];
          }
          return "";
        },
        /**
         * Converts URL to an absolute path.
         * When loading from a Web Worker, we must use absolute paths.
         * If the URL is already absolute we return it as is
         * If it's not, we convert it
         * @param url - The URL to test
         * @param customBaseUrl - The base URL to use
         * @param customRootUrl - The root URL to use
         */
        toAbsolute(url, customBaseUrl, customRootUrl) {
          assertPath(url);
          if (this.isDataUrl(url) || this.isBlobUrl(url))
            return url;
          const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
          const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
          url = this.toPosix(url);
          if (url.startsWith("/")) {
            return path.join(rootUrl, url.slice(1));
          }
          const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
          return absolutePath;
        },
        /**
         * Normalizes the given path, resolving '..' and '.' segments
         * @param path - The path to normalize
         */
        normalize(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          if (this.isDataUrl(path2) || this.isBlobUrl(path2))
            return path2;
          path2 = this.toPosix(path2);
          let protocol = "";
          const isAbsolute = path2.startsWith("/");
          if (this.hasProtocol(path2)) {
            protocol = this.rootname(path2);
            path2 = path2.slice(protocol.length);
          }
          const trailingSeparator = path2.endsWith("/");
          path2 = normalizeStringPosix(path2, false);
          if (path2.length > 0 && trailingSeparator)
            path2 += "/";
          if (isAbsolute)
            return `/${path2}`;
          return protocol + path2;
        },
        /**
         * Determines if path is an absolute path.
         * Absolute paths can be urls, data urls, or paths on disk
         * @param path - The path to test
         */
        isAbsolute(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          if (this.hasProtocol(path2))
            return true;
          return path2.startsWith("/");
        },
        /**
         * Joins all given path segments together using the platform-specific separator as a delimiter,
         * then normalizes the resulting path
         * @param segments - The segments of the path to join
         */
        join(...segments) {
          if (segments.length === 0) {
            return ".";
          }
          let joined;
          for (let i3 = 0; i3 < segments.length; ++i3) {
            const arg = segments[i3];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = segments[i3 - 1] ?? "";
                if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                  joined += `/../${arg}`;
                } else {
                  joined += `/${arg}`;
                }
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return this.normalize(joined);
        },
        /**
         * Returns the directory name of a path
         * @param path - The path to parse
         */
        dirname(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          path2 = this.toPosix(path2);
          let code = path2.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1;
          let matchedSlash = true;
          const proto = this.getProtocol(path2);
          const origpath = path2;
          path2 = path2.slice(proto.length);
          for (let i3 = path2.length - 1; i3 >= 1; --i3) {
            code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                end = i3;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
          if (hasRoot && end === 1)
            return "//";
          return proto + path2.slice(0, end);
        },
        /**
         * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
         * @param path - The path to parse
         */
        rootname(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          let root = "";
          if (path2.startsWith("/"))
            root = "/";
          else {
            root = this.getProtocol(path2);
          }
          if (this.isUrl(path2)) {
            const index = path2.indexOf("/", root.length);
            if (index !== -1) {
              root = path2.slice(0, index);
            } else
              root = path2;
            if (!root.endsWith("/"))
              root += "/";
          }
          return root;
        },
        /**
         * Returns the last portion of a path
         * @param path - The path to test
         * @param ext - Optional extension to remove
         */
        basename(path2, ext) {
          assertPath(path2);
          if (ext)
            assertPath(ext);
          path2 = removeUrlParams(this.toPosix(path2));
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i3;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2)
              return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i3 = path2.length - 1; i3 >= 0; --i3) {
              const code = path2.charCodeAt(i3);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i3 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i3 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i3;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path2.length;
            return path2.slice(start, end);
          }
          for (i3 = path2.length - 1; i3 >= 0; --i3) {
            if (path2.charCodeAt(i3) === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        },
        /**
         * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
         * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
         * the first character of the basename of path, an empty string is returned.
         * @param path - The path to parse
         */
        extname(path2) {
          assertPath(path2);
          path2 = removeUrlParams(this.toPosix(path2));
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i3 = path2.length - 1; i3 >= 0; --i3) {
            const code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i3 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i3;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path2.slice(startDot, end);
        },
        /**
         * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
         * @param path - The path to parse
         */
        parse(path2) {
          assertPath(path2);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path2.length === 0)
            return ret;
          path2 = removeUrlParams(this.toPosix(path2));
          let code = path2.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path2);
          let start;
          const protocol = "";
          ret.root = this.rootname(path2);
          if (isAbsolute || this.hasProtocol(path2)) {
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i3 = path2.length - 1;
          let preDotState = 0;
          for (; i3 >= start; --i3) {
            code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i3 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i3;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path2.slice(1, end);
              else
                ret.base = ret.name = path2.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path2.slice(1, startDot);
              ret.base = path2.slice(1, end);
            } else {
              ret.name = path2.slice(startPart, startDot);
              ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
          }
          ret.dir = this.dirname(path2);
          if (protocol)
            ret.dir = protocol + ret.dir;
          return ret;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/convertToList.mjs
  var convertToList;
  var init_convertToList = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
      "use strict";
      convertToList = (input, transform2, forceTransform = false) => {
        if (!Array.isArray(input)) {
          input = [input];
        }
        if (!transform2) {
          return input;
        }
        return input.map((item) => {
          if (typeof item === "string" || forceTransform) {
            return transform2(item);
          }
          return item;
        });
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
  function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i3 = 0; i3 < id.length; i3++) {
      const value = id[i3];
      if (depth < ids.length - 1) {
        processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }
  var init_createStringVariations = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
  var isSingleItem;
  var init_isSingleItem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
      "use strict";
      isSingleItem = (item) => !Array.isArray(item);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
  function getUrlExtension(url) {
    return url.split(".").pop().split("?").shift().split("#").shift();
  }
  var Resolver;
  var init_Resolver = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_createStringVariations();
      init_isSingleItem();
      Resolver = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          };
          this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
          this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
          this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
          this._assetMap = {};
          this._preferredOrder = [];
          this._parsers = [];
          this._resolverHash = {};
          this._bundles = {};
        }
        /**
         * Override how the resolver deals with generating bundle ids.
         * must be called before any bundles are added
         * @param bundleIdentifier - the bundle identifier options
         */
        setBundleIdentifier(bundleIdentifier) {
          this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
          this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
          this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
          if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
          }
        }
        /**
         * Let the resolver know which assets you prefer to use when resolving assets.
         * Multiple prefer user defined rules can be added.
         * @example
         * resolver.prefer({
         *     // first look for something with the correct format, and then then correct resolution
         *     priority: ['format', 'resolution'],
         *     params:{
         *         format:'webp', // prefer webp images
         *         resolution: 2, // prefer a resolution of 2
         *     }
         * })
         * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
         * resolver.resolveUrl('foo') // => 'bar@2x.webp'
         * @param preferOrders - the prefer options
         */
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
              prefer.priority = Object.keys(prefer.params);
            }
          });
          this._resolverHash = {};
        }
        /**
         * Set the base path to prepend to all urls when resolving
         * @example
         * resolver.basePath = 'https://home.com/';
         * resolver.add('foo', 'bar.ong');
         * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
         * @param basePath - the base path to use
         */
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        /**
         * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
         * default value for browsers is `window.location.origin`
         * @example
         * // Application hosted on https://home.com/some-path/index.html
         * resolver.basePath = 'https://home.com/some-path/';
         * resolver.rootPath = 'https://home.com/';
         * resolver.add('foo', '/bar.png');
         * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
         * @param rootPath - the root path to use
         */
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        /**
         * All the active URL parsers that help the parser to extract information and create
         * an asset object-based on parsing the URL itself.
         *
         * Can be added using the extensions API
         * @example
         * resolver.add('foo', [
         *     {
         *         resolution: 2,
         *         format: 'png',
         *         src: 'image@2x.png',
         *     },
         *     {
         *         resolution:1,
         *         format:'png',
         *         src: 'image.png',
         *     },
         * ]);
         *
         * // With a url parser the information such as resolution and file format could extracted from the url itself:
         * extensions.add({
         *     extension: ExtensionType.ResolveParser,
         *     test: loadTextures.test, // test if url ends in an image
         *     parse: (value: string) =>
         *     ({
         *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
         *         format: value.split('.').pop(),
         *         src: value,
         *     }),
         * });
         *
         * // Now resolution and format can be extracted from the url
         * resolver.add('foo', [
         *     'image@2x.png',
         *     'image.png',
         * ]);
         */
        get parsers() {
          return this._parsers;
        }
        /** Used for testing, this resets the resolver to its initial state */
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
          this._assetMap = {};
          this._preferredOrder = [];
          this._resolverHash = {};
          this._rootPath = null;
          this._basePath = null;
          this._manifest = null;
          this._bundles = {};
          this._defaultSearchParams = null;
        }
        /**
         * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
         * @param searchParams - the default url parameters to append when resolving urls
         */
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
          } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        /**
         * Returns the aliases for a given asset
         * @param asset - the asset to get the aliases for
         */
        getAlias(asset) {
          const { alias, src } = asset;
          const aliasesToUse = convertToList(
            alias || src,
            (value) => {
              if (typeof value === "string")
                return value;
              if (Array.isArray(value))
                return value.map((v2) => v2?.src ?? v2);
              if (value?.src)
                return value.src;
              return value;
            },
            true
          );
          return aliasesToUse;
        }
        /**
         * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
         * generally a manifest would be built using a tool.
         * @param manifest - the manifest to add to the resolver
         */
        addManifest(manifest) {
          if (this._manifest) {
            warn("[Resolver] Manifest already exists, this will be overwritten");
          }
          this._manifest = manifest;
          manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        /**
         * This adds a bundle of assets in one go so that you can resolve them as a group.
         * For example you could add a bundle for each screen in you pixi app
         * @example
         * resolver.addBundle('animals', [
         *  { alias: 'bunny', src: 'bunny.png' },
         *  { alias: 'chicken', src: 'chicken.png' },
         *  { alias: 'thumper', src: 'thumper.png' },
         * ]);
         * // or
         * resolver.addBundle('animals', {
         *     bunny: 'bunny.png',
         *     chicken: 'chicken.png',
         *     thumper: 'thumper.png',
         * });
         *
         * const resolvedAssets = await resolver.resolveBundle('animals');
         * @param bundleId - The id of the bundle to add
         * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
         */
        addBundle(bundleId, assets) {
          const assetNames = [];
          let convertedAssets = assets;
          if (!Array.isArray(assets)) {
            convertedAssets = Object.entries(assets).map(([alias, src]) => {
              if (typeof src === "string" || Array.isArray(src)) {
                return { alias, src };
              }
              return { alias, ...src };
            });
          }
          convertedAssets.forEach((asset) => {
            const srcs = asset.src;
            const aliases = asset.alias;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              ...{
                alias: ids,
                src: srcs
              }
            });
          });
          this._bundles[bundleId] = assetNames;
        }
        /**
         * Tells the resolver what keys are associated with witch asset.
         * The most important thing the resolver does
         * @example
         * // Single key, single asset:
         * resolver.add({alias: 'foo', src: 'bar.png');
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Multiple keys, single asset:
         * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
         * resolver.resolveUrl('foo') // => 'bar.png'
         * resolver.resolveUrl('boo') // => 'bar.png'
         *
         * // Multiple keys, multiple assets:
         * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Add custom data attached to the resolver
         * Resolver.add({
         *     alias: 'bunnyBooBooSmooth',
         *     src: 'bunny{png,webp}',
         *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
         * });
         *
         * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
         * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
         */
        add(aliases) {
          const assets = [];
          if (Array.isArray(aliases)) {
            assets.push(...aliases);
          } else {
            assets.push(aliases);
          }
          let keyCheck;
          keyCheck = (key) => {
            if (this.hasKey(key)) {
              warn(`[Resolver] already has key: ${key} overwriting`);
            }
          };
          const assetArray = convertToList(assets);
          assetArray.forEach((asset) => {
            const { src } = asset;
            let { data, format, loadParser } = asset;
            const srcsToUse = convertToList(src).map((src2) => {
              if (typeof src2 === "string") {
                return createStringVariations(src2);
              }
              return Array.isArray(src2) ? src2 : [src2];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs) => {
              srcs.forEach((src2) => {
                let formattedAsset = {};
                if (typeof src2 !== "object") {
                  formattedAsset.src = src2;
                  for (let i3 = 0; i3 < this._parsers.length; i3++) {
                    const parser = this._parsers[i3];
                    if (parser.test(src2)) {
                      formattedAsset = parser.parse(src2);
                      break;
                    }
                  }
                } else {
                  data = src2.data ?? data;
                  format = src2.format ?? format;
                  loadParser = src2.loadParser ?? loadParser;
                  formattedAsset = {
                    ...formattedAsset,
                    ...src2
                  };
                }
                if (!aliasesToUse) {
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                }
                formattedAsset = this._buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data,
                  format,
                  loadParser
                });
                resolvedAssets.push(formattedAsset);
              });
            });
            aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        // TODO: this needs an overload like load did in Assets
        /**
         * If the resolver has had a manifest set via setManifest, this will return the assets urls for
         * a given bundleId or bundleIds.
         * @example
         * // Manifest Example
         * const manifest = {
         *     bundles: [
         *         {
         *             name: 'load-screen',
         *             assets: [
         *                 {
         *                     alias: 'background',
         *                     src: 'sunset.png',
         *                 },
         *                 {
         *                     alias: 'bar',
         *                     src: 'load-bar.{png,webp}',
         *                 },
         *             ],
         *         },
         *         {
         *             name: 'game-screen',
         *             assets: [
         *                 {
         *                     alias: 'character',
         *                     src: 'robot.png',
         *                 },
         *                 {
         *                     alias: 'enemy',
         *                     src: 'bad-guy.png',
         *                 },
         *             ],
         *         },
         *     ]
         * };
         *
         * resolver.setManifest(manifest);
         * const resolved = resolver.resolveBundle('load-screen');
         * @param bundleIds - The bundle ids to resolve
         * @returns All the bundles assets or a hash of assets for each bundle specified
         */
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem(bundleIds);
          bundleIds = convertToList(bundleIds);
          const out2 = {};
          bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames);
              const assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          });
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        /**
         * Does exactly what resolve does, but returns just the URL rather than the whole asset object
         * @param key - The key or keys to resolve
         * @returns - The URLs associated with the key(s)
         */
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key !== "string") {
            const out2 = {};
            for (const i3 in result) {
              out2[i3] = result[i3].src;
            }
            return out2;
          }
          return result.src;
        }
        resolve(keys) {
          const singleAsset = isSingleItem(keys);
          keys = convertToList(keys);
          const result = {};
          keys.forEach((key) => {
            if (!this._resolverHash[key]) {
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const preferredOrder = this._getPreferredOrder(assets);
                preferredOrder?.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value) => {
                    const filteredAssets = assets.filter((asset) => {
                      if (asset[priorityKey]) {
                        return asset[priorityKey] === value;
                      }
                      return false;
                    });
                    if (filteredAssets.length) {
                      assets = filteredAssets;
                    }
                  });
                });
                this._resolverHash[key] = assets[0];
              } else {
                this._resolverHash[key] = this._buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
              }
            }
            result[key] = this._resolverHash[key];
          });
          return singleAsset ? result[keys[0]] : result;
        }
        /**
         * Checks if an asset with a given key exists in the resolver
         * @param key - The key of the asset
         */
        hasKey(key) {
          return !!this._assetMap[key];
        }
        /**
         * Checks if a bundle with the given key exists in the resolver
         * @param key - The key of the bundle
         */
        hasBundle(key) {
          return !!this._bundles[key];
        }
        /**
         * Internal function for figuring out what prefer criteria an asset should use.
         * @param assets
         */
        _getPreferredOrder(assets) {
          for (let i3 = 0; i3 < assets.length; i3++) {
            const asset = assets[0];
            const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred) {
              return preferred;
            }
          }
          return this._preferredOrder[0];
        }
        /**
         * Appends the default url parameters to the url
         * @param url - The url to append the default parameters to
         * @returns - The url with the default parameters appended
         */
        _appendDefaultSearchParams(url) {
          if (!this._defaultSearchParams)
            return url;
          const paramConnector = /\?/.test(url) ? "&" : "?";
          return `${url}${paramConnector}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(formattedAsset, data) {
          const { aliases, data: assetData, loadParser, format } = data;
          if (this._basePath || this._rootPath) {
            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
          formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
          formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
          return formattedAsset;
        }
      };
      Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
  var copySearchParams;
  var init_copySearchParams = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
      "use strict";
      copySearchParams = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        if (searchParams) {
          targetUrl += `?${searchParams}`;
        }
        return targetUrl;
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
  function init() {
    for (let i3 = 0; i3 < 16; i3++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i3] * ux[j2] + vx[i3] * uy[j2]);
        const _uy = signum(uy[i3] * ux[j2] + vy[i3] * uy[j2]);
        const _vx = signum(ux[i3] * vx[j2] + vx[i3] * vy[j2]);
        const _vy = signum(uy[i3] * vx[j2] + vy[i3] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i3 = 0; i3 < 16; i3++) {
      const mat = new Matrix();
      mat.set(ux[i3], uy[i3], vx[i3], vy[i3], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
  var init_groupD8 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
      init_Matrix();
      ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley = [];
      rotationMatrices = [];
      signum = Math.sign;
      init();
      groupD8 = {
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 0       | East      |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        E: 0,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 45     | Southeast |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        SE: 1,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 90     | South     |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        S: 2,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 135    | Southwest |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        SW: 3,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 180     | West      |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        W: 4,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -135/225 | Northwest    |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        NW: 5,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -90/270  | North        |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        N: 6,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -45/315  | Northeast    |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        NE: 7,
        /**
         * Reflection about Y-axis.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MIRROR_VERTICAL: 8,
        /**
         * Reflection about the main diagonal.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MAIN_DIAGONAL: 10,
        /**
         * Reflection about X-axis.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MIRROR_HORIZONTAL: 12,
        /**
         * Reflection about reverse diagonal.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        REVERSE_DIAGONAL: 14,
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the U-axis
         *    after rotating the axes.
         */
        uX: (ind) => ux[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the U-axis
         *    after rotating the axes.
         */
        uY: (ind) => uy[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the V-axis
         *    after rotating the axes.
         */
        vX: (ind) => vx[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the V-axis
         *    after rotating the axes.
         */
        vY: (ind) => vy[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotation - symmetry whose opposite
         *   is needed. Only rotations have opposite symmetries while
         *   reflections don't.
         * @returns {GD8Symmetry} The opposite symmetry of `rotation`
         */
        inv: (rotation) => {
          if (rotation & 8) {
            return rotation & 15;
          }
          return -rotation & 7;
        },
        /**
         * Composes the two D8 operations.
         *
         * Taking `^` as reflection:
         *
         * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
         * |-------|-----|-----|-----|-----|------|-------|-------|-------|
         * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
         * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
         * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
         * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
         * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
         * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
         * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
         * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
         *
         * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation, which
         *   is the row in the above cayley table.
         * @param {GD8Symmetry} rotationFirst - First operation, which
         *   is the column in the above cayley table.
         * @returns {GD8Symmetry} Composed operation
         */
        add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
        /**
         * Reverse of `add`.
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation
         * @param {GD8Symmetry} rotationFirst - First operation
         * @returns {GD8Symmetry} Result
         */
        sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
        /**
         * Adds 180 degrees to rotation, which is a commutative
         * operation.
         * @memberof maths.groupD8
         * @param {number} rotation - The number to rotate.
         * @returns {number} Rotated number
         */
        rotate180: (rotation) => rotation ^ 4,
        /**
         * Checks if the rotation angle is vertical, i.e. south
         * or north. It doesn't work for reflections.
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotation - The number to check.
         * @returns {boolean} Whether or not the direction is vertical
         */
        isVertical: (rotation) => (rotation & 3) === 2,
        // rotation % 4 === 2
        /**
         * Approximates the vector `V(dx,dy)` into one of the
         * eight directions provided by `groupD8`.
         * @memberof maths.groupD8
         * @param {number} dx - X-component of the vector
         * @param {number} dy - Y-component of the vector
         * @returns {GD8Symmetry} Approximation of the vector into
         *  one of the eight symmetries.
         */
        byDirection: (dx, dy) => {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return groupD8.S;
            }
            return groupD8.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return groupD8.E;
            }
            return groupD8.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return groupD8.SE;
            }
            return groupD8.SW;
          } else if (dx > 0) {
            return groupD8.NE;
          }
          return groupD8.NW;
        },
        /**
         * Helps sprite to compensate texture packer rotation.
         * @memberof maths.groupD8
         * @param {Matrix} matrix - sprite world matrix
         * @param {GD8Symmetry} rotation - The rotation factor to use.
         * @param {number} tx - sprite anchoring
         * @param {number} ty - sprite anchoring
         */
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices[groupD8.inv(rotation)];
          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/misc/NOOP.mjs
  var NOOP;
  var init_NOOP = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
      "use strict";
      NOOP = () => {
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/misc/pow2.mjs
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  function log2(v2) {
    let r2 = (v2 > 65535 ? 1 : 0) << 4;
    v2 >>>= r2;
    let shift = (v2 > 255 ? 1 : 0) << 3;
    v2 >>>= shift;
    r2 |= shift;
    shift = (v2 > 15 ? 1 : 0) << 2;
    v2 >>>= shift;
    r2 |= shift;
    shift = (v2 > 3 ? 1 : 0) << 1;
    v2 >>>= shift;
    r2 |= shift;
    return r2 | v2 >> 1;
  }
  var init_pow2 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  var init_definedProps = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  function createResourceIdFromString(value) {
    const id = idHash[value];
    if (id === void 0) {
      idHash[value] = uid("resource");
    }
    return id;
  }
  var idHash, _TextureStyle, TextureStyle;
  var init_TextureStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
      init_eventemitter3();
      init_uid();
      init_deprecation();
      idHash = /* @__PURE__ */ Object.create(null);
      _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
        /**
         * @param options - options for the style
         */
        constructor(options = {}) {
          super();
          this._resourceType = "textureSampler";
          this._touched = 0;
          this._maxAnisotropy = 1;
          this.destroyed = false;
          options = { ..._TextureStyle2.defaultOptions, ...options };
          this.addressMode = options.addressMode;
          this.addressModeU = options.addressModeU ?? this.addressModeU;
          this.addressModeV = options.addressModeV ?? this.addressModeV;
          this.addressModeW = options.addressModeW ?? this.addressModeW;
          this.scaleMode = options.scaleMode;
          this.magFilter = options.magFilter ?? this.magFilter;
          this.minFilter = options.minFilter ?? this.minFilter;
          this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
          this.lodMinClamp = options.lodMinClamp;
          this.lodMaxClamp = options.lodMaxClamp;
          this.compare = options.compare;
          this.maxAnisotropy = options.maxAnisotropy ?? 1;
        }
        set addressMode(value) {
          this.addressModeU = value;
          this.addressModeV = value;
          this.addressModeW = value;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this.addressModeU;
        }
        set wrapMode(value) {
          deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
          this.addressMode = value;
        }
        get wrapMode() {
          return this.addressMode;
        }
        set scaleMode(value) {
          this.magFilter = value;
          this.minFilter = value;
          this.mipmapFilter = value;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this.magFilter;
        }
        /** Specifies the maximum anisotropy value clamp used by the sampler. */
        set maxAnisotropy(value) {
          this._maxAnisotropy = Math.min(value, 16);
          if (this._maxAnisotropy > 1) {
            this.scaleMode = "linear";
          }
        }
        get maxAnisotropy() {
          return this._maxAnisotropy;
        }
        // TODO - move this to WebGL?
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId();
        }
        update() {
          this.emit("change", this);
          this._sharedResourceId = null;
        }
        _generateResourceId() {
          const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
          this._sharedResourceId = createResourceIdFromString(bigKey);
          return this._resourceId;
        }
        /** Destroys the style */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this.removeAllListeners();
        }
      };
      _TextureStyle.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
      };
      TextureStyle = _TextureStyle;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource, TextureSource;
  var init_TextureSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
      init_eventemitter3();
      init_pow2();
      init_definedProps();
      init_uid();
      init_TextureStyle();
      _TextureSource = class _TextureSource2 extends eventemitter3_default {
        /**
         * @param options - options for creating a new TextureSource
         */
        constructor(options = {}) {
          super();
          this.options = options;
          this.uid = uid("textureSource");
          this._resourceType = "textureSource";
          this._resourceId = uid("resource");
          this.uploadMethodId = "unknown";
          this._resolution = 1;
          this.pixelWidth = 1;
          this.pixelHeight = 1;
          this.width = 1;
          this.height = 1;
          this.sampleCount = 1;
          this.mipLevelCount = 1;
          this.autoGenerateMipmaps = false;
          this.format = "rgba8unorm";
          this.dimension = "2d";
          this.antialias = false;
          this._touched = 0;
          this._batchTick = -1;
          this._textureBindLocation = -1;
          options = { ..._TextureSource2.defaultOptions, ...options };
          this.label = options.label ?? "";
          this.resource = options.resource;
          this.autoGarbageCollect = options.autoGarbageCollect;
          this._resolution = options.resolution;
          if (options.width) {
            this.pixelWidth = options.width * this._resolution;
          } else {
            this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
          }
          if (options.height) {
            this.pixelHeight = options.height * this._resolution;
          } else {
            this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
          }
          this.width = this.pixelWidth / this._resolution;
          this.height = this.pixelHeight / this._resolution;
          this.format = options.format;
          this.dimension = options.dimensions;
          this.mipLevelCount = options.mipLevelCount;
          this.autoGenerateMipmaps = options.autoGenerateMipmaps;
          this.sampleCount = options.sampleCount;
          this.antialias = options.antialias;
          this.alphaMode = options.alphaMode;
          this.style = new TextureStyle(definedProps(options));
          this.destroyed = false;
          this._refreshPOT();
        }
        /** returns itself */
        get source() {
          return this;
        }
        /** the style of the texture */
        get style() {
          return this._style;
        }
        set style(value) {
          if (this.style === value)
            return;
          this._style?.off("change", this._onStyleChange, this);
          this._style = value;
          this._style?.on("change", this._onStyleChange, this);
          this._onStyleChange();
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this._style.addressMode;
        }
        set addressMode(value) {
          this._style.addressMode = value;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get repeatMode() {
          return this._style.addressMode;
        }
        set repeatMode(value) {
          this._style.addressMode = value;
        }
        /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
        get magFilter() {
          return this._style.magFilter;
        }
        set magFilter(value) {
          this._style.magFilter = value;
        }
        /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
        get minFilter() {
          return this._style.minFilter;
        }
        set minFilter(value) {
          this._style.minFilter = value;
        }
        /** Specifies behavior for sampling between mipmap levels. */
        get mipmapFilter() {
          return this._style.mipmapFilter;
        }
        set mipmapFilter(value) {
          this._style.mipmapFilter = value;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMinClamp() {
          return this._style.lodMinClamp;
        }
        set lodMinClamp(value) {
          this._style.lodMinClamp = value;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMaxClamp() {
          return this._style.lodMaxClamp;
        }
        set lodMaxClamp(value) {
          this._style.lodMaxClamp = value;
        }
        _onStyleChange() {
          this.emit("styleChange", this);
        }
        /** call this if you have modified the texture outside of the constructor */
        update() {
          if (this.resource) {
            const resolution = this._resolution;
            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
            if (didResize)
              return;
          }
          this.emit("update", this);
        }
        /** Destroys this texture source */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          if (this._style) {
            this._style.destroy();
            this._style = null;
          }
          this.uploadMethodId = null;
          this.resource = null;
          this.removeAllListeners();
        }
        /**
         * This will unload the Texture source from the GPU. This will free up the GPU memory
         * As soon as it is required fore rendering, it will be re-uploaded.
         */
        unload() {
          this._resourceId = uid("resource");
          this.emit("change", this);
          this.emit("unload", this);
        }
        /** the width of the resource. This is the REAL pure number, not accounting resolution   */
        get resourceWidth() {
          const { resource } = this;
          return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
        }
        /** the height of the resource. This is the REAL pure number, not accounting resolution */
        get resourceHeight() {
          const { resource } = this;
          return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
        }
        /**
         * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
         * but will the size of the texture when rendered.
         *
         * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
         * density will have increased)
         */
        get resolution() {
          return this._resolution;
        }
        set resolution(resolution) {
          if (this._resolution === resolution)
            return;
          this._resolution = resolution;
          this.width = this.pixelWidth / resolution;
          this.height = this.pixelHeight / resolution;
        }
        /**
         * Resize the texture, this is handy if you want to use the texture as a render texture
         * @param width - the new width of the texture
         * @param height - the new height of the texture
         * @param resolution - the new resolution of the texture
         * @returns - if the texture was resized
         */
        resize(width, height, resolution) {
          resolution = resolution || this._resolution;
          width = width || this.width;
          height = height || this.height;
          const newPixelWidth = Math.round(width * resolution);
          const newPixelHeight = Math.round(height * resolution);
          this.width = newPixelWidth / resolution;
          this.height = newPixelHeight / resolution;
          this._resolution = resolution;
          if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
            return false;
          }
          this._refreshPOT();
          this.pixelWidth = newPixelWidth;
          this.pixelHeight = newPixelHeight;
          this.emit("resize", this);
          this._resourceId = uid("resource");
          this.emit("change", this);
          return true;
        }
        /**
         * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
         * This is only important for RenderTexture instances, as standard Texture instances will have their
         * mipmaps generated on upload. You should call this method after you make any change to the texture
         *
         * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
         * We want you, the developer to specify when this action should happen.
         *
         * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
         */
        updateMipmaps() {
          if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
            this.emit("updateMipmaps", this);
          }
        }
        set wrapMode(value) {
          this._style.wrapMode = value;
        }
        get wrapMode() {
          return this._style.wrapMode;
        }
        set scaleMode(value) {
          this._style.scaleMode = value;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this._style.scaleMode;
        }
        /**
         * Refresh check for isPowerOfTwo texture based on size
         * @private
         */
        _refreshPOT() {
          this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
        }
        static test(_resource) {
          throw new Error("Unimplemented");
        }
      };
      _TextureSource.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: false,
        sampleCount: 1,
        antialias: false,
        autoGarbageCollect: false
      };
      TextureSource = _TextureSource;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
  var BufferImageSource;
  var init_BufferImageSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
      init_Extensions();
      init_TextureSource();
      BufferImageSource = class extends TextureSource {
        constructor(options) {
          const buffer = options.resource || new Float32Array(options.width * options.height * 4);
          let format = options.format;
          if (!format) {
            if (buffer instanceof Float32Array) {
              format = "rgba32float";
            } else if (buffer instanceof Int32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Uint32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Int16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Uint16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Int8Array) {
              format = "bgra8unorm";
            } else {
              format = "bgra8unorm";
            }
          }
          super({
            ...options,
            resource: buffer,
            format
          });
          this.uploadMethodId = "buffer";
        }
        static test(resource) {
          return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
        }
      };
      BufferImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat, TextureMatrix;
  var init_TextureMatrix = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
      init_Matrix();
      tempMat = new Matrix();
      TextureMatrix = class {
        /**
         * @param texture - observed texture
         * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         */
        constructor(texture, clampMargin) {
          this.mapCoord = new Matrix();
          this.uClampFrame = new Float32Array(4);
          this.uClampOffset = new Float32Array(2);
          this._textureID = -1;
          this._updateID = 0;
          this.clampOffset = 0;
          if (typeof clampMargin === "undefined") {
            this.clampMargin = texture.width < 10 ? 0 : 0.5;
          } else {
            this.clampMargin = clampMargin;
          }
          this.isSimple = false;
          this.texture = texture;
        }
        /** Texture property. */
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (this.texture === value)
            return;
          this._texture?.removeListener("update", this.update, this);
          this._texture = value;
          this._texture.addListener("update", this.update, this);
          this.update();
        }
        /**
         * Multiplies uvs array to transform
         * @param uvs - mesh uvs
         * @param [out=uvs] - output
         * @returns - output
         */
        multiplyUvs(uvs, out2) {
          if (out2 === void 0) {
            out2 = uvs;
          }
          const mat = this.mapCoord;
          for (let i3 = 0; i3 < uvs.length; i3 += 2) {
            const x2 = uvs[i3];
            const y2 = uvs[i3 + 1];
            out2[i3] = x2 * mat.a + y2 * mat.c + mat.tx;
            out2[i3 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        /**
         * Updates matrices if texture was changed
         * @returns - whether or not it was updated
         */
        update() {
          const tex = this._texture;
          this._updateID++;
          const uvs = tex.uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.orig;
          const trim = tex.trim;
          if (trim) {
            tempMat.set(
              orig.width / trim.width,
              0,
              0,
              orig.height / trim.height,
              -trim.x / trim.width,
              -trim.y / trim.height
            );
            this.mapCoord.append(tempMat);
          }
          const texBase = tex.source;
          const frame = this.uClampFrame;
          const margin = this.clampMargin / texBase._resolution;
          const offset = this.clampOffset / texBase._resolution;
          frame[0] = (tex.frame.x + margin + offset) / texBase.width;
          frame[1] = (tex.frame.y + margin + offset) / texBase.height;
          frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
          frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
          this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
          this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
          this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
          return true;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture;
  var init_Texture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
      init_eventemitter3();
      init_groupD8();
      init_Rectangle();
      init_uid();
      init_deprecation();
      init_NOOP();
      init_BufferImageSource();
      init_TextureSource();
      init_TextureMatrix();
      Texture = class extends eventemitter3_default {
        /**
         * @param {rendering.TextureOptions} options - Options for the texture
         */
        constructor({
          source: source7,
          label,
          frame,
          orig,
          trim,
          defaultAnchor,
          defaultBorders,
          rotate,
          dynamic
        } = {}) {
          super();
          this.uid = uid("texture");
          this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
          this.frame = new Rectangle();
          this.noFrame = false;
          this.dynamic = false;
          this.isTexture = true;
          this.label = label;
          this.source = source7?.source ?? new TextureSource();
          this.noFrame = !frame;
          if (frame) {
            this.frame.copyFrom(frame);
          } else {
            const { width, height } = this._source;
            this.frame.width = width;
            this.frame.height = height;
          }
          this.orig = orig || this.frame;
          this.trim = trim;
          this.rotate = rotate ?? 0;
          this.defaultAnchor = defaultAnchor;
          this.defaultBorders = defaultBorders;
          this.destroyed = false;
          this.dynamic = dynamic || false;
          this.updateUvs();
        }
        set source(value) {
          if (this._source) {
            this._source.off("resize", this.update, this);
          }
          this._source = value;
          value.on("resize", this.update, this);
          this.emit("update", this);
        }
        /** the underlying source of the texture (equivalent of baseTexture in v7) */
        get source() {
          return this._source;
        }
        /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
        get textureMatrix() {
          if (!this._textureMatrix) {
            this._textureMatrix = new TextureMatrix(this);
          }
          return this._textureMatrix;
        }
        /** The width of the Texture in pixels. */
        get width() {
          return this.orig.width;
        }
        /** The height of the Texture in pixels. */
        get height() {
          return this.orig.height;
        }
        /** Call this function when you have modified the frame of this texture. */
        updateUvs() {
          const { uvs, frame } = this;
          const { width, height } = this._source;
          const nX = frame.x / width;
          const nY = frame.y / height;
          const nW = frame.width / width;
          const nH = frame.height / height;
          let rotate = this.rotate;
          if (rotate) {
            const w2 = nW / 2;
            const h2 = nH / 2;
            const cX = nX + w2;
            const cY = nY + h2;
            rotate = groupD8.add(rotate, groupD8.NW);
            uvs.x0 = cX + w2 * groupD8.uX(rotate);
            uvs.y0 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x1 = cX + w2 * groupD8.uX(rotate);
            uvs.y1 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x2 = cX + w2 * groupD8.uX(rotate);
            uvs.y2 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x3 = cX + w2 * groupD8.uX(rotate);
            uvs.y3 = cY + h2 * groupD8.uY(rotate);
          } else {
            uvs.x0 = nX;
            uvs.y0 = nY;
            uvs.x1 = nX + nW;
            uvs.y1 = nY;
            uvs.x2 = nX + nW;
            uvs.y2 = nY + nH;
            uvs.x3 = nX;
            uvs.y3 = nY + nH;
          }
        }
        /**
         * Destroys this texture
         * @param destroySource - Destroy the source when the texture is destroyed.
         */
        destroy(destroySource = false) {
          if (this._source) {
            if (destroySource) {
              this._source.destroy();
              this._source = null;
            }
          }
          this._textureMatrix = null;
          this.destroyed = true;
          this.emit("destroy", this);
          this.removeAllListeners();
        }
        /**
         * Call this if you have modified the `texture outside` of the constructor.
         *
         * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
         */
        update() {
          if (this.noFrame) {
            this.frame.width = this._source.width;
            this.frame.height = this._source.height;
          }
          this.updateUvs();
          this.emit("update", this);
        }
        /** @deprecated since 8.0.0 */
        get baseTexture() {
          deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
          return this._source;
        }
      };
      Texture.EMPTY = new Texture({
        label: "EMPTY",
        source: new TextureSource({
          label: "EMPTY"
        })
      });
      Texture.EMPTY.destroy = NOOP;
      Texture.WHITE = new Texture({
        source: new BufferImageSource({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE"
        }),
        label: "WHITE"
      });
      Texture.WHITE.destroy = NOOP;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet, Spritesheet;
  var init_Spritesheet = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
      init_Rectangle();
      init_Texture();
      _Spritesheet = class _Spritesheet2 {
        /**
         * @param texture - Reference to the source BaseTexture object.
         * @param {object} data - Spritesheet image data.
         */
        constructor(texture, data) {
          this.linkedSheets = [];
          this._texture = texture instanceof Texture ? texture : null;
          this.textureSource = texture.source;
          this.textures = {};
          this.animations = {};
          this.data = data;
          const metaResolution = parseFloat(data.meta.scale);
          if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
          } else {
            this.resolution = texture.source._resolution;
          }
          this._frames = this.data.frames;
          this._frameKeys = Object.keys(this._frames);
          this._batchIndex = 0;
          this._callback = null;
        }
        /**
         * Parser spritesheet from loaded data. This is done asynchronously
         * to prevent creating too many Texture within a single process.
         */
        parse() {
          return new Promise((resolve) => {
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
              this._processFrames(0);
              this._processAnimations();
              this._parseComplete();
            } else {
              this._nextBatch();
            }
          });
        }
        /**
         * Process a batch of frames
         * @param initialFrameIndex - The index of frame to start.
         */
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet2.BATCH_SIZE;
          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            const i3 = this._frameKeys[frameIndex];
            const data = this._frames[i3];
            const rect = data.frame;
            if (rect) {
              let frame = null;
              let trim = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
              const orig = new Rectangle(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              if (data.rotated) {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.h) / this.resolution,
                  Math.floor(rect.w) / this.resolution
                );
              } else {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim = new Rectangle(
                  Math.floor(data.spriteSourceSize.x) / this.resolution,
                  Math.floor(data.spriteSourceSize.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              this.textures[i3] = new Texture({
                source: this.textureSource,
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders,
                label: i3.toString()
              });
            }
            frameIndex++;
          }
        }
        /** Parse animations config. */
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i3 = 0; i3 < animations[animName].length; i3++) {
              const frameName = animations[animName][i3];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        /** The parse has completed. */
        _parseComplete() {
          const callback = this._callback;
          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        }
        /** Begin the next batch of textures. */
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(() => {
            if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
              this._nextBatch();
            } else {
              this._processAnimations();
              this._parseComplete();
            }
          }, 0);
        }
        /**
         * Destroy Spritesheet and don't use after this.
         * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
         */
        destroy(destroyBase = false) {
          for (const i3 in this.textures) {
            this.textures[i3].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
          }
          this._texture = null;
          this.textureSource = null;
          this.linkedSheets = [];
        }
      };
      _Spritesheet.BATCH_SIZE = 1e3;
      Spritesheet = _Spritesheet;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out2 = {};
    keys.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i3) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i3]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages, spritesheetAsset;
  var init_spritesheetAsset = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
      init_LoaderParser();
      init_Resolver();
      init_copySearchParams();
      init_Extensions();
      init_Texture();
      init_path();
      init_Spritesheet();
      validImages = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
      ];
      spritesheetAsset = {
        extension: ExtensionType.Asset,
        /** Handle the caching of the related Spritesheet Textures */
        cache: {
          test: (asset) => asset instanceof Spritesheet,
          getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
        },
        /** Resolve the resolution of the asset. */
        resolver: {
          extension: {
            type: ExtensionType.ResolveParser,
            name: "resolveSpritesheet"
          },
          test: (value) => {
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format = split.pop();
            return extension === "json" && validImages.includes(format);
          },
          parse: (value) => {
            const split = value.split(".");
            return {
              resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
              format: split[split.length - 2],
              src: value
            };
          }
        },
        /**
         * Loader plugin that parses sprite sheets!
         * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
         * If it is, we load the spritesheets image and parse the data into Spritesheet
         * All textures in the sprite sheet are then added to the cache
         */
        loader: {
          name: "spritesheetLoader",
          extension: {
            type: ExtensionType.LoadParser,
            priority: LoaderParserPriority.Normal,
            name: "spritesheetLoader"
          },
          async testParse(asset, options) {
            return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
          },
          async parse(asset, options, loader) {
            const {
              texture: imageTexture,
              // if user need to use preloaded texture
              imageFilename
              // if user need to use custom filename (not from jsonFile.meta.image)
            } = options?.data ?? {};
            let basePath = path.dirname(options.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
              basePath += "/";
            }
            let texture;
            if (imageTexture instanceof Texture) {
              texture = imageTexture;
            } else {
              const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
              const assets = await loader.load([imagePath]);
              texture = assets[imagePath];
            }
            const spritesheet = new Spritesheet(
              texture.source,
              asset
            );
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
              const promises = [];
              for (const item of multiPacks) {
                if (typeof item !== "string") {
                  continue;
                }
                let itemUrl = basePath + item;
                if (options.data?.ignoreMultiPack) {
                  continue;
                }
                itemUrl = copySearchParams(itemUrl, options.src);
                promises.push(loader.load({
                  src: itemUrl,
                  data: {
                    ignoreMultiPack: true
                  }
                }));
              }
              const res = await Promise.all(promises);
              spritesheet.linkedSheets = res;
              res.forEach((item) => {
                item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
              });
            }
            return spritesheet;
          },
          async unload(spritesheet, _resolvedAsset, loader) {
            await loader.unload(spritesheet.textureSource._sourceOrigin);
            spritesheet.destroy(false);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/spritesheet/init.mjs
  var init_init4 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/spritesheet/init.mjs"() {
      init_Extensions();
      init_spritesheetAsset();
      extensions.add(spritesheetAsset);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
  function updateQuadBounds(bounds, anchor, texture, padding) {
    const { width, height } = texture.orig;
    const trim = texture.trim;
    if (trim) {
      const sourceWidth = trim.width;
      const sourceHeight = trim.height;
      bounds.minX = trim.x - anchor._x * width - padding;
      bounds.maxX = bounds.minX + sourceWidth;
      bounds.minY = trim.y - anchor._y * height - padding;
      bounds.maxY = bounds.minY + sourceHeight;
    } else {
      bounds.minX = -anchor._x * width - padding;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height - padding;
      bounds.maxY = bounds.minY + height;
    }
    return;
  }
  var init_updateQuadBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
  var ViewContainer;
  var init_ViewContainer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/view/ViewContainer.mjs"() {
      init_Bounds();
      init_Container();
      ViewContainer = class extends Container {
        constructor() {
          super(...arguments);
          this.canBundle = true;
          this.allowChildren = false;
          this._roundPixels = 0;
          this._lastUsed = 0;
          this._lastInstructionTick = -1;
          this._bounds = new Bounds(0, 1, 0, 0);
          this._boundsDirty = true;
        }
        /** @private */
        _updateBounds() {
        }
        /**
         * Whether or not to round the x/y position of the sprite.
         * @type {boolean}
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(value) {
          this._roundPixels = value ? 1 : 0;
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const bounds = this.bounds;
          const { x: x2, y: y2 } = point;
          return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
        }
        /** @private */
        onViewUpdate() {
          this._didViewChangeTick++;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        destroy(options) {
          super.destroy(options);
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
  var Sprite;
  var init_Sprite = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
      init_ObservablePoint();
      init_Texture();
      init_updateQuadBounds();
      init_ViewContainer();
      Sprite = class extends ViewContainer {
        /**
         * @param options - The options for creating the sprite.
         */
        constructor(options = Texture.EMPTY) {
          if (options instanceof Texture) {
            options = { texture: options };
          }
          const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
          super({
            label: "Sprite",
            ...rest
          });
          this.renderPipeId = "sprite";
          this.batched = true;
          this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          this._sourceBoundsDirty = true;
          this._anchor = new ObservablePoint(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          if (anchor) {
            this.anchor = anchor;
          } else if (texture.defaultAnchor) {
            this.anchor = texture.defaultAnchor;
          }
          this.texture = texture;
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
          if (width !== void 0)
            this.width = width;
          if (height !== void 0)
            this.height = height;
        }
        /**
         * Helper function that creates a new sprite based on the source you provide.
         * The source can be - frame id, image, video, canvas element, video element, texture
         * @param source - Source to create texture from
         * @param [skipCache] - Whether to skip the cache or not
         * @returns The newly created sprite
         */
        static from(source7, skipCache = false) {
          if (source7 instanceof Texture) {
            return new Sprite(source7);
          }
          return new Sprite(Texture.from(source7, skipCache));
        }
        set texture(value) {
          value || (value = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          this._texture = value;
          if (this._width) {
            this._setWidth(this._width, this._texture.orig.width);
          }
          if (this._height) {
            this._setHeight(this._height, this._texture.orig.height);
          }
          this.onViewUpdate();
        }
        /** The texture that the sprite is using. */
        get texture() {
          return this._texture;
        }
        /**
         * The local bounds of the sprite.
         * @type {rendering.Bounds}
         */
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        /**
         * The bounds of the sprite, taking the texture's trim into account.
         * @type {rendering.Bounds}
         */
        get sourceBounds() {
          if (this._sourceBoundsDirty) {
            this._updateSourceBounds();
            this._sourceBoundsDirty = false;
          }
          return this._sourceBounds;
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const bounds = this.sourceBounds;
          if (point.x >= bounds.maxX && point.x <= bounds.minX) {
            if (point.y >= bounds.maxY && point.y <= bounds.minY) {
              return true;
            }
          }
          return false;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;
          bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
        }
        onViewUpdate() {
          this._sourceBoundsDirty = this._boundsDirty = true;
          super.onViewUpdate();
        }
        _updateBounds() {
          updateQuadBounds(this._bounds, this._anchor, this._texture, 0);
        }
        _updateSourceBounds() {
          const anchor = this._anchor;
          const texture = this._texture;
          const sourceBounds = this._sourceBounds;
          const { width, height } = texture.orig;
          sourceBounds.maxX = -anchor._x * width;
          sourceBounds.minX = sourceBounds.maxX + width;
          sourceBounds.maxY = -anchor._y * height;
          sourceBounds.minY = sourceBounds.maxY + height;
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options = false) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._bounds = null;
          this._sourceBounds = null;
          this._anchor = null;
        }
        /**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
         * and passed to the constructor.
         *
         * The default is `(0,0)`, this means the sprite's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite({texture: Texture.WHITE});
         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         */
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value) {
          this._setWidth(value, this._texture.orig.width);
          this._width = value;
        }
        /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value) {
          this._setHeight(value, this._texture.orig.height);
          this._height = value;
        }
        /**
         * Retrieves the size of the Sprite as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the Sprite.
         */
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
          out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
          return out2;
        }
        /**
         * Sets the size of the Sprite to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value, height) {
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          } else {
            height ?? (height = value);
          }
          value !== void 0 && this._setWidth(value, this._texture.orig.width);
          height !== void 0 && this._setHeight(height, this._texture.orig.height);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }
  var tempBounds;
  var init_addMaskBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
      init_Bounds();
      init_getGlobalBounds();
      tempBounds = new Bounds();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix7 = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix7);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix7);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      warn("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      target.updateLocalTransform();
      matrix.append(target.localTransform);
    }
    return matrix;
  }
  var init_addMaskLocalBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
      init_getLocalBounds();
      init_matrixAndBoundsPool();
      init_warn();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask;
  var init_AlphaMask = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
      init_Extensions();
      init_Sprite();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      AlphaMask = class {
        constructor(options) {
          this.priority = 0;
          this.inverse = false;
          this.pipe = "alphaMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.renderMaskToTexture = !(mask instanceof Sprite);
          this.mask.renderable = this.renderMaskToTexture;
          this.mask.includeInBuild = !this.renderMaskToTexture;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          if (!this.inverse) {
            addMaskBounds(this.mask, bounds, skipUpdateTransform);
          }
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Sprite;
        }
      };
      AlphaMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask;
  var init_ColorMask = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
      init_Extensions();
      ColorMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "colorMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
        }
        destroy() {
        }
        static test(mask) {
          return typeof mask === "number";
        }
      };
      ColorMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask;
  var init_StencilMask = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
      init_Extensions();
      init_Container();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      StencilMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "stencilMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.mask.includeInBuild = false;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask.includeInBuild = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Container;
        }
      };
      StencilMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource;
  var init_CanvasSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_TextureSource();
      CanvasSource = class extends TextureSource {
        constructor(options) {
          if (!options.resource) {
            options.resource = DOMAdapter.get().createCanvas();
          }
          if (!options.width) {
            options.width = options.resource.width;
            if (!options.autoDensity) {
              options.width /= options.resolution;
            }
          }
          if (!options.height) {
            options.height = options.resource.height;
            if (!options.autoDensity) {
              options.height /= options.resolution;
            }
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoDensity = options.autoDensity;
          const canvas = options.resource;
          if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {
            this.resizeCanvas();
          }
          this.transparent = !!options.transparent;
        }
        resizeCanvas() {
          if (this.autoDensity) {
            this.resource.style.width = `${this.width}px`;
            this.resource.style.height = `${this.height}px`;
          }
          if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
            this.resource.width = this.pixelWidth;
            this.resource.height = this.pixelHeight;
          }
        }
        resize(width = this.width, height = this.height, resolution = this._resolution) {
          const didResize = super.resize(width, height, resolution);
          if (didResize) {
            this.resizeCanvas();
          }
          return didResize;
        }
        static test(resource) {
          return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
        }
        /**
         * Returns the 2D rendering context for the canvas.
         * Caches the context after creating it.
         * @returns The 2D rendering context of the canvas.
         */
        get context2D() {
          return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
      };
      CanvasSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource;
  var init_ImageSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      init_TextureSource();
      ImageSource = class extends TextureSource {
        constructor(options) {
          if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {
            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);
            const context4 = canvas.getContext("2d");
            context4.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);
            options.resource = canvas;
            warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoGarbageCollect = true;
        }
        static test(resource) {
          return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
        }
      };
      ImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
  async function detectVideoAlphaMode() {
    promise ?? (promise = (async () => {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        return "premultiply-alpha-on-upload";
      }
      const video = await new Promise((resolve) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve(video2);
        video2.onerror = () => resolve(null);
        video2.autoplay = false;
        video2.crossOrigin = "anonymous";
        video2.preload = "auto";
        video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
        video2.load();
      });
      if (!video) {
        return "premultiply-alpha-on-upload";
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      );
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
      gl.getExtension("WEBGL_lose_context")?.loseContext();
      return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
  }
  var promise;
  var init_detectVideoAlphaMode = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource, VideoSource;
  var init_VideoSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
      init_Extensions();
      init_Ticker();
      init_detectVideoAlphaMode();
      init_TextureSource();
      _VideoSource = class _VideoSource2 extends TextureSource {
        constructor(options) {
          super(options);
          this.isReady = false;
          this.uploadMethodId = "video";
          options = {
            ..._VideoSource2.defaultOptions,
            ...options
          };
          this._autoUpdate = true;
          this._isConnectedToTicker = false;
          this._updateFPS = options.updateFPS || 0;
          this._msToNextUpdate = 0;
          this.autoPlay = options.autoPlay !== false;
          this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
          this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
          this._videoFrameRequestCallbackHandle = null;
          this._load = null;
          this._resolve = null;
          this._reject = null;
          this._onCanPlay = this._onCanPlay.bind(this);
          this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
          this._onError = this._onError.bind(this);
          this._onPlayStart = this._onPlayStart.bind(this);
          this._onPlayStop = this._onPlayStop.bind(this);
          this._onSeeked = this._onSeeked.bind(this);
          if (options.autoLoad !== false) {
            void this.load();
          }
        }
        /** Update the video frame if the source is not destroyed and meets certain conditions. */
        updateFrame() {
          if (this.destroyed) {
            return;
          }
          if (this._updateFPS) {
            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          }
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
          if (this.isValid) {
            this.update();
          }
        }
        /** Callback to update the video frame and potentially request the next frame update. */
        _videoFrameRequestCallback() {
          this.updateFrame();
          if (this.destroyed) {
            this._videoFrameRequestCallbackHandle = null;
          } else {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            );
          }
        }
        /**
         * Checks if the resource has valid dimensions.
         * @returns {boolean} True if width and height are set, otherwise false.
         */
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        /**
         * Start preloading the video resource.
         * @returns {Promise<this>} Handle the validate event
         */
        async load() {
          if (this._load) {
            return this._load;
          }
          const source7 = this.resource;
          const options = this.options;
          if ((source7.readyState === source7.HAVE_ENOUGH_DATA || source7.readyState === source7.HAVE_FUTURE_DATA) && source7.width && source7.height) {
            source7.complete = true;
          }
          source7.addEventListener("play", this._onPlayStart);
          source7.addEventListener("pause", this._onPlayStop);
          source7.addEventListener("seeked", this._onSeeked);
          if (!this._isSourceReady()) {
            if (!options.preload) {
              source7.addEventListener("canplay", this._onCanPlay);
            }
            source7.addEventListener("canplaythrough", this._onCanPlayThrough);
            source7.addEventListener("error", this._onError, true);
          } else {
            this._mediaReady();
          }
          this.alphaMode = await detectVideoAlphaMode();
          this._load = new Promise((resolve, reject) => {
            if (this.isValid) {
              resolve(this);
            } else {
              this._resolve = resolve;
              this._reject = reject;
              if (options.preloadTimeoutMs !== void 0) {
                this._preloadTimeout = setTimeout(() => {
                  this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
                });
              }
              source7.load();
            }
          });
          return this._load;
        }
        /**
         * Handle video error events.
         * @param event - The error event
         */
        _onError(event) {
          this.resource.removeEventListener("error", this._onError, true);
          this.emit("error", event);
          if (this._reject) {
            this._reject(event);
            this._reject = null;
            this._resolve = null;
          }
        }
        /**
         * Checks if the underlying source is playing.
         * @returns True if playing.
         */
        _isSourcePlaying() {
          const source7 = this.resource;
          return !source7.paused && !source7.ended;
        }
        /**
         * Checks if the underlying source is ready for playing.
         * @returns True if ready.
         */
        _isSourceReady() {
          const source7 = this.resource;
          return source7.readyState > 2;
        }
        /** Runs the update loop when the video is ready to play. */
        _onPlayStart() {
          if (!this.isValid) {
            this._mediaReady();
          }
          this._configureAutoUpdate();
        }
        /** Stops the update loop when a pause event is triggered. */
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        /** Handles behavior when the video completes seeking to the current playback position. */
        _onSeeked() {
          if (this._autoUpdate && !this._isSourcePlaying()) {
            this._msToNextUpdate = 0;
            this.updateFrame();
            this._msToNextUpdate = 0;
          }
        }
        _onCanPlay() {
          const source7 = this.resource;
          source7.removeEventListener("canplay", this._onCanPlay);
          this._mediaReady();
        }
        _onCanPlayThrough() {
          const source7 = this.resource;
          source7.removeEventListener("canplaythrough", this._onCanPlay);
          if (this._preloadTimeout) {
            clearTimeout(this._preloadTimeout);
            this._preloadTimeout = void 0;
          }
          this._mediaReady();
        }
        /** Fired when the video is loaded and ready to play. */
        _mediaReady() {
          const source7 = this.resource;
          if (this.isValid) {
            this.isReady = true;
            this.resize(source7.videoWidth, source7.videoHeight);
          }
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
          if (this._resolve) {
            this._resolve(this);
            this._resolve = null;
            this._reject = null;
          }
          if (this._isSourcePlaying()) {
            this._onPlayStart();
          } else if (this.autoPlay) {
            void this.resource.play();
          }
        }
        /** Cleans up resources and event listeners associated with this texture. */
        destroy() {
          this._configureAutoUpdate();
          const source7 = this.resource;
          if (source7) {
            source7.removeEventListener("play", this._onPlayStart);
            source7.removeEventListener("pause", this._onPlayStop);
            source7.removeEventListener("seeked", this._onSeeked);
            source7.removeEventListener("canplay", this._onCanPlay);
            source7.removeEventListener("canplaythrough", this._onCanPlayThrough);
            source7.removeEventListener("error", this._onError, true);
            source7.pause();
            source7.src = "";
            source7.load();
          }
          super.destroy();
        }
        /** Should the base texture automatically update itself, set to true by default. */
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            this._configureAutoUpdate();
          }
        }
        /**
         * How many times a second to update the texture from the video.
         * Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         */
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
            this._configureAutoUpdate();
          }
        }
        /**
         * Configures the updating mechanism based on the current state and settings.
         *
         * This method decides between using the browser's native video frame callback or a custom ticker
         * for updating the video frame. It ensures optimal performance and responsiveness
         * based on the video's state, playback status, and the desired frames-per-second setting.
         *
         * - If `_autoUpdate` is enabled and the video source is playing:
         *   - It will prefer the native video frame callback if available and no specific FPS is set.
         *   - Otherwise, it will use a custom ticker for manual updates.
         * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
         */
        _configureAutoUpdate() {
          if (this._autoUpdate && this._isSourcePlaying()) {
            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
              if (this._isConnectedToTicker) {
                Ticker.shared.remove(this.updateFrame, this);
                this._isConnectedToTicker = false;
                this._msToNextUpdate = 0;
              }
              if (this._videoFrameRequestCallbackHandle === null) {
                this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                );
              }
            } else {
              if (this._videoFrameRequestCallbackHandle !== null) {
                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
                this._videoFrameRequestCallbackHandle = null;
              }
              if (!this._isConnectedToTicker) {
                Ticker.shared.add(this.updateFrame, this);
                this._isConnectedToTicker = true;
                this._msToNextUpdate = 0;
              }
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
          }
        }
        static test(resource) {
          return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
        }
      };
      _VideoSource.extension = ExtensionType.TextureSource;
      _VideoSource.defaultOptions = {
        ...TextureSource.defaultOptions,
        /** If true, the video will start loading immediately. */
        autoLoad: true,
        /** If true, the video will start playing as soon as it is loaded. */
        autoPlay: true,
        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
        updateFPS: 0,
        /** If true, the video will be loaded with the `crossorigin` attribute. */
        crossorigin: true,
        /** If true, the video will loop when it ends. */
        loop: false,
        /** If true, the video will be muted. */
        muted: true,
        /** If true, the video will play inline. */
        playsinline: true,
        /** If true, the video will be preloaded. */
        preload: false
      };
      _VideoSource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      VideoSource = _VideoSource;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/cache/Cache.mjs
  var CacheClass, Cache;
  var init_Cache = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
      init_warn();
      init_convertToList();
      CacheClass = class {
        constructor() {
          this._parsers = [];
          this._cache = /* @__PURE__ */ new Map();
          this._cacheMap = /* @__PURE__ */ new Map();
        }
        /** Clear all entries. */
        reset() {
          this._cacheMap.clear();
          this._cache.clear();
        }
        /**
         * Check if the key exists
         * @param key - The key to check
         */
        has(key) {
          return this._cache.has(key);
        }
        /**
         * Fetch entry by key
         * @param key - The key of the entry to get
         */
        get(key) {
          const result = this._cache.get(key);
          if (!result) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
          }
          return result;
        }
        /**
         * Set a value by key or keys name
         * @param key - The key or keys to set
         * @param value - The value to store in the cache or from which cacheable assets will be derived.
         */
        set(key, value) {
          const keys = convertToList(key);
          let cacheableAssets;
          for (let i3 = 0; i3 < this.parsers.length; i3++) {
            const parser = this.parsers[i3];
            if (parser.test(value)) {
              cacheableAssets = parser.getCacheableAssets(keys, value);
              break;
            }
          }
          const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
          if (!cacheableAssets) {
            keys.forEach((key2) => {
              cacheableMap.set(key2, value);
            });
          }
          const cacheKeys = [...cacheableMap.keys()];
          const cachedAssets = {
            cacheKeys,
            keys
          };
          keys.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          });
          cacheKeys.forEach((key2) => {
            const val = cacheableAssets ? cacheableAssets[key2] : value;
            if (this._cache.has(key2) && this._cache.get(key2) !== val) {
              warn("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableMap.get(key2));
          });
        }
        /**
         * Remove entry by key
         *
         * This function will also remove any associated alias from the cache also.
         * @param key - The key of the entry to remove
         */
        remove(key) {
          if (!this._cacheMap.has(key)) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          const cacheKeys = cacheMap2.cacheKeys;
          cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          });
          cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        /** All loader parsers registered */
        get parsers() {
          return this._parsers;
        }
      };
      Cache = new CacheClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
  function autoDetectSource(options = {}) {
    return textureSourceFrom(options);
  }
  function textureSourceFrom(options = {}) {
    const hasResource = options && options.resource;
    const res = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    for (let i3 = 0; i3 < sources.length; i3++) {
      const Source = sources[i3];
      if (Source.test(res)) {
        return new Source(opts);
      }
    }
    throw new Error(`Could not find a source type for resource: ${opts.resource}`);
  }
  function resourceToTexture(options = {}, skipCache = false) {
    const hasResource = options && options.resource;
    const resource = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    if (!skipCache && Cache.has(resource)) {
      return Cache.get(resource);
    }
    const texture = new Texture({ source: textureSourceFrom(opts) });
    texture.on("destroy", () => {
      if (Cache.has(resource)) {
        Cache.remove(resource);
      }
    });
    if (!skipCache) {
      Cache.set(resource, texture);
    }
    return texture;
  }
  function textureFrom(id, skipCache = false) {
    if (typeof id === "string") {
      return Cache.get(id);
    } else if (id instanceof TextureSource) {
      return new Texture({ source: id });
    }
    return resourceToTexture(id, skipCache);
  }
  var sources;
  var init_textureFrom = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
      init_Cache();
      init_Extensions();
      init_TextureSource();
      init_Texture();
      sources = [];
      extensions.handleByList(ExtensionType.TextureSource, sources);
      Texture.from = textureFrom;
      TextureSource.from = textureSourceFrom;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/init.mjs
  var init_init5 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/init.mjs"() {
      init_Extensions();
      init_AlphaMask();
      init_ColorMask();
      init_StencilMask();
      init_BufferImageSource();
      init_CanvasSource();
      init_ImageSource();
      init_VideoSource();
      init_textureFrom();
      extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  var BindGroup;
  var init_BindGroup = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
      "use strict";
      BindGroup = class {
        /**
         * Create a new instance eof the Bind Group.
         * @param resources - The resources that are bound together for use by a shader.
         */
        constructor(resources) {
          this.resources = /* @__PURE__ */ Object.create(null);
          this._dirty = true;
          let index = 0;
          for (const i3 in resources) {
            const resource = resources[i3];
            this.setResource(resource, index++);
          }
          this._updateKey();
        }
        /**
         * Updates the key if its flagged as dirty. This is used internally to
         * match this bind group to a WebGPU BindGroup.
         * @internal
         * @ignore
         */
        _updateKey() {
          if (!this._dirty)
            return;
          this._dirty = false;
          const keyParts = [];
          let index = 0;
          for (const i3 in this.resources) {
            keyParts[index++] = this.resources[i3]._resourceId;
          }
          this._key = keyParts.join("|");
        }
        /**
         * Set a resource at a given index. this function will
         * ensure that listeners will be removed from the current resource
         * and added to the new resource.
         * @param resource - The resource to set.
         * @param index - The index to set the resource at.
         */
        setResource(resource, index) {
          const currentResource = this.resources[index];
          if (resource === currentResource)
            return;
          if (currentResource) {
            resource.off?.("change", this.onResourceChange, this);
          }
          resource.on?.("change", this.onResourceChange, this);
          this.resources[index] = resource;
          this._dirty = true;
        }
        /**
         * Returns the resource at the current specified index.
         * @param index - The index of the resource to get.
         * @returns - The resource at the specified index.
         */
        getResource(index) {
          return this.resources[index];
        }
        /**
         * Used internally to 'touch' each resource, to ensure that the GC
         * knows that all resources in this bind group are still being used.
         * @param tick - The current tick.
         * @internal
         * @ignore
         */
        _touch(tick) {
          const resources = this.resources;
          for (const i3 in resources) {
            resources[i3]._touched = tick;
          }
        }
        /** Destroys this bind group and removes all listeners. */
        destroy() {
          const resources = this.resources;
          for (const i3 in resources) {
            const resource = resources[i3];
            resource.off?.("change", this.onResourceChange, this);
          }
          this.resources = null;
        }
        onResourceChange(resource) {
          this._dirty = true;
          if (resource.destroyed) {
            const resources = this.resources;
            for (const i3 in resources) {
              if (resources[i3] === resource) {
                resources[i3] = null;
              }
            }
          } else {
            this._updateKey();
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  function getTestContext() {
    if (!context || context?.isContextLost()) {
      const canvas = DOMAdapter.get().createCanvas();
      context = canvas.getContext("webgl", {});
    }
    return context;
  }
  var context;
  var init_getTestContext = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i3 = 0; i3 < maxIfs; ++i3) {
      if (i3 > 0) {
        src += "\nelse ";
      }
      if (i3 < maxIfs - 1) {
        src += `if(test == ${i3}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
      while (true) {
        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
    } finally {
      gl.deleteShader(shader);
    }
    return maxIfs;
  }
  var fragTemplate;
  var init_checkMaxIfStatementsInShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
      "use strict";
      fragTemplate = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
      ].join("\n");
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
  function getMaxTexturesPerBatch() {
    if (maxTexturesPerBatchCache)
      return maxTexturesPerBatchCache;
    const gl = getTestContext();
    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
      maxTexturesPerBatchCache,
      gl
    );
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return maxTexturesPerBatchCache;
  }
  var maxTexturesPerBatchCache;
  var init_maxRecommendedTextures = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
      init_getTestContext();
      init_checkMaxIfStatementsInShader();
      maxTexturesPerBatchCache = null;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  function getTextureBatchBindGroup(textures, size) {
    let uid3 = 2166136261;
    for (let i3 = 0; i3 < size; i3++) {
      uid3 ^= textures[i3].uid;
      uid3 = Math.imul(uid3, 16777619);
      uid3 >>>= 0;
    }
    return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, size, uid3);
  }
  function generateTextureBatchBindGroup(textures, size, key) {
    const bindGroupResources = {};
    let bindIndex = 0;
    if (!maxTextures)
      maxTextures = getMaxTexturesPerBatch();
    for (let i3 = 0; i3 < maxTextures; i3++) {
      const texture = i3 < size ? textures[i3] : Texture.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }
  var cachedGroups, maxTextures;
  var init_getTextureBatchBindGroup = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
      init_BindGroup();
      init_Texture();
      init_maxRecommendedTextures();
      cachedGroups = {};
      maxTextures = 0;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
  var ViewableBuffer;
  var init_ViewableBuffer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
      "use strict";
      ViewableBuffer = class {
        constructor(sizeOrBuffer) {
          if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
          } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
          } else {
            this.rawBinaryData = sizeOrBuffer;
          }
          this.uint32View = new Uint32Array(this.rawBinaryData);
          this.float32View = new Float32Array(this.rawBinaryData);
          this.size = this.rawBinaryData.byteLength;
        }
        /** View on the raw binary data as a `Int8Array`. */
        get int8View() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        }
        /** View on the raw binary data as a `Uint8Array`. */
        get uint8View() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        }
        /**  View on the raw binary data as a `Int16Array`. */
        get int16View() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        }
        /** View on the raw binary data as a `Int32Array`. */
        get int32View() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        }
        /** View on the raw binary data as a `Float64Array`. */
        get float64View() {
          if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
          }
          return this._float64Array;
        }
        /** View on the raw binary data as a `BigUint64Array`. */
        get bigUint64View() {
          if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
          }
          return this._bigUint64Array;
        }
        /**
         * Returns the view of the given type.
         * @param type - One of `int8`, `uint8`, `int16`,
         *    `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - typed array of given type
         */
        view(type) {
          return this[`${type}View`];
        }
        /** Destroys all buffer references. Do not use after calling this. */
        destroy() {
          this.rawBinaryData = null;
          this._int8View = null;
          this._uint8View = null;
          this._int16View = null;
          this.uint16View = null;
          this._int32View = null;
          this.uint32View = null;
          this.float32View = null;
        }
        /**
         * Returns the size of the given type in bytes.
         * @param type - One of `int8`, `uint8`, `int16`,
         *   `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - size of the type in bytes
         */
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }
  var init_fastCopy = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
  var BLEND_TO_NPM, STENCIL_MODES;
  var init_const3 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
      "use strict";
      BLEND_TO_NPM = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
      };
      STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
        STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
        STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
        STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
        return STENCIL_MODES2;
      })(STENCIL_MODES || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }
  var init_getAdjustedBlendModeBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
      init_const3();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
  var BatchTextureArray;
  var init_BatchTextureArray = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
      "use strict";
      BatchTextureArray = class {
        constructor() {
          this.ids = /* @__PURE__ */ Object.create(null);
          this.textures = [];
          this.count = 0;
        }
        /** Clear the textures and their locations. */
        clear() {
          for (let i3 = 0; i3 < this.count; i3++) {
            const t2 = this.textures[i3];
            this.textures[i3] = null;
            this.ids[t2.uid] = null;
          }
          this.count = 0;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
  function getBatchFromPool() {
    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
  }
  function returnBatchToPool(batch) {
    batchPool[batchPoolIndex++] = batch;
  }
  var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
  var init_Batcher = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
      init_uid();
      init_ViewableBuffer();
      init_fastCopy();
      init_getAdjustedBlendModeBlend();
      init_maxRecommendedTextures();
      init_BatchTextureArray();
      Batch = class {
        constructor() {
          this.renderPipeId = "batch";
          this.action = "startBatch";
          this.start = 0;
          this.size = 0;
          this.textures = new BatchTextureArray();
          this.blendMode = "normal";
          this.canBundle = true;
        }
        destroy() {
          this.textures = null;
          this.gpuBindGroup = null;
          this.bindGroup = null;
          this.batcher = null;
        }
      };
      batchPool = [];
      batchPoolIndex = 0;
      BATCH_TICK = 0;
      _Batcher = class _Batcher2 {
        constructor(options = {}) {
          this.uid = uid("batcher");
          this.dirty = true;
          this.batchIndex = 0;
          this.batches = [];
          this._elements = [];
          _Batcher2.defaultOptions.maxTextures = _Batcher2.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();
          options = { ..._Batcher2.defaultOptions, ...options };
          const { maxTextures: maxTextures2, attributesInitialSize, indicesInitialSize } = options;
          this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
          this.indexBuffer = new Uint16Array(indicesInitialSize);
          this.maxTextures = maxTextures2;
        }
        begin() {
          this.elementSize = 0;
          this.elementStart = 0;
          this.indexSize = 0;
          this.attributeSize = 0;
          for (let i3 = 0; i3 < this.batchIndex; i3++) {
            returnBatchToPool(this.batches[i3]);
          }
          this.batchIndex = 0;
          this._batchIndexStart = 0;
          this._batchIndexSize = 0;
          this.dirty = true;
        }
        add(batchableObject) {
          this._elements[this.elementSize++] = batchableObject;
          batchableObject._indexStart = this.indexSize;
          batchableObject._attributeStart = this.attributeSize;
          batchableObject._batcher = this;
          this.indexSize += batchableObject.indexSize;
          this.attributeSize += batchableObject.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(batchableObject, texture) {
          const textureId = batchableObject._batch.textures.ids[texture._source.uid];
          if (!textureId && textureId !== 0)
            return false;
          batchableObject._textureId = textureId;
          batchableObject.texture = texture;
          return true;
        }
        updateElement(batchableObject) {
          this.dirty = true;
          const attributeBuffer = this.attributeBuffer;
          if (batchableObject.packAsQuad) {
            this.packQuadAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          } else {
            this.packAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          }
        }
        /**
         * breaks the batcher. This happens when a batch gets too big,
         * or we need to switch to a different type of rendering (a filter for example)
         * @param instructionSet
         */
        break(instructionSet) {
          const elements = this._elements;
          if (!elements[this.elementStart])
            return;
          let batch = getBatchFromPool();
          let textureBatch = batch.textures;
          textureBatch.clear();
          const firstElement = elements[this.elementStart];
          let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
          if (this.attributeSize * 4 > this.attributeBuffer.size) {
            this._resizeAttributeBuffer(this.attributeSize * 4);
          }
          if (this.indexSize > this.indexBuffer.length) {
            this._resizeIndexBuffer(this.indexSize);
          }
          const f32 = this.attributeBuffer.float32View;
          const u32 = this.attributeBuffer.uint32View;
          const indexBuffer = this.indexBuffer;
          let size = this._batchIndexSize;
          let start = this._batchIndexStart;
          let action = "startBatch";
          const maxTextures2 = this.maxTextures;
          for (let i3 = this.elementStart; i3 < this.elementSize; ++i3) {
            const element = elements[i3];
            elements[i3] = null;
            const texture = element.texture;
            const source7 = texture._source;
            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source7);
            const breakRequired = blendMode !== adjustedBlendMode;
            if (source7._batchTick === BATCH_TICK && !breakRequired) {
              element._textureId = source7._textureBindLocation;
              size += element.indexSize;
              if (element.packAsQuad) {
                this.packQuadAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packQuadIndex(
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              } else {
                this.packAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packIndex(
                  element,
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              }
              element._batch = batch;
              continue;
            }
            source7._batchTick = BATCH_TICK;
            if (textureBatch.count >= maxTextures2 || breakRequired) {
              this._finishBatch(
                batch,
                start,
                size - start,
                textureBatch,
                blendMode,
                instructionSet,
                action
              );
              action = "renderBatch";
              start = size;
              blendMode = adjustedBlendMode;
              batch = getBatchFromPool();
              textureBatch = batch.textures;
              textureBatch.clear();
              ++BATCH_TICK;
            }
            element._textureId = source7._textureBindLocation = textureBatch.count;
            textureBatch.ids[source7.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source7;
            element._batch = batch;
            size += element.indexSize;
            if (element.packAsQuad) {
              this.packQuadAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packQuadIndex(
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            } else {
              this.packAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packIndex(
                element,
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            }
          }
          if (textureBatch.count > 0) {
            this._finishBatch(
              batch,
              start,
              size - start,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            start = size;
            ++BATCH_TICK;
          }
          this.elementStart = this.elementSize;
          this._batchIndexStart = start;
          this._batchIndexSize = size;
        }
        _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
          batch.gpuBindGroup = null;
          batch.bindGroup = null;
          batch.action = action;
          batch.batcher = this;
          batch.textures = textureBatch;
          batch.blendMode = blendMode;
          batch.start = indexStart;
          batch.size = indexSize;
          ++BATCH_TICK;
          this.batches[this.batchIndex++] = batch;
          instructionSet.add(batch);
        }
        finish(instructionSet) {
          this.break(instructionSet);
        }
        /**
         * Resizes the attribute buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureAttributeBuffer(size) {
          if (size * 4 <= this.attributeBuffer.size)
            return;
          this._resizeAttributeBuffer(size * 4);
        }
        /**
         * Resizes the index buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureIndexBuffer(size) {
          if (size <= this.indexBuffer.length)
            return;
          this._resizeIndexBuffer(size);
        }
        _resizeAttributeBuffer(size) {
          const newSize = Math.max(size, this.attributeBuffer.size * 2);
          const newArrayBuffer = new ViewableBuffer(newSize);
          fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
          this.attributeBuffer = newArrayBuffer;
        }
        _resizeIndexBuffer(size) {
          const indexBuffer = this.indexBuffer;
          let newSize = Math.max(size, indexBuffer.length * 1.5);
          newSize += newSize % 2;
          const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
          if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
            for (let i3 = 0; i3 < indexBuffer.length; i3++) {
              newIndexBuffer[i3] = indexBuffer[i3];
            }
          } else {
            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
          }
          this.indexBuffer = newIndexBuffer;
        }
        packQuadIndex(indexBuffer, index, indicesOffset) {
          indexBuffer[index] = indicesOffset + 0;
          indexBuffer[index + 1] = indicesOffset + 1;
          indexBuffer[index + 2] = indicesOffset + 2;
          indexBuffer[index + 3] = indicesOffset + 0;
          indexBuffer[index + 4] = indicesOffset + 2;
          indexBuffer[index + 5] = indicesOffset + 3;
        }
        packIndex(element, indexBuffer, index, indicesOffset) {
          const indices = element.indices;
          const size = element.indexSize;
          const indexOffset = element.indexOffset;
          const attributeOffset = element.attributeOffset;
          for (let i3 = 0; i3 < size; i3++) {
            indexBuffer[index++] = indicesOffset + indices[i3 + indexOffset] - attributeOffset;
          }
        }
        destroy() {
          for (let i3 = 0; i3 < this.batches.length; i3++) {
            returnBatchToPool(this.batches[i3]);
          }
          this.batches = null;
          for (let i3 = 0; i3 < this._elements.length; i3++) {
            this._elements[i3]._batch = null;
          }
          this._elements = null;
          this.indexBuffer = null;
          this.attributeBuffer.destroy();
          this.attributeBuffer = null;
        }
      };
      _Batcher.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
      };
      Batcher = _Batcher;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
  var BufferUsage;
  var init_const4 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
      "use strict";
      BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
        BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
        BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
        BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
        BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
        BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
        BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
        BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
        BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
        BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
        BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
        BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
        return BufferUsage2;
      })(BufferUsage || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer2;
  var init_Buffer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
      init_eventemitter3();
      init_uid();
      init_const4();
      Buffer2 = class extends eventemitter3_default {
        /**
         * Creates a new Buffer with the given options
         * @param options - the options for the buffer
         */
        constructor(options) {
          let { data, size } = options;
          const { usage, label, shrinkToFit } = options;
          super();
          this.uid = uid("buffer");
          this._resourceType = "buffer";
          this._resourceId = uid("resource");
          this._touched = 0;
          this._updateID = 1;
          this.shrinkToFit = true;
          this.destroyed = false;
          if (data instanceof Array) {
            data = new Float32Array(data);
          }
          this._data = data;
          size = size ?? data?.byteLength;
          const mappedAtCreation = !!data;
          this.descriptor = {
            size,
            usage,
            mappedAtCreation,
            label
          };
          this.shrinkToFit = shrinkToFit ?? true;
        }
        /** the data in the buffer */
        get data() {
          return this._data;
        }
        set data(value) {
          this.setDataWithSize(value, value.length, true);
        }
        /** whether the buffer is static or not */
        get static() {
          return !!(this.descriptor.usage & BufferUsage.STATIC);
        }
        set static(value) {
          if (value) {
            this.descriptor.usage |= BufferUsage.STATIC;
          } else {
            this.descriptor.usage &= ~BufferUsage.STATIC;
          }
        }
        /**
         * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
         * If you only want to update a subset of the buffer, you can pass in the size of the data.
         * @param value - the data to set
         * @param size - the size of the data in bytes
         * @param syncGPU - should the buffer be updated on the GPU immediately?
         */
        setDataWithSize(value, size, syncGPU) {
          this._updateID++;
          this._updateSize = size * value.BYTES_PER_ELEMENT;
          if (this._data === value) {
            if (syncGPU)
              this.emit("update", this);
            return;
          }
          const oldData = this._data;
          this._data = value;
          if (oldData.length !== value.length) {
            if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {
              if (syncGPU)
                this.emit("update", this);
            } else {
              this.descriptor.size = value.byteLength;
              this._resourceId = uid("resource");
              this.emit("change", this);
            }
            return;
          }
          if (syncGPU)
            this.emit("update", this);
        }
        /**
         * updates the buffer on the GPU to reflect the data in the buffer.
         * By default it will update the entire buffer. If you only want to update a subset of the buffer,
         * you can pass in the size of the buffer to update.
         * @param sizeInBytes - the new size of the buffer in bytes
         */
        update(sizeInBytes) {
          this._updateSize = sizeInBytes ?? this._updateSize;
          this._updateID++;
          this.emit("update", this);
        }
        /** Destroys the buffer */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this._data = null;
          this.descriptor = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index) {
    if (!(buffer instanceof Buffer2)) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer2({
        data: buffer,
        label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }
  var init_ensureIsBuffer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
      init_Buffer();
      init_const4();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer.data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i3 = offset; i3 < data.length; i3 += stride) {
      const x2 = data[i3];
      const y2 = data[i3 + 1];
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }
  var init_getGeometryBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
  function ensureIsAttribute(attribute) {
    if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  var Geometry;
  var init_Geometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
      init_eventemitter3();
      init_Bounds();
      init_uid();
      init_Buffer();
      init_ensureIsBuffer();
      init_getGeometryBounds();
      Geometry = class extends eventemitter3_default {
        /**
         * Create a new instance of a geometry
         * @param options - The options for the geometry.
         */
        constructor(options = {}) {
          super();
          this.uid = uid("geometry");
          this._layoutKey = 0;
          this.instanceCount = 1;
          this._bounds = new Bounds();
          this._boundsDirty = true;
          const { attributes, indexBuffer, topology } = options;
          this.buffers = [];
          this.attributes = {};
          if (attributes) {
            for (const i3 in attributes) {
              this.addAttribute(i3, attributes[i3]);
            }
          }
          this.instanceCount = options.instanceCount || 1;
          if (indexBuffer) {
            this.addIndex(indexBuffer);
          }
          this.topology = topology || "triangle-list";
        }
        onBufferUpdate() {
          this._boundsDirty = true;
          this.emit("update", this);
        }
        /**
         * Returns the requested attribute.
         * @param id - The name of the attribute required
         * @returns - The attribute requested.
         */
        getAttribute(id) {
          return this.attributes[id];
        }
        /**
         * Returns the index buffer
         * @returns - The index buffer.
         */
        getIndex() {
          return this.indexBuffer;
        }
        /**
         * Returns the requested buffer.
         * @param id - The name of the buffer required.
         * @returns - The buffer requested.
         */
        getBuffer(id) {
          return this.getAttribute(id).buffer;
        }
        /**
         * Used to figure out how many vertices there are in this geometry
         * @returns the number of vertices in the geometry
         */
        getSize() {
          for (const i3 in this.attributes) {
            const attribute = this.attributes[i3];
            const buffer = attribute.buffer;
            return buffer.data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        /**
         * Adds an attribute to the geometry.
         * @param name - The name of the attribute to add.
         * @param attributeOption - The attribute option to add.
         */
        addAttribute(name, attributeOption) {
          const attribute = ensureIsAttribute(attributeOption);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
            attribute.buffer.on("change", this.onBufferUpdate, this);
          }
          this.attributes[name] = attribute;
        }
        /**
         * Adds an index buffer to the geometry.
         * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
         */
        addIndex(indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        /** Returns the bounds of the geometry. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this._boundsDirty = false;
          return getGeometryBounds(this, "aPosition", this._bounds);
        }
        /**
         * destroys the geometry.
         * @param destroyBuffers - destroy the buffers associated with this geometry
         */
        destroy(destroyBuffers = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          if (destroyBuffers) {
            this.buffers.forEach((buffer) => buffer.destroy());
          }
          this.attributes = null;
          this.buffers = null;
          this.indexBuffer = null;
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
  var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
  var init_BatchGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      placeHolderBufferData = new Float32Array(1);
      placeHolderIndexData = new Uint32Array(1);
      BatchGeometry = class extends Geometry {
        constructor() {
          const vertexSize = 6;
          const attributeBuffer = new Buffer2({
            data: placeHolderBufferData,
            label: "attribute-batch-buffer",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
            shrinkToFit: false
          });
          const indexBuffer = new Buffer2({
            data: placeHolderIndexData,
            label: "index-batch-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
            // | BufferUsage.STATIC,
            shrinkToFit: false
          });
          const stride = vertexSize * 4;
          super({
            attributes: {
              aPosition: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 0
              },
              aUV: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 2 * 4
              },
              aColor: {
                buffer: attributeBuffer,
                format: "unorm8x4",
                stride,
                offset: 4 * 4
              },
              aTextureIdAndRound: {
                buffer: attributeBuffer,
                format: "uint16x2",
                stride,
                offset: 5 * 4
              }
            },
            indexBuffer
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  function createIdFromString(value, groupId) {
    let id = idHash2[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash2[value] = id = idCounts[groupId]++;
    }
    return id;
  }
  var idCounts, idHash2;
  var init_createIdFromString = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
      "use strict";
      idCounts = /* @__PURE__ */ Object.create(null);
      idHash2 = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }
  var maxFragmentPrecision;
  var init_getMaxFragmentPrecision = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
      init_getTestContext();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
  function addProgramDefines(src, isES300, isFragment) {
    if (isES300)
      return src;
    if (isFragment) {
      src = src.replace("out vec4 finalColor;", "");
      return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
    }
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
  }
  var init_addProgramDefines = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var init_ensurePrecision = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
  function insertVersion(src, isES300) {
    if (!isES300)
      return src;
    return `#version 300 es
${src}`;
  }
  var init_insertVersion = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
  function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name]) {
      nameCache[name]++;
      name += `-${nameCache[name]}`;
    } else {
      nameCache[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    return `${shaderName}
${src}`;
  }
  var fragmentNameCache, VertexNameCache;
  var init_setProgramName = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
      "use strict";
      fragmentNameCache = {};
      VertexNameCache = {};
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
  function stripVersion(src, isES300) {
    if (!isES300)
      return src;
    return src.replace("#version 300 es", "");
  }
  var init_stripVersion = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes, programCache, _GlProgram, GlProgram;
  var init_GlProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
      init_createIdFromString();
      init_getMaxFragmentPrecision();
      init_addProgramDefines();
      init_ensurePrecision();
      init_insertVersion();
      init_setProgramName();
      init_stripVersion();
      processes = {
        // strips any version headers..
        stripVersion,
        // adds precision string if not already present
        ensurePrecision,
        // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
        addProgramDefines,
        // add the program name to the shader
        setProgramName,
        // add the version string to the shader header
        insertVersion
      };
      programCache = /* @__PURE__ */ Object.create(null);
      _GlProgram = class _GlProgram2 {
        /**
         * Creates a shiny new GlProgram. Used by WebGL renderer.
         * @param options - The options for the program.
         */
        constructor(options) {
          options = { ..._GlProgram2.defaultOptions, ...options };
          const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
          const preprocessorOptions = {
            stripVersion: isES300,
            ensurePrecision: {
              requestedFragmentPrecision: options.preferredFragmentPrecision,
              requestedVertexPrecision: options.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: getMaxFragmentPrecision()
            },
            setProgramName: {
              name: options.name
            },
            addProgramDefines: isES300,
            insertVersion: isES300
          };
          let fragment7 = options.fragment;
          let vertex5 = options.vertex;
          Object.keys(processes).forEach((processKey) => {
            const processOptions = preprocessorOptions[processKey];
            fragment7 = processes[processKey](fragment7, processOptions, true);
            vertex5 = processes[processKey](vertex5, processOptions, false);
          });
          this.fragment = fragment7;
          this.vertex = vertex5;
          this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        /** destroys the program */
        destroy() {
          this.fragment = null;
          this.vertex = null;
          this._attributeData = null;
          this._uniformData = null;
          this._uniformBlockData = null;
          this.transformFeedbackVaryings = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options) {
          const key = `${options.vertex}:${options.fragment}`;
          if (!programCache[key]) {
            programCache[key] = new _GlProgram2(options);
          }
          return programCache[key];
        }
      };
      _GlProgram.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
      };
      GlProgram = _GlProgram;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
  function getAttributeInfoFromFormat(format) {
    return attributeFormatData[format] ?? attributeFormatData.float32;
  }
  var attributeFormatData;
  var init_getAttributeInfoFromFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
      "use strict";
      attributeFormatData = {
        uint8x2: { size: 2, stride: 2, normalised: false },
        uint8x4: { size: 4, stride: 4, normalised: false },
        sint8x2: { size: 2, stride: 2, normalised: false },
        sint8x4: { size: 4, stride: 4, normalised: false },
        unorm8x2: { size: 2, stride: 2, normalised: true },
        unorm8x4: { size: 4, stride: 4, normalised: true },
        snorm8x2: { size: 2, stride: 2, normalised: true },
        snorm8x4: { size: 4, stride: 4, normalised: true },
        uint16x2: { size: 2, stride: 4, normalised: false },
        uint16x4: { size: 4, stride: 8, normalised: false },
        sint16x2: { size: 2, stride: 4, normalised: false },
        sint16x4: { size: 4, stride: 8, normalised: false },
        unorm16x2: { size: 2, stride: 4, normalised: true },
        unorm16x4: { size: 4, stride: 8, normalised: true },
        snorm16x2: { size: 2, stride: 4, normalised: true },
        snorm16x4: { size: 4, stride: 8, normalised: true },
        float16x2: { size: 2, stride: 4, normalised: false },
        float16x4: { size: 4, stride: 8, normalised: false },
        float32: { size: 1, stride: 4, normalised: false },
        float32x2: { size: 2, stride: 8, normalised: false },
        float32x3: { size: 3, stride: 12, normalised: false },
        float32x4: { size: 4, stride: 16, normalised: false },
        uint32: { size: 1, stride: 4, normalised: false },
        uint32x2: { size: 2, stride: 8, normalised: false },
        uint32x3: { size: 3, stride: 12, normalised: false },
        uint32x4: { size: 4, stride: 16, normalised: false },
        sint32: { size: 1, stride: 4, normalised: false },
        sint32x2: { size: 2, stride: 8, normalised: false },
        sint32x3: { size: 3, stride: 12, normalised: false },
        sint32x4: { size: 4, stride: 16, normalised: false }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
  function extractAttributesFromGpuProgram({ source: source7, entryPoint }) {
    const results = {};
    const mainVertStart = source7.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source7.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source7.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let match;
        while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
          results[match[2]] = {
            location: parseInt(match[1], 10),
            format,
            stride: getAttributeInfoFromFormat(format).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }
  var WGSL_TO_VERTEX_TYPES;
  var init_extractAttributesFromGpuProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      WGSL_TO_VERTEX_TYPES = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
  function extractStructAndGroups(wgsl2) {
    const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = wgsl2.match(linePattern)?.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = wgsl2.match(structPattern)?.map((struct) => {
      const name = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member) => {
        const [name2, type] = member.split(":");
        acc[name2.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return { name, members };
    }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
    return {
      groups,
      structs
    };
  }
  var init_extractStructAndGroups = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
  var ShaderStage;
  var init_const5 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
      "use strict";
      ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
        ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
        ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
        ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
        return ShaderStage2;
      })(ShaderStage || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i3 = 0; i3 < groups.length; i3++) {
      const group = groups[i3];
      if (!layout[group.group]) {
        layout[group.group] = [];
      }
      if (group.isUniform) {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group.type === "sampler") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group.type === "texture_2d") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }
  var init_generateGpuLayoutGroups = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
      init_const5();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i3 = 0; i3 < groups.length; i3++) {
      const group = groups[i3];
      if (!layout[group.group]) {
        layout[group.group] = {};
      }
      layout[group.group][group.name] = group.binding;
    }
    return layout;
  }
  var init_generateLayoutHash = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
      const key = `${group.name}-${group.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return { structs, groups };
  }
  var init_removeStructAndGroupDuplicates = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var programCache2, GpuProgram;
  var init_GpuProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
      init_createIdFromString();
      init_extractAttributesFromGpuProgram();
      init_extractStructAndGroups();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      programCache2 = /* @__PURE__ */ Object.create(null);
      GpuProgram = class {
        /**
         * Create a new GpuProgram
         * @param options - The options for the gpu program
         */
        constructor(options) {
          this._layoutKey = 0;
          this._attributeLocationsKey = 0;
          const { fragment: fragment7, vertex: vertex5, layout, gpuLayout, name } = options;
          this.name = name;
          this.fragment = fragment7;
          this.vertex = vertex5;
          if (fragment7.source === vertex5.source) {
            const structsAndGroups = extractStructAndGroups(fragment7.source);
            this.structsAndGroups = structsAndGroups;
          } else {
            const vertexStructsAndGroups = extractStructAndGroups(vertex5.source);
            const fragmentStructsAndGroups = extractStructAndGroups(fragment7.source);
            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
          }
          this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
          this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
          this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
          this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
          this._generateProgramKey();
        }
        // TODO maker this pure
        _generateProgramKey() {
          const { vertex: vertex5, fragment: fragment7 } = this;
          const bigKey = vertex5.source + fragment7.source + vertex5.entryPoint + fragment7.entryPoint;
          this._layoutKey = createIdFromString(bigKey, "program");
        }
        get attributeData() {
          this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
          return this._attributeData;
        }
        /** destroys the program */
        destroy() {
          this.gpuLayout = null;
          this.layout = null;
          this.structsAndGroups = null;
          this.fragment = null;
          this.vertex = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options) {
          const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
          if (!programCache2[key]) {
            programCache2[key] = new GpuProgram(options);
          }
          return programCache2[key];
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i3 in srcParts) {
        const id = i3.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i3];
          if (i3 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name) {
            part.push(`//----${name}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn(`${i3} placement hook does not exist in shader`);
        }
      }
    }
  }
  var init_addBits = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
      init_warn();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }
  var findHooksRx;
  var init_compileHooks = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
      "use strict";
      findHooksRx = /\{\{(.*?)\}\}/g;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  function extractInputs(fragmentSource, out2) {
    let match;
    const regex = /@in\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment7) => {
      if (fragment7.header) {
        extractInputs(fragment7.header, results);
      }
    });
    const mainInput = results;
    if (sort) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i3) => `       @location(${i3}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }
  var init_compileInputs = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  function extractOutputs(fragmentSource, out2) {
    let match;
    const regex = /@out\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function extractVariableName(value) {
    const regex = /\b(\w+)\s*:/g;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = /@.*?\s+/g;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment7) => {
      if (fragment7.header) {
        extractOutputs(fragment7.header, results);
      }
    });
    let index = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }
  var init_compileOutputs = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i3 in fragmentParts) {
      const parts = fragmentParts[i3];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i3}}}`, `//-----${i3} START-----//
${parts.join("\n")}
//----${i3} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i3}}}`, "");
      }
    }
    return out2;
  }
  var init_injectBits = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const { vertex: vertex5, fragment: fragment7 } = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex5, fragment7, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex5, fragment7, bits) {
    const vertexParts = compileHooks(vertex5);
    const fragmentParts = compileHooks(fragment7);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex5, vertexParts),
      fragment: injectBits(fragment7, fragmentParts)
    };
  }
  var cacheMap, bitCacheMap, CACHE_UID;
  var init_compileHighShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_injectBits();
      cacheMap = /* @__PURE__ */ Object.create(null);
      bitCacheMap = /* @__PURE__ */ new Map();
      CACHE_UID = 0;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
  var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
  var init_defaultProgramTemplate = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
      "use strict";
      vertexGPUTemplate = /* wgsl */
      `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
      fragmentGPUTemplate = /* wgsl */
      `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
      vertexGlTemplate = /* glsl */
      `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
      fragmentGlTemplate = /* glsl */
      `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  var globalUniformsBit, globalUniformsUBOBitGl, globalUniformsBitGl;
  var init_globalUniformsBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
      "use strict";
      globalUniformsBit = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* wgsl */
            `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
          )
        }
      };
      globalUniformsUBOBitGl = {
        name: "global-uniforms-ubo-bit",
        vertex: {
          header: (
            /* glsl */
            `
          uniform globalUniforms {
            mat3 uProjectionMatrix;
            mat3 uWorldTransformMatrix;
            vec4 uWorldColorAlpha;
            vec2 uResolution;
          };
        `
          )
        }
      };
      globalUniformsBitGl = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* glsl */
            `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({ bits, name }) {
    const source7 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return GpuProgram.from({
      name,
      vertex: {
        source: source7.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source7.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({ bits, name }) {
    return new GlProgram({
      name,
      ...compileHighShaderGl({
        template: {
          vertex: vertexGlTemplate,
          fragment: fragmentGlTemplate
        },
        bits: [
          globalUniformsBitGl,
          ...bits
        ]
      })
    });
  }
  var init_compileHighShaderToProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_compileHighShader();
      init_defaultProgramTemplate();
      init_globalUniformsBit();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
  var colorBit, colorBitGl;
  var init_colorBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
      "use strict";
      colorBit = {
        name: "color-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            @in aColor: vec4<f32>;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
      colorBitGl = {
        name: "color-bit",
        vertex: {
          header: (
            /* glsl */
            `
            in vec4 aColor;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  function generateBindingSrc(maxTextures2) {
    const src = [];
    if (maxTextures2 === 1) {
      src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i3 = 0; i3 < maxTextures2; i3++) {
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i3 + 1}: texture_2d<f32>;`);
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i3 + 1}: sampler;`);
      }
    }
    return src.join("\n");
  }
  function generateSampleSrc(maxTextures2) {
    const src = [];
    if (maxTextures2 === 1) {
      src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src.push("switch vTextureId {");
      for (let i3 = 0; i3 < maxTextures2; i3++) {
        if (i3 === maxTextures2 - 1) {
          src.push(`  default:{`);
        } else {
          src.push(`  case ${i3}:{`);
        }
        src.push(`      outColor = textureSampleGrad(textureSource${i3 + 1}, textureSampler${i3 + 1}, vUV, uvDx, uvDy);`);
        src.push(`      break;}`);
      }
      src.push(`}`);
    }
    return src.join("\n");
  }
  function generateTextureBatchBit(maxTextures2) {
    if (!textureBatchBitGpuCache[maxTextures2]) {
      textureBatchBitGpuCache[maxTextures2] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures2)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures2)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures2];
  }
  function generateSampleGlSrc(maxTextures2) {
    const src = [];
    for (let i3 = 0; i3 < maxTextures2; i3++) {
      if (i3 > 0) {
        src.push("else");
      }
      if (i3 < maxTextures2 - 1) {
        src.push(`if(vTextureId < ${i3}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uTextures[${i3}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures2) {
    if (!textureBatchBitGlCache[maxTextures2]) {
      textureBatchBitGlCache[maxTextures2] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures2}];

            `,
          main: `

                ${generateSampleGlSrc(maxTextures2)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures2];
  }
  var textureBatchBitGpuCache, textureBatchBitGlCache;
  var init_generateTextureBatchBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
      "use strict";
      textureBatchBitGpuCache = {};
      textureBatchBitGlCache = {};
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  var roundPixelsBit, roundPixelsBitGl;
  var init_roundPixelsBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
      "use strict";
      roundPixelsBit = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
      roundPixelsBitGl = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* glsl */
            `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
  var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
  var init_types = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs"() {
      "use strict";
      UNIFORM_TYPES_VALUES = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>"
      ];
      UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
        acc[type] = true;
        return acc;
      }, {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
  function getDefaultUniformValue(type, size) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size);
      case "vec3<f32>":
        return new Float32Array(3 * size);
      case "vec4<f32>":
        return new Float32Array(4 * size);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_getDefaultUniformValue = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup, UniformGroup;
  var init_UniformGroup = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
      init_uid();
      init_createIdFromString();
      init_types();
      init_getDefaultUniformValue();
      _UniformGroup = class _UniformGroup2 {
        /**
         * Create a new Uniform group
         * @param uniformStructures - The structures of the uniform group
         * @param options - The optional parameters of this uniform group
         */
        constructor(uniformStructures, options) {
          this._touched = 0;
          this.uid = uid("uniform");
          this._resourceType = "uniformGroup";
          this._resourceId = uid("resource");
          this.isUniformGroup = true;
          this._dirtyId = 0;
          this.destroyed = false;
          options = { ..._UniformGroup2.defaultOptions, ...options };
          this.uniformStructures = uniformStructures;
          const uniforms = {};
          for (const i3 in uniformStructures) {
            const uniformData = uniformStructures[i3];
            uniformData.name = i3;
            uniformData.size = uniformData.size ?? 1;
            if (!UNIFORM_TYPES_MAP[uniformData.type]) {
              throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
            }
            uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
            uniforms[i3] = uniformData.value;
          }
          this.uniforms = uniforms;
          this._dirtyId = 1;
          this.ubo = options.ubo;
          this.isStatic = options.isStatic;
          this._signature = createIdFromString(Object.keys(uniforms).map(
            (i3) => `${i3}-${uniformStructures[i3].type}`
          ).join("-"), "uniform-group");
        }
        /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
        update() {
          this._dirtyId++;
        }
      };
      _UniformGroup.defaultOptions = {
        /** if true the UniformGroup is handled as an Uniform buffer object. */
        ubo: false,
        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
        isStatic: false
      };
      UniformGroup = _UniformGroup;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
  function getBatchSamplersUniformGroup(maxTextures2) {
    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2];
    if (batchSamplersUniformGroup)
      return batchSamplersUniformGroup;
    const sampleValues = new Int32Array(maxTextures2);
    for (let i3 = 0; i3 < maxTextures2; i3++) {
      sampleValues[i3] = i3;
    }
    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2] = new UniformGroup({
      uTextures: { value: sampleValues, type: `i32`, size: maxTextures2 }
    }, { isStatic: true });
    return batchSamplersUniformGroup;
  }
  var batchSamplersUniformGroupHash;
  var init_getBatchSamplersUniformGroup = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
      init_UniformGroup();
      batchSamplersUniformGroupHash = {};
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/types.mjs
  var RendererType;
  var init_types2 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
      "use strict";
      RendererType = /* @__PURE__ */ ((RendererType2) => {
        RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
        RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
        RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
        return RendererType2;
      })(RendererType || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader;
  var init_Shader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
      init_eventemitter3();
      init_GlProgram();
      init_BindGroup();
      init_GpuProgram();
      init_types2();
      init_UniformGroup();
      Shader = class extends eventemitter3_default {
        constructor(options) {
          super();
          this._uniformBindMap = /* @__PURE__ */ Object.create(null);
          this._ownedBindGroups = [];
          let {
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            groups,
            resources,
            compatibleRenderers,
            groupMap
          } = options;
          this.gpuProgram = gpuProgram3;
          this.glProgram = glProgram3;
          if (compatibleRenderers === void 0) {
            compatibleRenderers = 0;
            if (gpuProgram3)
              compatibleRenderers |= RendererType.WEBGPU;
            if (glProgram3)
              compatibleRenderers |= RendererType.WEBGL;
          }
          this.compatibleRenderers = compatibleRenderers;
          const nameHash = {};
          if (!resources && !groups) {
            resources = {};
          }
          if (resources && groups) {
            throw new Error("[Shader] Cannot have both resources and groups");
          } else if (!gpuProgram3 && groups && !groupMap) {
            throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
          } else if (!gpuProgram3 && groups && groupMap) {
            for (const i3 in groupMap) {
              for (const j2 in groupMap[i3]) {
                const uniformName = groupMap[i3][j2];
                nameHash[uniformName] = {
                  group: i3,
                  binding: j2,
                  name: uniformName
                };
              }
            }
          } else if (gpuProgram3 && groups && !groupMap) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          } else if (resources) {
            groups = {};
            groupMap = {};
            if (gpuProgram3) {
              const groupData = gpuProgram3.structsAndGroups.groups;
              groupData.forEach((data) => {
                groupMap[data.group] = groupMap[data.group] || {};
                groupMap[data.group][data.binding] = data.name;
                nameHash[data.name] = data;
              });
            }
            let bindTick = 0;
            for (const i3 in resources) {
              if (nameHash[i3])
                continue;
              if (!groups[99]) {
                groups[99] = new BindGroup();
                this._ownedBindGroups.push(groups[99]);
              }
              nameHash[i3] = { group: 99, binding: bindTick, name: i3 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i3;
              bindTick++;
            }
            for (const i3 in resources) {
              const name = i3;
              let value = resources[i3];
              if (!value.source && !value._resourceType) {
                value = new UniformGroup(value);
              }
              const data = nameHash[name];
              if (data) {
                if (!groups[data.group]) {
                  groups[data.group] = new BindGroup();
                  this._ownedBindGroups.push(groups[data.group]);
                }
                groups[data.group].setResource(value, data.binding);
              }
            }
          }
          this.groups = groups;
          this._uniformBindMap = groupMap;
          this.resources = this._buildResourceAccessor(groups, nameHash);
        }
        /**
         * Sometimes a resource group will be provided later (for example global uniforms)
         * In such cases, this method can be used to let the shader know about the group.
         * @param name - the name of the resource group
         * @param groupIndex - the index of the group (should match the webGPU shader group location)
         * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
         */
        addResource(name, groupIndex, bindIndex) {
          var _a, _b;
          (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
          (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
          if (!this.groups[groupIndex]) {
            this.groups[groupIndex] = new BindGroup();
            this._ownedBindGroups.push(this.groups[groupIndex]);
          }
        }
        _buildResourceAccessor(groups, nameHash) {
          const uniformsOut = {};
          for (const i3 in nameHash) {
            const data = nameHash[i3];
            Object.defineProperty(uniformsOut, data.name, {
              get() {
                return groups[data.group].getResource(data.binding);
              },
              set(value) {
                groups[data.group].setResource(value, data.binding);
              }
            });
          }
          return uniformsOut;
        }
        /**
         * Use to destroy the shader when its not longer needed.
         * It will destroy the resources and remove listeners.
         * @param destroyPrograms - if the programs should be destroyed as well.
         * Make sure its not being used by other shaders!
         */
        destroy(destroyPrograms = false) {
          this.emit("destroy", this);
          if (destroyPrograms) {
            this.gpuProgram?.destroy();
            this.glProgram?.destroy();
          }
          this.gpuProgram = null;
          this.glProgram = null;
          this.removeAllListeners();
          this._uniformBindMap = null;
          this._ownedBindGroups.forEach((bindGroup) => {
            bindGroup.destroy();
          });
          this._ownedBindGroups = null;
          this.resources = null;
          this.groups = null;
        }
        static from(options) {
          const { gpu, gl, ...rest } = options;
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new Shader({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            ...rest
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
  var DefaultShader;
  var init_DefaultShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs"() {
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      DefaultShader = class extends Shader {
        constructor(maxTextures2) {
          const glProgram3 = compileHighShaderGlProgram({
            name: "batch",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              roundPixelsBitGl
            ]
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "batch",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures2),
              roundPixelsBit
            ]
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
  var defaultShader, _DefaultBatcher, DefaultBatcher;
  var init_DefaultBatcher = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs"() {
      init_Extensions();
      init_Batcher();
      init_BatchGeometry();
      init_DefaultShader();
      defaultShader = null;
      _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
        constructor() {
          super(...arguments);
          this.geometry = new BatchGeometry();
          this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));
          this.name = _DefaultBatcher2.extension.name;
          this.vertexSize = 6;
        }
        /**
         * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
         * @param element - The DefaultBatchableMeshElement to pack.
         * @param float32View - The Float32Array view to pack into.
         * @param uint32View - The Uint32Array view to pack into.
         * @param index - The starting index in the views.
         * @param textureId - The texture ID to use.
         */
        packAttributes(element, float32View, uint32View, index, textureId) {
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const { positions, uvs } = element;
          const argb = element.color;
          const offset = element.attributeOffset;
          const end = offset + element.attributeSize;
          for (let i3 = offset; i3 < end; i3++) {
            const i22 = i3 * 2;
            const x2 = positions[i22];
            const y2 = positions[i22 + 1];
            float32View[index++] = a2 * x2 + c2 * y2 + tx;
            float32View[index++] = d2 * y2 + b2 * x2 + ty;
            float32View[index++] = uvs[i22];
            float32View[index++] = uvs[i22 + 1];
            uint32View[index++] = argb;
            uint32View[index++] = textureIdAndRound;
          }
        }
        /**
         * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
         * @param element - The DefaultBatchableQuadElement to pack.
         * @param float32View - The Float32Array view to pack into.
         * @param uint32View - The Uint32Array view to pack into.
         * @param index - The starting index in the views.
         * @param textureId - The texture ID to use.
         */
        packQuadAttributes(element, float32View, uint32View, index, textureId) {
          const texture = element.texture;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const bounds = element.bounds;
          const w0 = bounds.maxX;
          const w1 = bounds.minX;
          const h0 = bounds.maxY;
          const h1 = bounds.minY;
          const uvs = texture.uvs;
          const argb = element.color;
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
          float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
          float32View[index + 2] = uvs.x0;
          float32View[index + 3] = uvs.y0;
          uint32View[index + 4] = argb;
          uint32View[index + 5] = textureIdAndRound;
          float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
          float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
          float32View[index + 8] = uvs.x1;
          float32View[index + 9] = uvs.y1;
          uint32View[index + 10] = argb;
          uint32View[index + 11] = textureIdAndRound;
          float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
          float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
          float32View[index + 14] = uvs.x2;
          float32View[index + 15] = uvs.y2;
          uint32View[index + 16] = argb;
          uint32View[index + 17] = textureIdAndRound;
          float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
          float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
          float32View[index + 20] = uvs.x3;
          float32View[index + 21] = uvs.y3;
          uint32View[index + 22] = argb;
          uint32View[index + 23] = textureIdAndRound;
        }
      };
      _DefaultBatcher.extension = {
        type: [
          ExtensionType.Batcher
        ],
        name: "default"
      };
      DefaultBatcher = _DefaultBatcher;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
    let index = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index < size) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }
  var init_buildUvs = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  function transformVertices(vertices, m2, offset, stride, size) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset = offset || 0;
    stride = stride || 2;
    size = size || vertices.length / stride - offset;
    let index = offset * stride;
    for (let i3 = 0; i3 < size; i3++) {
      const x2 = vertices[index];
      const y2 = vertices[index + 1];
      vertices[index] = a2 * x2 + c2 * y2 + tx;
      vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
      index += stride;
    }
  }
  var init_transformVertices = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
  function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2)
      return color2;
    if (color2 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 * r2 / 255;
    const g3 = g1 * g2 / 255;
    const b3 = b1 * b2 / 255;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_multiplyHexColors = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
  var identityMatrix2, BatchableGraphics;
  var init_BatchableGraphics = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
      init_Matrix();
      init_multiplyHexColors();
      identityMatrix2 = new Matrix();
      BatchableGraphics = class {
        constructor() {
          this.packAsQuad = false;
          this.batcherName = "default";
          this.applyTransform = true;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
        }
        get uvs() {
          return this.geometryData.uvs;
        }
        get positions() {
          return this.geometryData.vertices;
        }
        get indices() {
          return this.geometryData.indices;
        }
        get blendMode() {
          if (this.applyTransform) {
            return this.renderable.groupBlendMode;
          }
          return "normal";
        }
        get color() {
          const rgb = this.baseColor;
          const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
          const renderable = this.renderable;
          if (renderable) {
            return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
          }
          return bgr + (this.alpha * 255 << 24);
        }
        get transform() {
          return this.renderable?.groupTransform || identityMatrix2;
        }
        copyTo(gpuBuffer) {
          gpuBuffer.indexOffset = this.indexOffset;
          gpuBuffer.indexSize = this.indexSize;
          gpuBuffer.attributeOffset = this.attributeOffset;
          gpuBuffer.attributeSize = this.attributeSize;
          gpuBuffer.baseColor = this.baseColor;
          gpuBuffer.alpha = this.alpha;
          gpuBuffer.texture = this.texture;
          gpuBuffer.geometryData = this.geometryData;
        }
        reset() {
          this.applyTransform = true;
          this.renderable = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle, buildEllipse, buildRoundedRectangle;
  var init_buildCircle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
      init_Extensions();
      buildCircle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "circle"
        },
        build(shape, points) {
          let x2;
          let y2;
          let dx;
          let dy;
          let rx;
          let ry;
          if (shape.type === "circle") {
            const circle = shape;
            x2 = circle.x;
            y2 = circle.y;
            rx = ry = circle.radius;
            dx = dy = 0;
          } else if (shape.type === "ellipse") {
            const ellipse = shape;
            x2 = ellipse.x;
            y2 = ellipse.y;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            dx = dy = 0;
          } else {
            const roundedRect = shape;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth;
            y2 = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
          }
          if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
            return points;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
          const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (m2 === 0) {
            return points;
          }
          if (n2 === 0) {
            points[0] = points[6] = x2 + dx;
            points[1] = points[3] = y2 + dy;
            points[2] = points[4] = x2 - dx;
            points[5] = points[7] = y2 - dy;
            return points;
          }
          let j1 = 0;
          let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
          let j3 = j2;
          let j4 = m2;
          let x0 = dx + rx;
          let y0 = dy;
          let x1 = x2 + x0;
          let x22 = x2 - x0;
          let y1 = y2 + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x22;
          if (dy) {
            const y222 = y2 - y0;
            points[j3++] = x22;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x1;
          }
          for (let i3 = 1; i3 < n2; i3++) {
            const a2 = Math.PI / 2 * (i3 / n2);
            const x02 = dx + Math.cos(a2) * rx;
            const y02 = dy + Math.sin(a2) * ry;
            const x12 = x2 + x02;
            const x222 = x2 - x02;
            const y12 = y2 + y02;
            const y222 = y2 - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x222;
            points[j3++] = x222;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x12;
          }
          x0 = dx;
          y0 = dy + ry;
          x1 = x2 + x0;
          x22 = x2 - x0;
          y1 = y2 + y0;
          const y22 = y2 - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x22;
            points[j1++] = y1;
            points[--j4] = y22;
            points[--j4] = x22;
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          if (points.length === 0) {
            return;
          }
          let centerX = 0;
          let centerY = 0;
          for (let i3 = 0; i3 < points.length; i3 += 2) {
            centerX += points[i3];
            centerY += points[i3 + 1];
          }
          centerX /= points.length / 2;
          centerY /= points.length / 2;
          let count2 = verticesOffset;
          vertices[count2 * verticesStride] = centerX;
          vertices[count2 * verticesStride + 1] = centerY;
          const centerIndex = count2++;
          for (let i3 = 0; i3 < points.length; i3 += 2) {
            vertices[count2 * verticesStride] = points[i3];
            vertices[count2 * verticesStride + 1] = points[i3 + 1];
            if (i3 > 0) {
              indices[indicesOffset++] = count2;
              indices[indicesOffset++] = centerIndex;
              indices[indicesOffset++] = count2 - 1;
            }
            count2++;
          }
          indices[indicesOffset++] = centerIndex + 1;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count2 - 1;
        }
      };
      buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
      buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
  var closePointEps, curveEps;
  var init_const6 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
      "use strict";
      closePointEps = 1e-4;
      curveEps = 1e-4;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area = 0;
    for (let i3 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i3 < m2; i3 += 2) {
      const x2 = points[i3];
      const y2 = points[i3 + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area < 0) {
      return -1;
    }
    return 1;
  }
  var init_getOrientationOfPoints = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i3 = 1; i3 < length - 1; ++i3) {
      x0 = points[(i3 - 1) * 2];
      y0 = points[(i3 - 1) * 2 + 1];
      x1 = points[i3 * 2];
      y1 = points[i3 * 2 + 1];
      x2 = points[(i3 + 1) * 2];
      y2 = points[(i3 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i3 = indexStart; i3 < indexCount + indexStart - 2; ++i3) {
      x0 = verts[i3 * 2];
      y0 = verts[i3 * 2 + 1];
      x1 = verts[(i3 + 1) * 2];
      y1 = verts[(i3 + 1) * 2 + 1];
      x2 = verts[(i3 + 2) * 2];
      y2 = verts[(i3 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i3, i3 + 1, i3 + 2);
    }
  }
  var init_buildLine = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
      init_Point();
      init_const6();
      init_getOrientationOfPoints();
    }
  });

  // node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i3 = dim; i3 < outerLen; i3 += dim) {
            x2 = data[i3];
            y2 = data[i3 + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i3, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i3 = start; i3 < end; i3 += dim)
            last = insertNode(i3, data[i3], data[i3 + 1], last);
        } else {
          for (i3 = end - dim; i3 >= start; i3 -= dim)
            last = insertNode(i3, data[i3], data[i3 + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p3 = start, again;
        do {
          again = false;
          if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
            removeNode(p3);
            p3 = end = p3.prev;
            if (p3 === p3.next)
              break;
            again = true;
          } else {
            p3 = p3.next;
          }
        } while (again || p3 !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p3 = c2.next;
        while (p3 !== a2) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p3 = ear.prevZ, n2 = ear.nextZ;
        while (p3 && p3.z >= minZ && n2 && n2.z <= maxZ) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a2 && p3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        while (p3 && p3.z >= minZ) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a2 && p3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p3 = start;
        do {
          var a2 = p3.prev, b2 = p3.next.next;
          if (!equals(a2, b2) && intersects(a2, p3, p3.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p3.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode(p3);
            removeNode(p3.next);
            p3 = start = b2;
          }
          p3 = p3.next;
        } while (p3 !== start);
        return filterPoints(p3);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a2 = start;
        do {
          var b2 = a2.next.next;
          while (b2 !== a2.prev) {
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
              var c2 = splitPolygon(a2, b2);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a2 = a2.next;
        } while (a2 !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i3, len, start, end, list;
        for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
          start = holeIndices[i3] * dim;
          end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i3 = 0; i3 < queue.length; i3++) {
          outerNode = eliminateHole(queue[i3], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b2) {
        return a2.x - b2.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p3 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
            var x2 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m2 = p3.x < p3.next.x ? p3 : p3.next;
              if (x2 === hx)
                return m2;
            }
          }
          p3 = p3.next;
        } while (p3 !== outerNode);
        if (!m2)
          return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
        p3 = m2;
        do {
          if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
            tan = Math.abs(hy - p3.y) / (hx - p3.x);
            if (locallyInside(p3, hole) && (tan < tanMin || tan === tanMin && (p3.x > m2.x || p3.x === m2.x && sectorContainsSector(m2, p3)))) {
              m2 = p3;
              tanMin = tan;
            }
          }
          p3 = p3.next;
        } while (p3 !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p3) {
        return area(m2.prev, m2, p3.prev) < 0 && area(p3.next, m2, m2.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p3 = start;
        do {
          if (p3.z === 0)
            p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
          p3.prevZ = p3.prev;
          p3.nextZ = p3.next;
          p3 = p3.next;
        } while (p3 !== start);
        p3.prevZ.nextZ = null;
        p3.prevZ = null;
        sortLinked(p3);
      }
      function sortLinked(list) {
        var i3, p3, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p3 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p3) {
            numMerges++;
            q = p3;
            pSize = 0;
            for (i3 = 0; i3 < inSize; i3++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p3.z <= q.z)) {
                e2 = p3;
                p3 = p3.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e2;
              else
                list = e2;
              e2.prevZ = tail;
              tail = e2;
            }
            p3 = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p3 = start, leftmost = start;
        do {
          if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
            leftmost = p3;
          p3 = p3.next;
        } while (p3 !== start);
        return leftmost;
      }
      function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b2) {
        return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
        (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
        (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
        equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
      }
      function area(p3, q, r2) {
        return (q.y - p3.y) * (r2.x - q.x) - (q.x - p3.x) * (r2.y - q.y);
      }
      function equals(p1, p22) {
        return p1.x === p22.x && p1.y === p22.y;
      }
      function intersects(p1, q1, p22, q2) {
        var o1 = sign(area(p1, q1, p22));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p22, q2, p1));
        var o4 = sign(area(p22, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p22, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p22, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p22, q1, q2))
          return true;
        return false;
      }
      function onSegment(p3, q, r2) {
        return q.x <= Math.max(p3.x, r2.x) && q.x >= Math.min(p3.x, r2.x) && q.y <= Math.max(p3.y, r2.y) && q.y >= Math.min(p3.y, r2.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b2) {
        var p3 = a2;
        do {
          if (p3.i !== a2.i && p3.next.i !== a2.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects(p3, p3.next, a2, b2))
            return true;
          p3 = p3.next;
        } while (p3 !== a2);
        return false;
      }
      function locallyInside(a2, b2) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
      }
      function middleInside(a2, b2) {
        var p3 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
        do {
          if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
            inside = !inside;
          p3 = p3.next;
        } while (p3 !== a2);
        return inside;
      }
      function splitPolygon(a2, b2) {
        var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
        a2.next = b2;
        b2.prev = a2;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode(i3, x2, y2, last) {
        var p3 = new Node(i3, x2, y2);
        if (!last) {
          p3.prev = p3;
          p3.next = p3;
        } else {
          p3.next = last.next;
          p3.prev = last;
          last.next.prev = p3;
          last.next = p3;
        }
        return p3;
      }
      function removeNode(p3) {
        p3.next.prev = p3.prev;
        p3.prev.next = p3.next;
        if (p3.prevZ)
          p3.prevZ.nextZ = p3.nextZ;
        if (p3.nextZ)
          p3.nextZ.prevZ = p3.prevZ;
      }
      function Node(i3, x2, y2) {
        this.i = i3;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i3 = 0, len = holeIndices.length; i3 < len; i3++) {
            var start = holeIndices[i3] * dim;
            var end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i3 = 0; i3 < triangles.length; i3 += 3) {
          var a2 = triangles[i3] * dim;
          var b2 = triangles[i3 + 1] * dim;
          var c2 = triangles[i3 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i3 = start, j2 = end - dim; i3 < end; i3 += dim) {
          sum += (data[j2] - data[i3]) * (data[i3 + 1] + data[j2 + 1]);
          j2 = i3;
        }
        return sum;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i3 = 0; i3 < data.length; i3++) {
          for (var j2 = 0; j2 < data[i3].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++)
              result.vertices.push(data[i3][j2][d2]);
          }
          if (i3 > 0) {
            holeIndex += data[i3 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = (0, import_earcut.default)(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i3 = 0; i3 < triangles.length; i3 += 3) {
      indices[indicesOffset++] = triangles[i3] + verticesOffset;
      indices[indicesOffset++] = triangles[i3 + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i3 + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i3 = 0; i3 < points.length; i3 += 2) {
      vertices[index] = points[i3];
      vertices[index + 1] = points[i3 + 1];
      index += verticesStride;
    }
  }
  var import_earcut;
  var init_triangulateWithHoles = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
      import_earcut = __toESM(require_earcut(), 1);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray, buildPolygon;
  var init_buildPolygon = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
      init_Extensions();
      init_triangulateWithHoles();
      emptyArray = [];
      buildPolygon = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "polygon"
        },
        build(shape, points) {
          for (let i3 = 0; i3 < shape.points.length; i3++) {
            points[i3] = shape.points[i3];
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle;
  var init_buildRectangle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
      init_Extensions();
      buildRectangle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "rectangle"
        },
        build(shape, points) {
          const rectData = shape;
          const x2 = rectData.x;
          const y2 = rectData.y;
          const width = rectData.width;
          const height = rectData.height;
          if (!(width >= 0 && height >= 0)) {
            return points;
          }
          points[0] = x2;
          points[1] = y2;
          points[2] = x2 + width;
          points[3] = y2;
          points[4] = x2 + width;
          points[5] = y2 + height;
          points[6] = x2;
          points[7] = y2 + height;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[6];
          vertices[verticesOffset + count2 + 1] = points[7];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          count2 += verticesStride;
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 3;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle;
  var init_buildTriangle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
      init_Extensions();
      buildTriangle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "triangle"
        },
        build(shape, points) {
          points[0] = shape.x;
          points[1] = shape.y;
          points[2] = shape.x2;
          points[3] = shape.y2;
          points[4] = shape.x3;
          points[5] = shape.y3;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  function buildContextBatches(context4, gpuContext) {
    const { geometryData, batches } = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (let i3 = 0; i3 < context4.instructions.length; i3++) {
      const instruction = context4.instructions[i3];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
        }
        addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = shapeBuilders.rectangle;
    const rect = tempRect;
    const texture = data.image;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    build.build(rect, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const textureUvs = texture.uvs;
    uvs.push(
      textureUvs.x0,
      textureUvs.y0,
      textureUvs.x1,
      textureUvs.y1,
      textureUvs.x3,
      textureUvs.y3,
      textureUvs.x2,
      textureUvs.y2
    );
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const lastIndex = shapePath.shapePrimitives.length - 1;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i3) => {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = shapeBuilders[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (hole && lastIndex === i3) {
          if (lastIndex !== 0) {
            console.warn("[Pixi Graphics] only the last shape have be cut out");
          }
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(hole.shapePath);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close = shape.closePath ?? true;
        const lineStyle = style;
        buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = style.matrix;
        if (textureMatrix) {
          if (matrix) {
            textureMatrix.append(matrix.clone().invert());
          }
          buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
        }
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.attributeOffset = vertOffset;
      graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
      graphicsBatch.baseColor = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(shape) {
    if (!shape)
      return [];
    const holePrimitives = shape.shapePrimitives;
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = shapeBuilders[holePrimitive.type];
      holeBuilder.build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }
  var shapeBuilders, tempRect;
  var init_buildContextBatches = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
      init_Extensions();
      init_Rectangle();
      init_buildUvs();
      init_transformVertices();
      init_Texture();
      init_PoolGroup();
      init_BatchableGraphics();
      init_buildCircle();
      init_buildLine();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_triangulateWithHoles();
      shapeBuilders = {};
      extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
      extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
      tempRect = new Rectangle();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
  var init_GraphicsContextSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
      init_Extensions();
      init_getTextureBatchBindGroup();
      init_DefaultBatcher();
      init_InstructionSet();
      init_deprecation();
      init_PoolGroup();
      init_buildContextBatches();
      GpuGraphicsContext = class {
        constructor() {
          this.batches = [];
          this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
          };
        }
      };
      GraphicsContextRenderData = class {
        constructor() {
          this.batcher = new DefaultBatcher();
          this.instructions = new InstructionSet();
        }
        init() {
          this.instructions.reset();
        }
        /**
         * @deprecated since version 8.0.0
         * Use `batcher.geometry` instead.
         * @see {Batcher#geometry}
         */
        get geometry() {
          deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
          return this.batcher.geometry;
        }
      };
      _GraphicsContextSystem = class _GraphicsContextSystem2 {
        constructor(renderer) {
          this._gpuContextHash = {};
          this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
          renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
          renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
        }
        /**
         * Runner init called, update the default options
         * @ignore
         */
        init(options) {
          _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
        }
        getContextRenderData(context4) {
          return this._graphicsDataContextHash[context4.uid] || this._initContextRenderData(context4);
        }
        // Context management functions
        updateGpuContext(context4) {
          let gpuContext = this._gpuContextHash[context4.uid] || this._initContext(context4);
          if (context4.dirty) {
            if (gpuContext) {
              this._cleanGraphicsContextData(context4);
            } else {
              gpuContext = this._initContext(context4);
            }
            buildContextBatches(context4, gpuContext);
            const batchMode = context4.batchMode;
            if (context4.customShader || batchMode === "no-batch") {
              gpuContext.isBatchable = false;
            } else if (batchMode === "auto") {
              gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
            }
            context4.dirty = false;
          }
          return gpuContext;
        }
        getGpuContext(context4) {
          return this._gpuContextHash[context4.uid] || this._initContext(context4);
        }
        _initContextRenderData(context4) {
          const graphicsData = BigPool.get(GraphicsContextRenderData);
          const { batches, geometryData } = this._gpuContextHash[context4.uid];
          const vertexSize = geometryData.vertices.length;
          const indexSize = geometryData.indices.length;
          for (let i3 = 0; i3 < batches.length; i3++) {
            batches[i3].applyTransform = false;
          }
          const batcher = graphicsData.batcher;
          batcher.ensureAttributeBuffer(vertexSize);
          batcher.ensureIndexBuffer(indexSize);
          batcher.begin();
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batcher.add(batch);
          }
          batcher.finish(graphicsData.instructions);
          const geometry = batcher.geometry;
          geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
          geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
          const drawBatches = batcher.batches;
          for (let i3 = 0; i3 < drawBatches.length; i3++) {
            const batch = drawBatches[i3];
            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
          }
          this._graphicsDataContextHash[context4.uid] = graphicsData;
          return graphicsData;
        }
        _initContext(context4) {
          const gpuContext = new GpuGraphicsContext();
          gpuContext.context = context4;
          this._gpuContextHash[context4.uid] = gpuContext;
          context4.on("destroy", this.onGraphicsContextDestroy, this);
          return this._gpuContextHash[context4.uid];
        }
        onGraphicsContextDestroy(context4) {
          this._cleanGraphicsContextData(context4);
          context4.off("destroy", this.onGraphicsContextDestroy, this);
          this._gpuContextHash[context4.uid] = null;
        }
        _cleanGraphicsContextData(context4) {
          const gpuContext = this._gpuContextHash[context4.uid];
          if (!gpuContext.isBatchable) {
            if (this._graphicsDataContextHash[context4.uid]) {
              BigPool.return(this.getContextRenderData(context4));
              this._graphicsDataContextHash[context4.uid] = null;
            }
          }
          if (gpuContext.batches) {
            gpuContext.batches.forEach((batch) => {
              BigPool.return(batch);
            });
          }
        }
        destroy() {
          for (const i3 in this._gpuContextHash) {
            if (this._gpuContextHash[i3]) {
              this.onGraphicsContextDestroy(this._gpuContextHash[i3].context);
            }
          }
        }
      };
      _GraphicsContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "graphicsContext"
      };
      _GraphicsContextSystem.defaultOptions = {
        /**
         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
         * @default 0.5
         */
        bezierSmoothness: 0.5
      };
      GraphicsContextSystem = _GraphicsContextSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
  var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
  var init_State = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
      "use strict";
      blendModeIds = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
      };
      BLEND = 0;
      OFFSET = 1;
      CULLING = 2;
      DEPTH_TEST = 3;
      WINDING = 4;
      DEPTH_MASK = 5;
      _State = class _State2 {
        constructor() {
          this.data = 0;
          this.blendMode = "normal";
          this.polygonOffset = 0;
          this.blend = true;
          this.depthMask = true;
        }
        /**
         * Activates blending of the computed fragment color values.
         * @default true
         */
        get blend() {
          return !!(this.data & 1 << BLEND);
        }
        set blend(value) {
          if (!!(this.data & 1 << BLEND) !== value) {
            this.data ^= 1 << BLEND;
          }
        }
        /**
         * Activates adding an offset to depth values of polygon's fragments
         * @default false
         */
        get offsets() {
          return !!(this.data & 1 << OFFSET);
        }
        set offsets(value) {
          if (!!(this.data & 1 << OFFSET) !== value) {
            this.data ^= 1 << OFFSET;
          }
        }
        /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
        set cullMode(value) {
          if (value === "none") {
            this.culling = false;
            return;
          }
          this.culling = true;
          this.clockwiseFrontFace = value === "front";
        }
        get cullMode() {
          if (!this.culling) {
            return "none";
          }
          return this.clockwiseFrontFace ? "front" : "back";
        }
        /**
         * Activates culling of polygons.
         * @default false
         */
        get culling() {
          return !!(this.data & 1 << CULLING);
        }
        set culling(value) {
          if (!!(this.data & 1 << CULLING) !== value) {
            this.data ^= 1 << CULLING;
          }
        }
        /**
         * Activates depth comparisons and updates to the depth buffer.
         * @default false
         */
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST);
        }
        set depthTest(value) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value) {
            this.data ^= 1 << DEPTH_TEST;
          }
        }
        /**
         * Enables or disables writing to the depth buffer.
         * @default true
         */
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK);
        }
        set depthMask(value) {
          if (!!(this.data & 1 << DEPTH_MASK) !== value) {
            this.data ^= 1 << DEPTH_MASK;
          }
        }
        /**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @default false
         */
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING);
        }
        set clockwiseFrontFace(value) {
          if (!!(this.data & 1 << WINDING) !== value) {
            this.data ^= 1 << WINDING;
          }
        }
        /**
         * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         * @default 'normal'
         */
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value) {
          this.blend = value !== "none";
          this._blendMode = value;
          this._blendModeId = blendModeIds[value] || 0;
        }
        /**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         * @default 0
         */
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        }
        toString() {
          return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        /**
         * A quickly getting an instance of a State that is configured for 2d rendering.
         * @returns a new State with values set for 2d rendering
         */
        static for2d() {
          const state = new _State2();
          state.depthTest = false;
          state.blend = true;
          return state;
        }
      };
      _State.default2d = _State.for2d();
      State = _State;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
  function colorToUniform(rgb, alpha, out2, offset) {
    out2[offset++] = (rgb >> 16 & 255) / 255;
    out2[offset++] = (rgb >> 8 & 255) / 255;
    out2[offset++] = (rgb & 255) / 255;
    out2[offset++] = alpha;
  }
  function color32BitToUniform(abgr, out2, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out2[offset++] = (abgr & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out2[offset++] = alpha;
  }
  var init_colorToUniform = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsPipe;
  var init_GraphicsPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
      init_Extensions();
      init_State();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableGraphics();
      GraphicsPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
          this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash");
        }
        validateRenderable(graphics) {
          const context4 = graphics.context;
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(context4);
          if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
          }
          return false;
        }
        addRenderable(graphics, instructionSet) {
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (graphics.didViewUpdate) {
            this._rebuild(graphics);
          }
          if (gpuContext.isBatchable) {
            this._addToBatcher(graphics, instructionSet);
          } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add(graphics);
          }
        }
        updateRenderable(graphics) {
          const batches = this._graphicsBatchesHash[graphics.uid];
          if (batches) {
            for (let i3 = 0; i3 < batches.length; i3++) {
              const batch = batches[i3];
              batch._batcher.updateElement(batch);
            }
          }
        }
        destroyRenderable(graphics) {
          if (this._graphicsBatchesHash[graphics.uid]) {
            this._removeBatchForRenderable(graphics.uid);
          }
          graphics.off("destroyed", this._destroyRenderableBound);
        }
        execute(graphics) {
          if (!graphics.isRenderable)
            return;
          const renderer = this.renderer;
          const context4 = graphics.context;
          const contextSystem = renderer.graphicsContext;
          if (!contextSystem.getGpuContext(context4).batches.length) {
            return;
          }
          const shader = context4.customShader || this._adaptor.shader;
          this.state.blendMode = graphics.groupBlendMode;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = graphics.groupTransform;
          localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
          color32BitToUniform(
            graphics.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._adaptor.execute(this, graphics);
        }
        _rebuild(graphics) {
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (wasBatched) {
            this._removeBatchForRenderable(graphics.uid);
          }
          if (gpuContext.isBatchable) {
            this._initBatchesForRenderable(graphics);
          }
          graphics.batched = gpuContext.isBatchable;
        }
        _addToBatcher(graphics, instructionSet) {
          const batchPipe = this.renderer.renderPipes.batch;
          const batches = this._getBatchesForRenderable(graphics);
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batchPipe.addToBatch(batch, instructionSet);
          }
        }
        _getBatchesForRenderable(graphics) {
          return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
        }
        _initBatchesForRenderable(graphics) {
          const context4 = graphics.context;
          const gpuContext = this.renderer.graphicsContext.getGpuContext(context4);
          const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
          const batches = gpuContext.batches.map((batch) => {
            const batchClone = BigPool.get(BatchableGraphics);
            batch.copyTo(batchClone);
            batchClone.renderable = graphics;
            batchClone.roundPixels = roundPixels;
            return batchClone;
          });
          if (this._graphicsBatchesHash[graphics.uid] === void 0) {
            graphics.on("destroyed", this._destroyRenderableBound);
          }
          this._graphicsBatchesHash[graphics.uid] = batches;
          return batches;
        }
        _removeBatchForRenderable(graphicsUid) {
          this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
            BigPool.return(batch);
          });
          this._graphicsBatchesHash[graphicsUid] = null;
        }
        destroy() {
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.state = null;
          for (const i3 in this._graphicsBatchesHash) {
            this._removeBatchForRenderable(i3);
          }
          this._graphicsBatchesHash = null;
        }
      };
      GraphicsPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/init.mjs
  var init_init6 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
      init_Extensions();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      extensions.add(GraphicsPipe);
      extensions.add(GraphicsContextSystem);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
  var BatchableMesh;
  var init_BatchableMesh = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
      "use strict";
      BatchableMesh = class {
        constructor() {
          this.batcherName = "default";
          this.packAsQuad = false;
          this.indexOffset = 0;
          this.attributeOffset = 0;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.geometry = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get uvs() {
          const geometry = this.geometry;
          const uvBuffer = geometry.getBuffer("aUV");
          const uvs = uvBuffer.data;
          let transformedUvs = uvs;
          const textureMatrix = this.texture.textureMatrix;
          if (!textureMatrix.isSimple) {
            transformedUvs = this._transformedUvs;
            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
              if (!transformedUvs || transformedUvs.length < uvs.length) {
                transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
              }
              this._textureMatrixUpdateId = textureMatrix._updateID;
              this._uvUpdateId = uvBuffer._updateID;
              textureMatrix.multiplyUvs(uvs, transformedUvs);
            }
          }
          return transformedUvs;
        }
        get positions() {
          return this.geometry.positions;
        }
        get indices() {
          return this.geometry.indices;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        get groupTransform() {
          return this.renderable.groupTransform;
        }
        get attributeSize() {
          return this.geometry.positions.length / 2;
        }
        get indexSize() {
          return this.geometry.indices.length;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshPipe;
  var init_MeshPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_BindGroup();
      init_UniformGroup();
      init_getAdjustedBlendModeBlend();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableMesh();
      MeshPipe = class {
        constructor(renderer, adaptor) {
          this.localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this.localUniformsBindGroup = new BindGroup({
            0: this.localUniforms
          });
          this._meshDataHash = /* @__PURE__ */ Object.create(null);
          this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
          renderer.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash");
          renderer.renderableGC.addManagedHash(this, "_meshDataHash");
        }
        validateRenderable(mesh) {
          const meshData = this._getMeshData(mesh);
          const wasBatched = meshData.batched;
          const isBatched = mesh.batched;
          meshData.batched = isBatched;
          if (wasBatched !== isBatched) {
            return true;
          } else if (isBatched) {
            const geometry = mesh._geometry;
            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
              meshData.indexSize = geometry.indices.length;
              meshData.vertexSize = geometry.positions.length;
              return true;
            }
            const batchableMesh = this._getBatchableMesh(mesh);
            const texture = mesh.texture;
            if (batchableMesh.texture._source !== texture._source) {
              if (batchableMesh.texture._source !== texture._source) {
                return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);
              }
            }
          }
          return false;
        }
        addRenderable(mesh, instructionSet) {
          const batcher = this.renderer.renderPipes.batch;
          const { batched } = this._getMeshData(mesh);
          if (batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            batcher.addToBatch(gpuBatchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            instructionSet.add(mesh);
          }
        }
        updateRenderable(mesh) {
          if (mesh.batched) {
            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
          }
        }
        destroyRenderable(mesh) {
          this._meshDataHash[mesh.uid] = null;
          const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
          if (gpuMesh) {
            BigPool.return(gpuMesh);
            this._gpuBatchableMeshHash[mesh.uid] = null;
          }
          mesh.off("destroyed", this._destroyRenderableBound);
        }
        execute(mesh) {
          if (!mesh.isRenderable)
            return;
          mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
          const localUniforms = this.localUniforms;
          localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
          localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
          localUniforms.update();
          color32BitToUniform(
            mesh.groupColorAlpha,
            localUniforms.uniforms.uColor,
            0
          );
          this._adaptor.execute(this, mesh);
        }
        _getMeshData(mesh) {
          return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
        }
        _initMeshData(mesh) {
          this._meshDataHash[mesh.uid] = {
            batched: mesh.batched,
            indexSize: mesh._geometry.indices?.length,
            vertexSize: mesh._geometry.positions?.length
          };
          mesh.on("destroyed", this._destroyRenderableBound);
          return this._meshDataHash[mesh.uid];
        }
        _getBatchableMesh(mesh) {
          return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
        }
        _initBatchableMesh(mesh) {
          const gpuMesh = BigPool.get(BatchableMesh);
          gpuMesh.renderable = mesh;
          gpuMesh.texture = mesh._texture;
          gpuMesh.transform = mesh.groupTransform;
          gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
          this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
          return gpuMesh;
        }
        destroy() {
          for (const i3 in this._gpuBatchableMeshHash) {
            if (this._gpuBatchableMeshHash[i3]) {
              BigPool.return(this._gpuBatchableMeshHash[i3]);
            }
          }
          this._gpuBatchableMeshHash = null;
          this._meshDataHash = null;
          this.localUniforms = null;
          this.localUniformsBindGroup = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.renderer = null;
        }
      };
      MeshPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/init.mjs
  var init_init7 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
      init_Extensions();
      init_MeshPipe();
      extensions.add(MeshPipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
  var GlParticleContainerAdaptor;
  var init_GlParticleContainerAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs"() {
      "use strict";
      GlParticleContainerAdaptor = class {
        execute(particleContainerPop, container) {
          const state = particleContainerPop.state;
          const renderer = particleContainerPop.renderer;
          const shader = container.shader || particleContainerPop.defaultShader;
          shader.resources.uTexture = container.texture._source;
          shader.resources.uniforms = particleContainerPop.localUniforms;
          const gl = renderer.gl;
          const buffer = particleContainerPop.getBuffers(container);
          renderer.shader.bind(shader);
          renderer.state.set(state);
          renderer.geometry.bind(buffer.geometry, shader.glProgram);
          const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    if (totalIndices > 65535) {
      outBuffer = outBuffer || new Uint32Array(totalIndices);
    } else {
      outBuffer = outBuffer || new Uint16Array(totalIndices);
    }
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i3 = 0, j2 = 0; i3 < totalIndices; i3 += 6, j2 += 4) {
      outBuffer[i3 + 0] = j2 + 0;
      outBuffer[i3 + 1] = j2 + 1;
      outBuffer[i3 + 2] = j2 + 2;
      outBuffer[i3 + 3] = j2 + 0;
      outBuffer[i3 + 4] = j2 + 2;
      outBuffer[i3 + 5] = j2 + 3;
    }
    return outBuffer;
  }
  var init_createIndicesForQuads = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
  function generateParticleUpdateFunction(properties) {
    return {
      dynamicUpdate: generateUpdateFunction(properties, true),
      staticUpdate: generateUpdateFunction(properties, false)
    };
  }
  function generateUpdateFunction(properties, dynamic) {
    const funcFragments = [];
    funcFragments.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let offset = 0;
    for (const i3 in properties) {
      const property = properties[i3];
      if (dynamic !== property.dynamic)
        continue;
      funcFragments.push(`offset = index + ${offset}`);
      funcFragments.push(property.code);
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      offset += attributeInfo.stride / 4;
    }
    funcFragments.push(`
            index += stride * 4;
        }
    `);
    funcFragments.unshift(`
        var stride = ${offset};
    `);
    const functionSource = funcFragments.join("\n");
    return new Function("ps", "f32v", "u32v", functionSource);
  }
  var init_generateParticleUpdateFunction = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs"() {
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
  function getParticleSyncKey(properties) {
    const keyGen = [];
    for (const key in properties) {
      const property = properties[key];
      keyGen.push(key, property.code, property.dynamic ? "d" : "s");
    }
    return keyGen.join("_");
  }
  var ParticleBuffer;
  var init_ParticleBuffer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      init_getAttributeInfoFromFormat();
      init_ViewableBuffer();
      init_createIndicesForQuads();
      init_generateParticleUpdateFunction();
      ParticleBuffer = class {
        constructor(options) {
          this._size = 0;
          this._generateParticleUpdateCache = {};
          const size = this._size = options.size ?? 1e3;
          const properties = options.properties;
          let staticVertexSize = 0;
          let dynamicVertexSize = 0;
          for (const i3 in properties) {
            const property = properties[i3];
            const attributeInfo = getAttributeInfoFromFormat(property.format);
            if (property.dynamic) {
              dynamicVertexSize += attributeInfo.stride;
            } else {
              staticVertexSize += attributeInfo.stride;
            }
          }
          this._dynamicStride = dynamicVertexSize / 4;
          this._staticStride = staticVertexSize / 4;
          this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
          this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
          this.indexBuffer = createIndicesForQuads(size);
          const geometry = new Geometry();
          let dynamicOffset = 0;
          let staticOffset = 0;
          this._staticBuffer = new Buffer2({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: false,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          this._dynamicBuffer = new Buffer2({
            data: new Float32Array(1),
            label: "dynamic-particle-buffer",
            shrinkToFit: false,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          for (const i3 in properties) {
            const property = properties[i3];
            const attributeInfo = getAttributeInfoFromFormat(property.format);
            if (property.dynamic) {
              geometry.addAttribute(property.attributeName, {
                buffer: this._dynamicBuffer,
                stride: this._dynamicStride * 4,
                offset: dynamicOffset * 4,
                format: property.format
              });
              dynamicOffset += attributeInfo.size;
            } else {
              geometry.addAttribute(property.attributeName, {
                buffer: this._staticBuffer,
                stride: this._staticStride * 4,
                offset: staticOffset * 4,
                format: property.format
              });
              staticOffset += attributeInfo.size;
            }
          }
          geometry.addIndex(this.indexBuffer);
          const uploadFunction = this.getParticleUpdate(properties);
          this._dynamicUpload = uploadFunction.dynamicUpdate;
          this._staticUpload = uploadFunction.staticUpdate;
          this.geometry = geometry;
        }
        getParticleUpdate(properties) {
          const key = getParticleSyncKey(properties);
          if (this._generateParticleUpdateCache[key]) {
            return this._generateParticleUpdateCache[key];
          }
          this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
          return this._generateParticleUpdateCache[key];
        }
        generateParticleUpdate(properties) {
          return generateParticleUpdateFunction(properties);
        }
        update(particles, uploadStatic) {
          if (particles.length > this._size) {
            uploadStatic = true;
            this._size = Math.max(particles.length, this._size * 1.5 | 0);
            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
            this.indexBuffer = createIndicesForQuads(this._size);
            this.geometry.indexBuffer.setDataWithSize(
              this.indexBuffer,
              this.indexBuffer.byteLength,
              true
            );
          }
          const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
          this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
          this._dynamicBuffer.setDataWithSize(
            this.dynamicAttributeBuffer.float32View,
            particles.length * this._dynamicStride * 4,
            true
          );
          if (uploadStatic) {
            const staticAttributeBuffer = this.staticAttributeBuffer;
            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
            this._staticBuffer.setDataWithSize(
              staticAttributeBuffer.float32View,
              particles.length * this._staticStride * 4,
              true
            );
          }
        }
        destroy() {
          this._staticBuffer.destroy();
          this._dynamicBuffer.destroy();
          this.geometry.destroy();
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
  var fragment;
  var init_particles_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs"() {
      fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
  var vertex;
  var init_particles_vert = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs"() {
      vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = aColor * uColor;\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
  var wgsl;
  var init_particles_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs"() {
      wgsl = "\nstruct ParticleUniforms {\n  uProjectionMatrix:mat3x3<f32>,\n  uResolution:vec2<f32>,\n  uRoundPixels:f32,\n};\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n  return VSOutput(\n   position,\n   aUV,\n   aColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
  var ParticleShader;
  var init_ParticleShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs"() {
      init_Color();
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_Texture();
      init_TextureStyle();
      init_particles_frag();
      init_particles_vert();
      init_particles_wgsl();
      ParticleShader = class extends Shader {
        constructor() {
          const glProgram3 = GlProgram.from({
            vertex,
            fragment
          });
          const gpuProgram3 = GpuProgram.from({
            fragment: {
              source: wgsl,
              entryPoint: "mainFragment"
            },
            vertex: {
              source: wgsl,
              entryPoint: "mainVertex"
            }
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              // this will be replaced with the texture from the particle container
              uTexture: Texture.WHITE.source,
              // this will be replaced with the texture style from the particle container
              uSampler: new TextureStyle({}),
              // this will be replaced with the local uniforms from the particle container
              uniforms: {
                uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Color(16777215), type: "vec4<f32>" },
                uRound: { value: 1, type: "f32" },
                uResolution: { value: [0, 0], type: "vec2<f32>" }
              }
            }
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
  var ParticleContainerPipe;
  var init_ParticleContainerPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs"() {
      init_Matrix();
      init_UniformGroup();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_colorToUniform();
      init_ParticleBuffer();
      init_ParticleShader();
      ParticleContainerPipe = class {
        /**
         * @param renderer - The renderer this sprite batch works for.
         * @param adaptor
         */
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._gpuBufferHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.localUniforms = new UniformGroup({
            uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array(4), type: "vec4<f32>" },
            uRound: { value: 1, type: "f32" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          });
          this.renderer = renderer;
          this.adaptor = adaptor;
          this.defaultShader = new ParticleShader();
          this.state = State.for2d();
        }
        validateRenderable(_renderable) {
          return false;
        }
        addRenderable(renderable, instructionSet) {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderable);
        }
        getBuffers(renderable) {
          return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);
        }
        _initBuffer(renderable) {
          this._gpuBufferHash[renderable.uid] = new ParticleBuffer({
            size: renderable.particleChildren.length,
            properties: renderable._properties
          });
          renderable.on("destroyed", this._destroyRenderableBound);
          return this._gpuBufferHash[renderable.uid];
        }
        updateRenderable(_renderable) {
        }
        destroyRenderable(renderable) {
          const buffer = this._gpuBufferHash[renderable.uid];
          buffer.destroy();
          this._gpuBufferHash[renderable.uid] = null;
          renderable.off("destroyed", this._destroyRenderableBound);
        }
        execute(container) {
          const children = container.particleChildren;
          if (children.length === 0) {
            return;
          }
          const renderer = this.renderer;
          const buffer = this.getBuffers(container);
          container.texture || (container.texture = children[0].texture);
          const state = this.state;
          buffer.update(children, container._childrenDirty);
          container._childrenDirty = false;
          state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
          const uniforms = this.localUniforms.uniforms;
          const transformationMatrix = uniforms.uTranslationMatrix;
          container.worldTransform.copyTo(transformationMatrix);
          transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
          uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
          uniforms.uRound = renderer._roundPixels | container._roundPixels;
          color32BitToUniform(
            container.groupColorAlpha,
            uniforms.uColor,
            0
          );
          this.adaptor.execute(this, container);
        }
        /** Destroys the ParticleRenderer. */
        destroy() {
          if (this.defaultShader) {
            this.defaultShader.destroy();
            this.defaultShader = null;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
  var GlParticleContainerPipe;
  var init_GlParticleContainerPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs"() {
      init_Extensions();
      init_GlParticleContainerAdaptor();
      init_ParticleContainerPipe();
      GlParticleContainerPipe = class extends ParticleContainerPipe {
        constructor(renderer) {
          super(renderer, new GlParticleContainerAdaptor());
        }
      };
      GlParticleContainerPipe.extension = {
        type: [
          ExtensionType.WebGLPipes
        ],
        name: "particle"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
  var GpuParticleContainerAdaptor;
  var init_GpuParticleContainerAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs"() {
      "use strict";
      GpuParticleContainerAdaptor = class {
        execute(particleContainerPop, container) {
          const renderer = particleContainerPop.renderer;
          const shader = container.shader || particleContainerPop.defaultShader;
          shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPop.localUniforms, true);
          shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
          const state = particleContainerPop.state;
          const buffer = particleContainerPop.getBuffers(container);
          renderer.encoder.draw({
            geometry: buffer.geometry,
            shader: container.shader || particleContainerPop.defaultShader,
            state,
            size: container.particleChildren.length * 6
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
  var GpuParticleContainerPipe;
  var init_GpuParticleContainerPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs"() {
      init_Extensions();
      init_GpuParticleContainerAdaptor();
      init_ParticleContainerPipe();
      GpuParticleContainerPipe = class extends ParticleContainerPipe {
        constructor(renderer) {
          super(renderer, new GpuParticleContainerAdaptor());
        }
      };
      GpuParticleContainerPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "particle"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/init.mjs
  var init_init8 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/init.mjs"() {
      init_Extensions();
      init_GlParticleContainerPipe();
      init_GpuParticleContainerPipe();
      extensions.add(GlParticleContainerPipe);
      extensions.add(GpuParticleContainerPipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
  var BatchableSprite;
  var init_BatchableSprite = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
      "use strict";
      BatchableSprite = class {
        constructor() {
          this.batcherName = "default";
          this.attributeSize = 4;
          this.indexSize = 6;
          this.packAsQuad = true;
          this.roundPixels = 0;
          this._attributeStart = 0;
          this._batcher = null;
          this._batch = null;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.bounds = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe;
  var init_CanvasTextPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
      init_Extensions();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      CanvasTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.runners.resolutionChange.add(this);
          this._renderer.renderableGC.addManagedHash(this, "_gpuText");
        }
        resolutionChange() {
          for (const i3 in this._gpuText) {
            const gpuText = this._gpuText[i3];
            if (!gpuText)
              continue;
            const text = gpuText.batchableSprite.renderable;
            if (text._autoResolution) {
              text._resolution = this._renderer.resolution;
              text.onViewUpdate();
            }
          }
        }
        validateRenderable(text) {
          const gpuText = this._getGpuText(text);
          const newKey = text._getKey();
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(text, instructionSet) {
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (text._didTextUpdate) {
            this._updateText(text);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
        }
        updateRenderable(text) {
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (text._didTextUpdate) {
            this._updateText(text);
          }
          batchableSprite._batcher.updateElement(batchableSprite);
        }
        destroyRenderable(text) {
          text.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableById(text.uid);
        }
        _destroyRenderableById(textUid) {
          const gpuText = this._gpuText[textUid];
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[textUid] = null;
        }
        _updateText(text) {
          const newKey = text._getKey();
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(text);
          }
          text._didTextUpdate = false;
          const padding = text._style.padding;
          updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);
        }
        _updateGpuText(text) {
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          }
          gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);
          gpuText.currentKey = text._getKey();
          batchableSprite.texture = gpuText.texture;
        }
        _getGpuText(text) {
          return this._gpuText[text.uid] || this.initGpuText(text);
        }
        initGpuText(text) {
          const gpuTextData = {
            texture: null,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite)
          };
          gpuTextData.batchableSprite.renderable = text;
          gpuTextData.batchableSprite.transform = text.groupTransform;
          gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;
          this._gpuText[text.uid] = gpuTextData;
          text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          this._updateText(text);
          text.on("destroyed", this._destroyRenderableBound);
          return gpuTextData;
        }
        destroy() {
          for (const i3 in this._gpuText) {
            this._destroyRenderableById(i3);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      CanvasTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "text"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass, CanvasPool;
  var init_CanvasPool = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
      init_adapter();
      init_pow2();
      CanvasPoolClass = class {
        constructor(canvasOptions) {
          this._canvasPool = /* @__PURE__ */ Object.create(null);
          this.canvasOptions = canvasOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         */
        _createCanvasAndContext(pixelWidth, pixelHeight) {
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = pixelWidth;
          canvas.height = pixelHeight;
          const context4 = canvas.getContext("2d");
          return { canvas, context: context4 };
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param minWidth - The minimum width of the render texture.
         * @param minHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @returns The new render texture.
         */
        getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
          minWidth = Math.ceil(minWidth * resolution - 1e-6);
          minHeight = Math.ceil(minHeight * resolution - 1e-6);
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          const key = (minWidth << 17) + (minHeight << 1);
          if (!this._canvasPool[key]) {
            this._canvasPool[key] = [];
          }
          let canvasAndContext = this._canvasPool[key].pop();
          if (!canvasAndContext) {
            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
          }
          return canvasAndContext;
        }
        /**
         * Place a render texture back into the pool.
         * @param canvasAndContext
         */
        returnCanvasAndContext(canvasAndContext) {
          const canvas = canvasAndContext.canvas;
          const { width, height } = canvas;
          const key = (width << 17) + (height << 1);
          canvasAndContext.context.clearRect(0, 0, width, height);
          this._canvasPool[key].push(canvasAndContext);
        }
        clear() {
          this._canvasPool = {};
        }
      };
      CanvasPool = new CanvasPoolClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count, TexturePoolClass, TexturePool;
  var init_TexturePool = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
      init_pow2();
      init_TextureSource();
      init_Texture();
      count = 0;
      TexturePoolClass = class {
        /**
         * @param textureOptions - options that will be passed to BaseRenderTexture constructor
         * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
         */
        constructor(textureOptions) {
          this._poolKeyHash = /* @__PURE__ */ Object.create(null);
          this._texturePool = {};
          this.textureOptions = textureOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         * @param antialias
         */
        createTexture(pixelWidth, pixelHeight, antialias) {
          const textureSource = new TextureSource({
            ...this.textureOptions,
            width: pixelWidth,
            height: pixelHeight,
            resolution: 1,
            antialias,
            autoGarbageCollect: true
          });
          return new Texture({
            source: textureSource,
            label: `texturePool_${count++}`
          });
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param frameWidth - The minimum width of the render texture.
         * @param frameHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @param antialias
         * @returns The new render texture.
         */
        getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
          let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
          let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
          po2Width = nextPow2(po2Width);
          po2Height = nextPow2(po2Height);
          const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
          if (!this._texturePool[key]) {
            this._texturePool[key] = [];
          }
          let texture = this._texturePool[key].pop();
          if (!texture) {
            texture = this.createTexture(po2Width, po2Height, antialias);
          }
          texture.source._resolution = resolution;
          texture.source.width = po2Width / resolution;
          texture.source.height = po2Height / resolution;
          texture.source.pixelWidth = po2Width;
          texture.source.pixelHeight = po2Height;
          texture.frame.x = 0;
          texture.frame.y = 0;
          texture.frame.width = frameWidth;
          texture.frame.height = frameHeight;
          texture.updateUvs();
          this._poolKeyHash[texture.uid] = key;
          return texture;
        }
        /**
         * Gets extra texture of the same size as input renderTexture
         * @param texture - The texture to check what size it is.
         * @param antialias - Whether to use antialias.
         * @returns A texture that is a power of two
         */
        getSameSizeTexture(texture, antialias = false) {
          const source7 = texture.source;
          return this.getOptimalTexture(texture.width, texture.height, source7._resolution, antialias);
        }
        /**
         * Place a render texture back into the pool.
         * @param renderTexture - The renderTexture to free
         */
        returnTexture(renderTexture) {
          const key = this._poolKeyHash[renderTexture.uid];
          this._texturePool[key].push(renderTexture);
        }
        /**
         * Clears the pool.
         * @param destroyTextures - Destroy all stored textures.
         */
        clear(destroyTextures) {
          destroyTextures = destroyTextures !== false;
          if (destroyTextures) {
            for (const i3 in this._texturePool) {
              const textures = this._texturePool[i3];
              if (textures) {
                for (let j2 = 0; j2 < textures.length; j2++) {
                  textures[j2].destroy(true);
                }
              }
            }
          }
          this._texturePool = {};
        }
      };
      TexturePool = new TexturePoolClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
  function checkRow(data, width, y2) {
    for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width, x2, top, bottom) {
    const stride = 4 * width;
    for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox(canvas, resolution = 1) {
    const { width, height } = canvas;
    const context4 = canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (context4 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    const imageData = context4.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while (top < height && checkRow(data, width, top))
      ++top;
    if (top === height)
      return Rectangle.EMPTY;
    while (checkRow(data, width, bottom))
      --bottom;
    while (checkColumn(data, width, left, top, bottom))
      ++left;
    while (checkColumn(data, width, right, top, bottom))
      --right;
    ++right;
    ++bottom;
    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
  }
  var init_getCanvasBoundingBox = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
      init_Rectangle();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
  var _FillGradient, FillGradient;
  var init_FillGradient = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
      init_Color();
      init_adapter();
      init_Matrix();
      init_ImageSource();
      init_Texture();
      init_uid();
      _FillGradient = class _FillGradient2 {
        constructor(x0, y0, x1, y1) {
          this.uid = uid("fillGradient");
          this.type = "linear";
          this.gradientStops = [];
          this._styleKey = null;
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;
        }
        addColorStop(offset, color) {
          this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
          this._styleKey = null;
          return this;
        }
        // TODO move to the system!
        buildLinearGradient() {
          const defaultSize = _FillGradient2.defaultTextureSize;
          const { gradientStops } = this;
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = defaultSize;
          canvas.height = defaultSize;
          const ctx = canvas.getContext("2d");
          const gradient = ctx.createLinearGradient(0, 0, _FillGradient2.defaultTextureSize, 1);
          for (let i3 = 0; i3 < gradientStops.length; i3++) {
            const stop = gradientStops[i3];
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, defaultSize, defaultSize);
          this.texture = new Texture({
            source: new ImageSource({
              resource: canvas,
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            })
          });
          const { x0, y0, x1, y1 } = this;
          const m2 = new Matrix();
          const dx = x1 - x0;
          const dy = y1 - y0;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          m2.translate(-x0, -y0);
          m2.scale(1 / defaultSize, 1 / defaultSize);
          m2.rotate(-angle);
          m2.scale(256 / dist, 1);
          this.transform = m2;
          this._styleKey = null;
        }
        get styleKey() {
          if (this._styleKey) {
            return this._styleKey;
          }
          const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join("-");
          const texture = this.texture.uid;
          const transform2 = this.transform.toArray().join("-");
          return `fill-gradient-${this.uid}-${stops}-${texture}-${transform2}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
        }
      };
      _FillGradient.defaultTextureSize = 256;
      FillGradient = _FillGradient;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap, FillPattern;
  var init_FillPattern = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
      init_Matrix();
      init_uid();
      repetitionMap = {
        repeat: {
          addressModeU: "repeat",
          addressModeV: "repeat"
        },
        "repeat-x": {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        },
        "no-repeat": {
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      };
      FillPattern = class {
        constructor(texture, repetition) {
          this.uid = uid("fillPattern");
          this.transform = new Matrix();
          this._styleKey = null;
          this.texture = texture;
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
          }
        }
        setTransform(transform2) {
          const texture = this.texture;
          this.transform.copyFrom(transform2);
          this.transform.invert();
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          this._styleKey = null;
        }
        get styleKey() {
          if (this._styleKey)
            return this._styleKey;
          this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
          return this._styleKey;
        }
      };
    }
  });

  // node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse2;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse2(path2) {
        var data = [];
        path2.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type])
              throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
  function SVGToGraphicsPath(svgPath, path2) {
    const commands = (0, import_parse_svg_path.default)(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i3 = 0; i3 < commands.length; i3++) {
      const command = commands[i3];
      const type = command[0];
      const data = command;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path2.bezierCurveTo(
            data[1],
            data[2],
            data[3],
            data[4],
            lastX,
            lastY
          );
          break;
        case "c":
          path2.bezierCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4],
            lastX + data[5],
            lastY + data[6]
          );
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path2.bezierCurveToShort(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "s":
          path2.bezierCurveToShort(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path2.quadraticCurveTo(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "q":
          path2.quadraticCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path2.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path2.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "Z":
        case "z":
          path2.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          warn(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = { startX: lastX, startY: lastY };
          subpaths.push(currentSubPath);
        }
      }
    }
    return path2;
  }
  var import_parse_svg_path;
  var init_SVGToGraphicsPath = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
      import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
      init_warn();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Circle.mjs
  var Circle;
  var init_Circle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
      init_Rectangle();
      Circle = class {
        /**
         * @param x - The X coordinate of the center of this circle
         * @param y - The Y coordinate of the center of this circle
         * @param radius - The radius of the circle
         */
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.type = "circle";
          this.x = x2;
          this.y = y2;
          this.radius = radius;
        }
        /**
         * Creates a clone of this Circle instance
         * @returns A copy of the Circle
         */
        clone() {
          return new Circle(this.x, this.y, this.radius);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Circle
         */
        contains(x2, y2) {
          if (this.radius <= 0)
            return false;
          const r2 = this.radius * this.radius;
          let dx = this.x - x2;
          let dy = this.y - y2;
          dx *= dx;
          dy *= dy;
          return dx + dy <= r2;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width - The width of the line to check
         * @returns Whether the x/y coordinates are within this Circle
         */
        strokeContains(x2, y2, width) {
          if (this.radius === 0)
            return false;
          const dx = this.x - x2;
          const dy = this.y - y2;
          const r2 = this.radius;
          const w2 = width / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < r2 + w2 && distance > r2 - w2;
        }
        /**
         * Returns the framing rectangle of the circle as a Rectangle object
         * @param out
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x - this.radius;
          out2.y = this.y - this.radius;
          out2.width = this.radius * 2;
          out2.height = this.radius * 2;
          return out2;
        }
        /**
         * Copies another circle to this one.
         * @param circle - The circle to copy from.
         * @returns Returns itself.
         */
        copyFrom(circle) {
          this.x = circle.x;
          this.y = circle.y;
          this.radius = circle.radius;
          return this;
        }
        /**
         * Copies this circle to another one.
         * @param circle - The circle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(circle) {
          circle.copyFrom(this);
          return circle;
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
  var Ellipse;
  var init_Ellipse = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
      init_Rectangle();
      Ellipse = class {
        /**
         * @param x - The X coordinate of the center of this ellipse
         * @param y - The Y coordinate of the center of this ellipse
         * @param halfWidth - The half width of this ellipse
         * @param halfHeight - The half height of this ellipse
         */
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.type = "ellipse";
          this.x = x2;
          this.y = y2;
          this.halfWidth = halfWidth;
          this.halfHeight = halfHeight;
        }
        /**
         * Creates a clone of this Ellipse instance
         * @returns {Ellipse} A copy of the ellipse
         */
        clone() {
          return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coords are within this ellipse
         */
        contains(x2, y2) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
          }
          let normx = (x2 - this.x) / this.halfWidth;
          let normy = (y2 - this.y) / this.halfHeight;
          normx *= normx;
          normy *= normy;
          return normx + normy <= 1;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse including stroke
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width
         * @returns Whether the x/y coords are within this ellipse
         */
        strokeContains(x2, y2, width) {
          const { halfWidth, halfHeight } = this;
          if (halfWidth <= 0 || halfHeight <= 0) {
            return false;
          }
          const halfStrokeWidth = width / 2;
          const innerA = halfWidth - halfStrokeWidth;
          const innerB = halfHeight - halfStrokeWidth;
          const outerA = halfWidth + halfStrokeWidth;
          const outerB = halfHeight + halfStrokeWidth;
          const normalizedX = x2 - this.x;
          const normalizedY = y2 - this.y;
          const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
          const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
          return innerEllipse > 1 && outerEllipse <= 1;
        }
        /**
         * Returns the framing rectangle of the ellipse as a Rectangle object
         * @param out
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x - this.halfWidth;
          out2.y = this.y - this.halfHeight;
          out2.width = this.halfWidth * 2;
          out2.height = this.halfHeight * 2;
          return out2;
        }
        /**
         * Copies another ellipse to this one.
         * @param ellipse - The ellipse to copy from.
         * @returns Returns itself.
         */
        copyFrom(ellipse) {
          this.x = ellipse.x;
          this.y = ellipse.y;
          this.halfWidth = ellipse.halfWidth;
          this.halfHeight = ellipse.halfHeight;
          return this;
        }
        /**
         * Copies this ellipse to another one.
         * @param ellipse - The ellipse to copy to.
         * @returns Returns given parameter.
         */
        copyTo(ellipse) {
          ellipse.copyFrom(this);
          return ellipse;
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
  function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
    const a2 = x2 - x1;
    const b2 = y2 - y1;
    const c2 = x22 - x1;
    const d2 = y22 - y1;
    const dot = a2 * c2 + b2 * d2;
    const lenSq = c2 * c2 + d2 * d2;
    let param = -1;
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x22;
      yy = y22;
    } else {
      xx = x1 + param * c2;
      yy = y1 + param * d2;
    }
    const dx = x2 - xx;
    const dy = y2 - yy;
    return dx * dx + dy * dy;
  }
  var init_squaredDistanceToLineSegment = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
  var Polygon;
  var init_Polygon = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
      init_squaredDistanceToLineSegment();
      init_Rectangle();
      Polygon = class {
        /**
         * @param points - This can be an array of Points
         *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
         *  the arguments passed can be all the points of the polygon e.g.
         *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
         *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
         */
        constructor(...points) {
          this.type = "polygon";
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] !== "number") {
            const p3 = [];
            for (let i3 = 0, il = flat.length; i3 < il; i3++) {
              p3.push(flat[i3].x, flat[i3].y);
            }
            flat = p3;
          }
          this.points = flat;
          this.closePath = true;
        }
        /**
         * Creates a clone of this polygon.
         * @returns - A copy of the polygon.
         */
        clone() {
          const points = this.points.slice();
          const polygon = new Polygon(points);
          polygon.closePath = this.closePath;
          return polygon;
        }
        /**
         * Checks whether the x and y coordinates passed to this function are contained within this polygon.
         * @param x - The X coordinate of the point to test.
         * @param y - The Y coordinate of the point to test.
         * @returns - Whether the x/y coordinates are within this polygon.
         */
        contains(x2, y2) {
          let inside = false;
          const length = this.points.length / 2;
          for (let i3 = 0, j2 = length - 1; i3 < length; j2 = i3++) {
            const xi = this.points[i3 * 2];
            const yi = this.points[i3 * 2 + 1];
            const xj = this.points[j2 * 2];
            const yj = this.points[j2 * 2 + 1];
            const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
            if (intersect) {
              inside = !inside;
            }
          }
          return inside;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this polygon
         */
        strokeContains(x2, y2, strokeWidth) {
          const halfStrokeWidth = strokeWidth / 2;
          const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
          const { points } = this;
          const iterationLength = points.length - (this.closePath ? 0 : 2);
          for (let i3 = 0; i3 < iterationLength; i3 += 2) {
            const x1 = points[i3];
            const y1 = points[i3 + 1];
            const x22 = points[(i3 + 2) % points.length];
            const y22 = points[(i3 + 3) % points.length];
            const distanceSqrd = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
            if (distanceSqrd <= halfStrokeWidthSqrd) {
              return true;
            }
          }
          return false;
        }
        /**
         * Returns the framing rectangle of the polygon as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          const points = this.points;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (let i3 = 0, n2 = points.length; i3 < n2; i3 += 2) {
            const x2 = points[i3];
            const y2 = points[i3 + 1];
            minX = x2 < minX ? x2 : minX;
            maxX = x2 > maxX ? x2 : maxX;
            minY = y2 < minY ? y2 : minY;
            maxY = y2 > maxY ? y2 : maxY;
          }
          out2.x = minX;
          out2.width = maxX - minX;
          out2.y = minY;
          out2.height = maxY - minY;
          return out2;
        }
        /**
         * Copies another polygon to this one.
         * @param polygon - The polygon to copy from.
         * @returns Returns itself.
         */
        copyFrom(polygon) {
          this.points = polygon.points.slice();
          this.closePath = polygon.closePath;
          return this;
        }
        /**
         * Copies this polygon to another one.
         * @param polygon - The polygon to copy to.
         * @returns Returns given parameter.
         */
        copyTo(polygon) {
          polygon.copyFrom(this);
          return polygon;
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
        }
        /**
         * Get the last X coordinate of the polygon
         * @readonly
         */
        get lastX() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the last Y coordinate of the polygon
         * @readonly
         */
        get lastY() {
          return this.points[this.points.length - 1];
        }
        /**
         * Get the first X coordinate of the polygon
         * @readonly
         */
        get x() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the first Y coordinate of the polygon
         * @readonly
         */
        get y() {
          return this.points[this.points.length - 1];
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
  var isCornerWithinStroke, RoundedRectangle;
  var init_RoundedRectangle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
      init_Rectangle();
      isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {
        const dx = pX - cornerX;
        const dy = pY - cornerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;
      };
      RoundedRectangle = class {
        /**
         * @param x - The X coordinate of the upper-left corner of the rounded rectangle
         * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
         * @param width - The overall width of this rounded rectangle
         * @param height - The overall height of this rounded rectangle
         * @param radius - Controls the radius of the rounded corners
         */
        constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
          this.type = "roundedRectangle";
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
          this.radius = radius;
        }
        /**
         * Returns the framing rectangle of the rounded rectangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x;
          out2.y = this.y;
          out2.width = this.width;
          out2.height = this.height;
          return out2;
        }
        /**
         * Creates a clone of this Rounded Rectangle.
         * @returns - A copy of the rounded rectangle.
         */
        clone() {
          return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        }
        /**
         * Copies another rectangle to this one.
         * @param rectangle - The rectangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @param rectangle - The rectangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
         * @param x - The X coordinate of the point to test.
         * @param y - The Y coordinate of the point to test.
         * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 <= this.x + this.width) {
            if (y2 >= this.y && y2 <= this.y + this.height) {
              const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
              if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
                return true;
              }
              let dx = x2 - (this.x + radius);
              let dy = y2 - (this.y + radius);
              const radius2 = radius * radius;
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + this.width - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y2 - (this.y + this.height - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @param pX - The X coordinate of the point to test
         * @param pY - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this rectangle
         */
        strokeContains(pX, pY, strokeWidth) {
          const { x: x2, y: y2, width, height, radius } = this;
          const halfStrokeWidth = strokeWidth / 2;
          const innerX = x2 + radius;
          const innerY = y2 + radius;
          const innerWidth = width - radius * 2;
          const innerHeight = height - radius * 2;
          const rightBound = x2 + width;
          const bottomBound = y2 + height;
          if ((pX >= x2 - halfStrokeWidth && pX <= x2 + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {
            return true;
          }
          if ((pY >= y2 - halfStrokeWidth && pY <= y2 + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {
            return true;
          }
          return (
            // Top-left
            pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)
          );
        }
        toString() {
          return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
  var init_buildAdaptiveBezier = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT = 8;
      FLT_EPSILON = 11920929e-14;
      PATH_DISTANCE_EPSILON = 1;
      curveAngleToleranceEpsilon = 0.01;
      mAngleTolerance = 0;
      mCuspLimit = 0;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
  var init_buildAdaptiveQuadratic = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT2 = 8;
      FLT_EPSILON2 = 11920929e-14;
      PATH_DISTANCE_EPSILON2 = 1;
      curveAngleToleranceEpsilon2 = 0.01;
      mAngleTolerance2 = 0;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
    steps = Math.max(steps, 3);
    let f2 = dist / steps;
    let t2 = start;
    f2 *= clockwise ? -1 : 1;
    for (let i3 = 0; i3 < steps + 1; i3++) {
      const cs = Math.cos(t2);
      const sn = Math.sin(t2);
      const nx = x2 + cs * radius;
      const ny = y2 + sn * radius;
      points.push(nx, ny);
      t2 += f2;
    }
  }
  var init_buildArc = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }
  var init_buildArcTo = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
      init_buildArc();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i3 = 0; i3 < segments; i3++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      );
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }
  var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
  var init_buildArcToSvg = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
      init_buildAdaptiveBezier();
      TAU = Math.PI * 2;
      out = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
      };
      mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
        x2 *= rx;
        y2 *= ry;
        const xp = cosPhi * x2 - sinPhi * y2;
        const yp = sinPhi * x2 + cosPhi * y2;
        out2.x = xp + centerX;
        out2.y = yp + centerY;
        return out2;
      };
      vectorAngle = (ux2, uy2, vx2, vy2) => {
        const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
        let dot = ux2 * vx2 + uy2 * vy2;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign * Math.acos(dot);
      };
      getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
        const rxSq = Math.pow(rx, 2);
        const rySq = Math.pow(ry, 2);
        const pxpSq = Math.pow(pxp, 2);
        const pypSq = Math.pow(pyp, 2);
        let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxSq * pypSq + rySq * pxpSq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        const centerXp = radicant * rx / ry * pyp;
        const centerYp = radicant * -ry / rx * pxp;
        const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
        const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
        const vx1 = (pxp - centerXp) / rx;
        const vy1 = (pyp - centerYp) / ry;
        const vx2 = (-pxp - centerXp) / rx;
        const vy2 = (-pyp - centerYp) / ry;
        const ang1 = vectorAngle(1, 0, vx1, vy1);
        let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        out2.centerX = centerX;
        out2.centerY = centerY;
        out2.ang1 = ang1;
        out2.ang2 = ang2;
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
  function roundedShapeArc(g2, points, radius) {
    const vecFrom = (p3, pp) => {
      const x2 = pp.x - p3.x;
      const y2 = pp.y - p3.y;
      const len = Math.sqrt(x2 * x2 + y2 * y2);
      const nx = x2 / len;
      const ny = y2 / len;
      return { len, nx, ny };
    };
    const sharpCorner = (i3, p3) => {
      if (i3 === 0) {
        g2.moveTo(p3.x, p3.y);
      } else {
        g2.lineTo(p3.x, p3.y);
      }
    };
    let p1 = points[points.length - 1];
    for (let i3 = 0; i3 < points.length; i3++) {
      const p22 = points[i3 % points.length];
      const pRadius = p22.radius ?? radius;
      if (pRadius <= 0) {
        sharpCorner(i3, p22);
        p1 = p22;
        continue;
      }
      const p3 = points[(i3 + 1) % points.length];
      const v1 = vecFrom(p22, p1);
      const v2 = vecFrom(p22, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i3, p22);
        p1 = p22;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(
        Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
      );
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p22.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p22.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i3 === 0) {
        g2.moveTo(
          cX + Math.cos(startAngle) * cRadius,
          cY + Math.sin(startAngle) * cRadius
        );
      }
      g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p22;
    }
  }
  function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
    const distance = (p1, p22) => Math.sqrt((p1.x - p22.x) ** 2 + (p1.y - p22.y) ** 2);
    const pointLerp = (p1, p22, t2) => ({
      x: p1.x + (p22.x - p1.x) * t2,
      y: p1.y + (p22.y - p1.y) * t2
    });
    const numPoints = points.length;
    for (let i3 = 0; i3 < numPoints; i3++) {
      const thisPoint = points[(i3 + 1) % numPoints];
      const pRadius = thisPoint.radius ?? radius;
      if (pRadius <= 0) {
        if (i3 === 0) {
          g2.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g2.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i3];
      const nextPoint = points[(i3 + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start;
      if (lastEdgeLength < 1e-4) {
        start = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start = pointLerp(
          thisPoint,
          lastPoint,
          lastOffsetDistance / lastEdgeLength
        );
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(
          thisPoint,
          nextPoint,
          nextOffsetDistance / nextEdgeLength
        );
      }
      if (i3 === 0) {
        g2.moveTo(start.x, start.y);
      } else {
        g2.lineTo(start.x, start.y);
      }
      g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }
  var init_roundShape = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle, ShapePath;
  var init_ShapePath = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_Bounds();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      init_roundShape();
      tempRectangle = new Rectangle();
      ShapePath = class {
        constructor(graphicsPath2D) {
          this.shapePrimitives = [];
          this._currentPoly = null;
          this._bounds = new Bounds();
          this._graphicsPath2D = graphicsPath2D;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this.startPoly(x2, y2);
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          const fromX = points[points.length - 2];
          const fromY = points[points.length - 1];
          if (fromX !== x2 || fromY !== y2) {
            points.push(x2, y2);
          }
          return this;
        }
        /**
         * Adds an arc to the path. The arc is centered at (x, y)
         *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The radius of the arc.
         * @param startAngle - The starting angle of the arc, in radians.
         * @param endAngle - The ending angle of the arc, in radians.
         * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
         * @returns The instance of the current object for chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._ensurePoly(false);
          const points = this._currentPoly.points;
          buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
          return this;
        }
        /**
         * Adds an arc to the path with the arc tangent to the line joining two specified points.
         * The arc radius is specified by `radius`.
         * @param x1 - The x-coordinate of the first point.
         * @param y1 - The y-coordinate of the first point.
         * @param x2 - The x-coordinate of the second point.
         * @param y2 - The y-coordinate of the second point.
         * @param radius - The radius of the arc.
         * @returns The instance of the current object for chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          buildArcTo(points, x1, y1, x2, y2, radius);
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          const points = this._currentPoly.points;
          buildArcToSvg(
            points,
            this._currentPoly.lastX,
            this._currentPoly.lastY,
            x2,
            y2,
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveBezier(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            cp2x,
            cp2y,
            x2,
            y2,
            smoothness
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the control point.
         * @param cp1y - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothing - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveQuadratic(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            x2,
            y2,
            smoothing
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.endPoly(true);
          return this;
        }
        /**
         * Adds another path to the current path. This method allows for the combination of multiple paths into one.
         * @param path - The `GraphicsPath` object representing the path to add.
         * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          this.endPoly();
          if (transform2 && !transform2.isIdentity()) {
            path2 = path2.clone(true);
            path2.transform(transform2);
          }
          for (let i3 = 0; i3 < path2.instructions.length; i3++) {
            const instruction = path2.instructions[i3];
            this[instruction.action](...instruction.data);
          }
          return this;
        }
        /**
         * Finalizes the drawing of the current path. Optionally, it can close the path.
         * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
         */
        finish(closePath = false) {
          this.endPoly(closePath);
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.drawShape(new Rectangle(x2, y2, w2, h2), transform2);
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.drawShape(new Circle(x2, y2, radius), transform2);
          return this;
        }
        /**
         * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
         * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        poly(points, close, transform2) {
          const polygon = new Polygon(points);
          polygon.closePath = close;
          this.drawShape(polygon, transform2);
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          sides = Math.max(sides | 0, 3);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const polygon = [];
          for (let i3 = 0; i3 < sides; i3++) {
            const angle = i3 * delta + startAngle;
            polygon.push(
              x2 + radius * Math.cos(angle),
              y2 + radius * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
          sides = Math.max(sides | 0, 3);
          if (corner <= 0) {
            return this.regularPoly(x2, y2, radius, sides, rotation);
          }
          const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
          corner = Math.min(corner, sideLength);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const internalAngle = (sides - 2) * Math.PI / sides / 2;
          for (let i3 = 0; i3 < sides; i3++) {
            const angle = i3 * delta + startAngle;
            const x0 = x2 + radius * Math.cos(angle);
            const y0 = y2 + radius * Math.sin(angle);
            const a1 = angle + Math.PI + internalAngle;
            const a2 = angle - Math.PI - internalAngle;
            const x1 = x0 + corner * Math.cos(a1);
            const y1 = y0 + corner * Math.sin(a1);
            const x3 = x0 + corner * Math.cos(a2);
            const y3 = y0 + corner * Math.sin(a2);
            if (i3 === 0) {
              this.moveTo(x1, y1);
            } else {
              this.lineTo(x1, y1);
            }
            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
          }
          return this.closePath();
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic = false, smoothness) {
          if (points.length < 3) {
            return this;
          }
          if (useQuadratic) {
            roundedShapeQuadraticCurve(this, points, radius, smoothness);
          } else {
            roundedShapeArc(this, points, radius);
          }
          return this.closePath();
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width, height, fillet) {
          if (fillet === 0) {
            return this.rect(x2, y2, width, height);
          }
          const maxFillet = Math.min(width, height) / 2;
          const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
          const right = x2 + width;
          const bottom = y2 + height;
          const dir = inset < 0 ? -inset : 0;
          const size = Math.abs(inset);
          return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          if (chamfer <= 0) {
            return this.rect(x2, y2, width, height);
          }
          const inset = Math.min(chamfer, Math.min(width, height) / 2);
          const right = x2 + width;
          const bottom = y2 + height;
          const points = [
            x2 + inset,
            y2,
            right - inset,
            y2,
            right,
            y2 + inset,
            right,
            bottom - inset,
            right - inset,
            bottom,
            x2 + inset,
            bottom,
            x2,
            bottom - inset,
            x2,
            y2 + inset
          ];
          for (let i3 = points.length - 1; i3 >= 2; i3 -= 2) {
            if (points[i3] === points[i3 - 2] && points[i3 - 1] === points[i3 - 3]) {
              points.splice(i3 - 1, 2);
            }
          }
          return this.poly(points, true, transform2);
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY, transform2) {
          this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform2);
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius, transform2) {
          this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform2);
          return this;
        }
        /**
         * Draws a given shape on the canvas.
         * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
         * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
         * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
         * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
         * scaling, and translations.
         * @returns The instance of the current object for chaining.
         */
        drawShape(shape, matrix) {
          this.endPoly();
          this.shapePrimitives.push({ shape, transform: matrix });
          return this;
        }
        /**
         * Starts a new polygon path from the specified starting point.
         * This method initializes a new polygon or ends the current one if it exists.
         * @param x - The x-coordinate of the starting point of the new polygon.
         * @param y - The y-coordinate of the starting point of the new polygon.
         * @returns The instance of the current object for chaining.
         */
        startPoly(x2, y2) {
          let currentPoly = this._currentPoly;
          if (currentPoly) {
            this.endPoly();
          }
          currentPoly = new Polygon();
          currentPoly.points.push(x2, y2);
          this._currentPoly = currentPoly;
          return this;
        }
        /**
         * Ends the current polygon path. If `closePath` is set to true,
         * the path is closed by connecting the last point to the first one.
         * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
         * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
         *  back to the starting point. False by default.
         * @returns The instance of the current object for chaining.
         */
        endPoly(closePath = false) {
          const shape = this._currentPoly;
          if (shape && shape.points.length > 2) {
            shape.closePath = closePath;
            this.shapePrimitives.push({ shape });
          }
          this._currentPoly = null;
          return this;
        }
        _ensurePoly(start = true) {
          if (this._currentPoly)
            return;
          this._currentPoly = new Polygon();
          if (start) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
              let lx = lastShape.shape.x;
              let ly = lastShape.shape.y;
              if (lastShape.transform && !lastShape.transform.isIdentity()) {
                const t2 = lastShape.transform;
                const tempX = lx;
                lx = t2.a * lx + t2.c * ly + t2.tx;
                ly = t2.b * tempX + t2.d * ly + t2.ty;
              }
              this._currentPoly.points.push(lx, ly);
            } else {
              this._currentPoly.points.push(0, 0);
            }
          }
        }
        /** Builds the path. */
        buildPath() {
          const path2 = this._graphicsPath2D;
          this.shapePrimitives.length = 0;
          this._currentPoly = null;
          for (let i3 = 0; i3 < path2.instructions.length; i3++) {
            const instruction = path2.instructions[i3];
            this[instruction.action](...instruction.data);
          }
          this.finish();
        }
        /** Gets the bounds of the path. */
        get bounds() {
          const bounds = this._bounds;
          bounds.clear();
          const shapePrimitives = this.shapePrimitives;
          for (let i3 = 0; i3 < shapePrimitives.length; i3++) {
            const shapePrimitive = shapePrimitives[i3];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
            if (shapePrimitive.transform) {
              bounds.addRect(boundsRect, shapePrimitive.transform);
            } else {
              bounds.addRect(boundsRect);
            }
          }
          return bounds;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
  function adjustTransform(currentMatrix, transform2) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform2);
    }
    return transform2.clone();
  }
  var GraphicsPath;
  var init_GraphicsPath = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
      init_Point();
      init_uid();
      init_warn();
      init_SVGToGraphicsPath();
      init_ShapePath();
      GraphicsPath = class {
        /**
         * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
         * @param instructions - An SVG path string or an array of `PathInstruction` objects.
         */
        constructor(instructions) {
          this.instructions = [];
          this.uid = uid("graphicsPath");
          this._dirty = true;
          if (typeof instructions === "string") {
            SVGToGraphicsPath(instructions, this);
          } else {
            this.instructions = instructions?.slice() ?? [];
          }
        }
        /**
         * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
         * @returns The `ShapePath` instance associated with this `GraphicsPath`.
         */
        get shapePath() {
          if (!this._shapePath) {
            this._shapePath = new ShapePath(this);
          }
          if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
          }
          return this._shapePath;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @param transform - An optional transformation to apply to the added path.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          path2 = path2.clone();
          this.instructions.push({ action: "addPath", data: [path2, transform2] });
          this._dirty = true;
          return this;
        }
        arc(...args) {
          this.instructions.push({ action: "arc", data: args });
          this._dirty = true;
          return this;
        }
        arcTo(...args) {
          this.instructions.push({ action: "arcTo", data: args });
          this._dirty = true;
          return this;
        }
        arcToSvg(...args) {
          this.instructions.push({ action: "arcToSvg", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveTo(...args) {
          this.instructions.push({ action: "bezierCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires two points: the second control point and the end point. The first control point is assumed to be
         * The starting point is the last point in the current path.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cp1x = 0;
          let cp1y = 0;
          if (!last || last.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
          } else {
            cp1x = last.data[2];
            cp1y = last.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
          }
          this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.instructions.push({ action: "closePath", data: [] });
          this._dirty = true;
          return this;
        }
        ellipse(...args) {
          this.instructions.push({ action: "ellipse", data: args });
          this._dirty = true;
          return this;
        }
        lineTo(...args) {
          this.instructions.push({ action: "lineTo", data: args });
          this._dirty = true;
          return this;
        }
        moveTo(...args) {
          this.instructions.push({ action: "moveTo", data: args });
          return this;
        }
        quadraticCurveTo(...args) {
          this.instructions.push({ action: "quadraticCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It uses the previous point as the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveToShort(x2, y2, smoothness) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cpx1 = 0;
          let cpy1 = 0;
          if (!last || last.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
          } else {
            cpx1 = last.data[0];
            cpy1 = last.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
          }
          this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform2] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.instructions.push({ action: "circle", data: [x2, y2, radius, transform2] });
          this._dirty = true;
          return this;
        }
        roundRect(...args) {
          this.instructions.push({ action: "roundRect", data: args });
          this._dirty = true;
          return this;
        }
        poly(...args) {
          this.instructions.push({ action: "poly", data: args });
          this._dirty = true;
          return this;
        }
        regularPoly(...args) {
          this.instructions.push({ action: "regularPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundPoly(...args) {
          this.instructions.push({ action: "roundPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundShape(...args) {
          this.instructions.push({ action: "roundShape", data: args });
          this._dirty = true;
          return this;
        }
        filletRect(...args) {
          this.instructions.push({ action: "filletRect", data: args });
          this._dirty = true;
          return this;
        }
        chamferRect(...args) {
          this.instructions.push({ action: "chamferRect", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @param transform - An optional `Matrix` object to apply a transformation to the star.
         * This can include rotations, scaling, and translations.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        // eslint-disable-next-line max-len
        star(x2, y2, points, radius, innerRadius, rotation, transform2) {
          innerRadius = innerRadius || radius / 2;
          const startAngle = -1 * Math.PI / 2 + rotation;
          const len = points * 2;
          const delta = Math.PI * 2 / len;
          const polygon = [];
          for (let i3 = 0; i3 < len; i3++) {
            const r2 = i3 % 2 ? innerRadius : radius;
            const angle = i3 * delta + startAngle;
            polygon.push(
              x2 + r2 * Math.cos(angle),
              y2 + r2 * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
         * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
         * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
         * do not affect the original `GraphicsPath` and vice versa.
         * @param deep - A boolean flag indicating whether the clone should be deep.
         * @returns A new `GraphicsPath` instance that is a clone of the current instance.
         */
        clone(deep = false) {
          const newGraphicsPath2D = new GraphicsPath();
          if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
          } else {
            for (let i3 = 0; i3 < this.instructions.length; i3++) {
              const instruction = this.instructions[i3];
              newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
            }
          }
          return newGraphicsPath2D;
        }
        clear() {
          this.instructions.length = 0;
          this._dirty = true;
          return this;
        }
        /**
         * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
         * This method enables the modification of the path's geometry according to the provided
         * transformation matrix, which can include translations, rotations, scaling, and skewing.
         *
         * Each drawing instruction in the path is updated to reflect the transformation,
         * ensuring the visual representation of the path is consistent with the applied matrix.
         *
         * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
         * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
         * allowing for fine-grained control over the path's appearance.
         * @param matrix - A `Matrix` object representing the transformation to apply.
         * @returns The instance of the current object for chaining further operations.
         */
        transform(matrix) {
          if (matrix.isIdentity())
            return this;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let x2 = 0;
          let y2 = 0;
          let cpx1 = 0;
          let cpy1 = 0;
          let cpx2 = 0;
          let cpy2 = 0;
          let rx = 0;
          let ry = 0;
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            const data = instruction.data;
            switch (instruction.action) {
              case "moveTo":
              case "lineTo":
                x2 = data[0];
                y2 = data[1];
                data[0] = a2 * x2 + c2 * y2 + tx;
                data[1] = b2 * x2 + d2 * y2 + ty;
                break;
              case "bezierCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                cpx2 = data[2];
                cpy2 = data[3];
                x2 = data[4];
                y2 = data[5];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * cpx2 + c2 * cpy2 + tx;
                data[3] = b2 * cpx2 + d2 * cpy2 + ty;
                data[4] = a2 * x2 + c2 * y2 + tx;
                data[5] = b2 * x2 + d2 * y2 + ty;
                break;
              case "quadraticCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                x2 = data[2];
                y2 = data[3];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * x2 + c2 * y2 + tx;
                data[3] = b2 * x2 + d2 * y2 + ty;
                break;
              case "arcToSvg":
                x2 = data[5];
                y2 = data[6];
                rx = data[0];
                ry = data[1];
                data[0] = a2 * rx + c2 * ry;
                data[1] = b2 * rx + d2 * ry;
                data[5] = a2 * x2 + c2 * y2 + tx;
                data[6] = b2 * x2 + d2 * y2 + ty;
                break;
              case "circle":
                data[4] = adjustTransform(data[3], matrix);
                break;
              case "rect":
                data[4] = adjustTransform(data[4], matrix);
                break;
              case "ellipse":
                data[8] = adjustTransform(data[8], matrix);
                break;
              case "roundRect":
                data[5] = adjustTransform(data[5], matrix);
                break;
              case "addPath":
                data[0].transform(matrix);
                break;
              case "poly":
                data[2] = adjustTransform(data[2], matrix);
                break;
              default:
                warn("unknown transform action", instruction.action);
                break;
            }
          }
          this._dirty = true;
          return this;
        }
        get bounds() {
          return this.shapePath.bounds;
        }
        /**
         * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
         * This method is useful for operations that depend on the path's current endpoint,
         * such as connecting subsequent shapes or paths. It supports various drawing instructions,
         * ensuring the last point's position is accurately determined regardless of the path's complexity.
         *
         * If the last instruction is a `closePath`, the method iterates backward through the instructions
         *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
         * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
         * the last point from the nested path.
         * @param out - A `Point` object where the last point's coordinates will be stored.
         * This object is modified directly to contain the result.
         * @returns The `Point` object containing the last point's coordinates.
         */
        getLastPoint(out2) {
          let index = this.instructions.length - 1;
          let lastInstruction = this.instructions[index];
          if (!lastInstruction) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          while (lastInstruction.action === "closePath") {
            index--;
            if (index < 0) {
              out2.x = 0;
              out2.y = 0;
              return out2;
            }
            lastInstruction = this.instructions[index];
          }
          switch (lastInstruction.action) {
            case "moveTo":
            case "lineTo":
              out2.x = lastInstruction.data[0];
              out2.y = lastInstruction.data[1];
              break;
            case "quadraticCurveTo":
              out2.x = lastInstruction.data[2];
              out2.y = lastInstruction.data[3];
              break;
            case "bezierCurveTo":
              out2.x = lastInstruction.data[4];
              out2.y = lastInstruction.data[5];
              break;
            case "arc":
            case "arcToSvg":
              out2.x = lastInstruction.data[5];
              out2.y = lastInstruction.data[6];
              break;
            case "addPath":
              lastInstruction.data[0].getLastPoint(out2);
              break;
          }
          return out2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      path: new GraphicsPath()
    };
    renderChildren(svg, session, null, null);
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
    if (f1 && fillStyle) {
      fillStyle = { ...fillStyle, ...f1 };
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = { ...strokeStyle, ...s1 };
    } else if (s1) {
      strokeStyle = s1;
    }
    session.context.fillStyle = fillStyle;
    session.context.strokeStyle = strokeStyle;
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width;
    let height;
    switch (svg.nodeName.toLowerCase()) {
      case "path":
        d2 = svg.getAttribute("d");
        graphicsPath = new GraphicsPath(d2);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "circle":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        r2 = parseFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "rect":
        x2 = parseFloatAttribute(svg, "x", 0);
        y2 = parseFloatAttribute(svg, "y", 0);
        width = parseFloatAttribute(svg, "width", 0);
        height = parseFloatAttribute(svg, "height", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width, height, rx || ry);
        } else {
          session.context.rect(x2, y2, width, height);
        }
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "ellipse":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "line":
        x1 = parseFloatAttribute(svg, "x1", 0);
        y1 = parseFloatAttribute(svg, "y1", 0);
        x22 = parseFloatAttribute(svg, "x2", 0);
        y22 = parseFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let i3 = 0; i3 < children.length; i3++) {
      renderChildren(children[i3], session, fillStyle, strokeStyle);
    }
  }
  function parseFloatAttribute(svg, id, defaultValue2) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue2;
  }
  function parseStyle(svg) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    let useFill = false;
    let useStroke = false;
    if (style) {
      const styleParts = style.split(";");
      for (let i3 = 0; i3 < styleParts.length; i3++) {
        const stylePart = styleParts[i3];
        const [key, value] = stylePart.split(":");
        switch (key) {
          case "stroke":
            if (value !== "none") {
              strokeStyle.color = Color.shared.setValue(value).toNumber();
              useStroke = true;
            }
            break;
          case "stroke-width":
            strokeStyle.width = Number(value);
            break;
          case "fill":
            if (value !== "none") {
              useFill = true;
              fillStyle.color = Color.shared.setValue(value).toNumber();
            }
            break;
          case "fill-opacity":
            fillStyle.alpha = Number(value);
            break;
          case "stroke-opacity":
            strokeStyle.alpha = Number(value);
            break;
          case "opacity":
            fillStyle.alpha = Number(value);
            strokeStyle.alpha = Number(value);
            break;
        }
      }
    } else {
      const stroke = svg.getAttribute("stroke");
      if (stroke && stroke !== "none") {
        useStroke = true;
        strokeStyle.color = Color.shared.setValue(stroke).toNumber();
        strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
      }
      const fill = svg.getAttribute("fill");
      if (fill && fill !== "none") {
        useFill = true;
        fillStyle.color = Color.shared.setValue(fill).toNumber();
      }
    }
    return {
      strokeStyle: useStroke ? strokeStyle : null,
      fillStyle: useFill ? fillStyle : null
    };
  }
  var init_SVGParser = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
      init_Color();
      init_GraphicsPath();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function isColorLike(value) {
    return Color.isColorLike(value);
  }
  function isFillPattern(value) {
    return value instanceof FillPattern;
  }
  function isFillGradient(value) {
    return value instanceof FillGradient;
  }
  function handleColorLike(fill, value, defaultStyle) {
    const temp = Color.shared.setValue(value ?? 0);
    fill.color = temp.toNumber();
    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill.texture = Texture.WHITE;
    return { ...defaultStyle, ...fill };
  }
  function handleFillPattern(fill, value, defaultStyle) {
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return { ...defaultStyle, ...fill };
  }
  function handleFillGradient(fill, value, defaultStyle) {
    value.buildLinearGradient();
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return { ...defaultStyle, ...fill };
  }
  function handleFillObject(value, defaultStyle) {
    const style = { ...defaultStyle, ...value };
    if (style.texture) {
      if (style.texture !== Texture.WHITE) {
        const m2 = style.matrix?.invert() || new Matrix();
        m2.translate(style.texture.frame.x, style.texture.frame.y);
        m2.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
        style.matrix = m2;
      }
      const sourceStyle = style.texture.source.style;
      if (sourceStyle.addressMode === "clamp-to-edge") {
        sourceStyle.addressMode = "repeat";
        sourceStyle.update();
      }
    }
    const color = Color.shared.setValue(style.color);
    style.alpha *= color.alpha;
    style.color = color.toNumber();
    style.matrix = style.matrix ? style.matrix.clone() : null;
    return style;
  }
  function toFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
      return null;
    }
    const fill = {};
    const objectStyle = value;
    if (isColorLike(value)) {
      return handleColorLike(fill, value, defaultStyle);
    } else if (isFillPattern(value)) {
      return handleFillPattern(fill, value, defaultStyle);
    } else if (isFillGradient(value)) {
      return handleFillGradient(fill, value, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
      return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
      return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
  }
  function toStrokeStyle(value, defaultStyle) {
    const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;
    const fill = toFillStyle(value, rest);
    if (!fill) {
      return null;
    }
    return {
      width,
      alignment,
      miterLimit,
      cap,
      join,
      ...fill
    };
  }
  var init_convertFillInputToFillStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
  var init_GraphicsContext = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
      init_eventemitter3();
      init_Color();
      init_Matrix();
      init_Point();
      init_Texture();
      init_uid();
      init_deprecation();
      init_Bounds();
      init_GraphicsPath();
      init_SVGParser();
      init_convertFillInputToFillStyle();
      tmpPoint = new Point();
      tempMatrix3 = new Matrix();
      _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.uid = uid("graphicsContext");
          this.dirty = true;
          this.batchMode = "auto";
          this.instructions = [];
          this._activePath = new GraphicsPath();
          this._transform = new Matrix();
          this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
          this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
          this._stateStack = [];
          this._tick = 0;
          this._bounds = new Bounds();
          this._boundsDirty = true;
        }
        /**
         * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
         * including the current drawing state, transformations, styles, and instructions.
         * @returns A new GraphicsContext instance with the same properties and state as this one.
         */
        clone() {
          const clone = new _GraphicsContext2();
          clone.batchMode = this.batchMode;
          clone.instructions = this.instructions.slice();
          clone._activePath = this._activePath.clone();
          clone._transform = this._transform.clone();
          clone._fillStyle = { ...this._fillStyle };
          clone._strokeStyle = { ...this._strokeStyle };
          clone._stateStack = this._stateStack.slice();
          clone._bounds = this._bounds.clone();
          clone._boundsDirty = true;
          return clone;
        }
        /**
         * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
         */
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(value) {
          this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
        }
        /**
         * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         */
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(value) {
          this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
        }
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
         *                or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(style) {
          this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
          return this;
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         *                or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(style) {
          this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
          return this;
        }
        texture(texture, tint, dx, dy, dw, dh) {
          this.instructions.push({
            action: "texture",
            data: {
              image: texture,
              dx: dx || 0,
              dy: dy || 0,
              dw: dw || texture.frame.width,
              dh: dh || texture.frame.height,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
            }
          });
          this.onUpdate();
          return this;
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          this._activePath = new GraphicsPath();
          return this;
        }
        fill(style, alpha) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style != null) {
            if (alpha !== void 0 && typeof style === "number") {
              deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
              style = { color: style, alpha };
            }
            this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
          }
          this.instructions.push({
            action: "fill",
            // TODO copy fill style!
            data: { style: this.fillStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        _initNextPathLocation() {
          const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
          this._activePath.clear();
          this._activePath.moveTo(x2, y2);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(style) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style != null) {
            this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
          }
          this.instructions.push({
            action: "stroke",
            // TODO copy fill style!
            data: { style: this.strokeStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        cut() {
          for (let i3 = 0; i3 < 2; i3++) {
            const lastInstruction = this.instructions[this.instructions.length - 1 - i3];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
              if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                if (lastInstruction.data.hole) {
                  lastInstruction.data.hole.addPath(holePath);
                } else {
                  lastInstruction.data.hole = holePath;
                  break;
                }
              }
            }
          }
          this._initNextPathLocation();
          return this;
        }
        /**
         * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
         * starting and ending angles, and direction.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The arc's radius.
         * @param startAngle - The starting angle, in radians.
         * @param endAngle - The ending angle, in radians.
         * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arc(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius,
            startAngle,
            endAngle,
            counterclockwise
          );
          return this;
        }
        /**
         * Adds an arc to the current path with the given control points and radius, connected to the previous point
         * by a straight line if necessary.
         * @param x1 - The x-coordinate of the first control point.
         * @param y1 - The y-coordinate of the first control point.
         * @param x2 - The x-coordinate of the second control point.
         * @param y2 - The y-coordinate of the second control point.
         * @param radius - The arc's radius.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcTo(
            t2.a * x1 + t2.c * y1 + t2.tx,
            t2.b * x1 + t2.d * y1 + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius
          );
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcToSvg(
            rx,
            ry,
            xAxisRotation,
            // should we rotate this with transform??
            largeArcFlag,
            sweepFlag,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.bezierCurveTo(
            t2.a * cp1x + t2.c * cp1y + t2.tx,
            t2.b * cp1x + t2.d * cp1y + t2.ty,
            t2.a * cp2x + t2.c * cp2y + t2.tx,
            t2.b * cp2x + t2.d * cp2y + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this._tick++;
          this._activePath?.closePath();
          return this;
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY) {
          this._tick++;
          this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius) {
          this._tick++;
          this._activePath.circle(x2, y2, radius, this._transform.clone());
          return this;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @returns The instance of the current object for chaining.
         */
        path(path2) {
          this._tick++;
          this._activePath.addPath(path2, this._transform.clone());
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.lineTo(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          const instructions = this._activePath.instructions;
          const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
          const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
          if (instructions.length === 1 && instructions[0].action === "moveTo") {
            instructions[0].data[0] = transformedX;
            instructions[0].data[1] = transformedY;
            return this;
          }
          this._activePath.moveTo(
            transformedX,
            transformedY
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cpx - The x-coordinate of the control point.
         * @param cpy - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.quadraticCurveTo(
            t2.a * cpx + t2.c * cpy + t2.tx,
            t2.b * cpx + t2.d * cpy + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2) {
          this._tick++;
          this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius) {
          this._tick++;
          this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
          return this;
        }
        /**
         * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
         * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
         * rotated, or translated as needed.
         * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates, of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         */
        poly(points, close) {
          this._tick++;
          this._activePath.poly(points, close, this._transform.clone());
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          this._tick++;
          this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation) {
          this._tick++;
          this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
          return this;
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic, smoothness) {
          this._tick++;
          this._activePath.roundShape(points, radius, useQuadratic, smoothness);
          return this;
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width, height, fillet) {
          this._tick++;
          this._activePath.filletRect(x2, y2, width, height, fillet);
          return this;
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          this._tick++;
          this._activePath.chamferRect(x2, y2, width, height, chamfer, transform2);
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
          this._tick++;
          this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
          return this;
        }
        /**
         * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
         * defined in SVG format to be drawn within the graphics context.
         * @param svg - The SVG string to be parsed and rendered.
         */
        svg(svg) {
          this._tick++;
          SVGParser(svg, this);
          return this;
        }
        /**
         * Restores the most recently saved graphics state by popping the top of the graphics state stack.
         * This includes transformations, fill styles, and stroke styles.
         */
        restore() {
          const state = this._stateStack.pop();
          if (state) {
            this._transform = state.transform;
            this._fillStyle = state.fillStyle;
            this._strokeStyle = state.strokeStyle;
          }
          return this;
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: { ...this._fillStyle },
            strokeStyle: { ...this._strokeStyle }
          });
          return this;
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this._transform;
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          this._transform.identity();
          return this;
        }
        /**
         * Applies a rotation transformation to the graphics context around the current origin.
         * @param angle - The angle of rotation in radians.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        rotate(angle) {
          this._transform.rotate(angle);
          return this;
        }
        /**
         * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
         * @param x - The scale factor in the horizontal direction.
         * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        scale(x2, y2 = x2) {
          this._transform.scale(x2, y2);
          return this;
        }
        setTransform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
            return this;
          }
          this._transform.set(a2, b2, c2, d2, dx, dy);
          return this;
        }
        transform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.append(a2);
            return this;
          }
          tempMatrix3.set(a2, b2, c2, d2, dx, dy);
          this._transform.append(tempMatrix3);
          return this;
        }
        /**
         * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
         * @param x - The amount to translate in the horizontal direction.
         * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        translate(x2, y2 = x2) {
          this._transform.translate(x2, y2);
          return this;
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          this._activePath.clear();
          this.instructions.length = 0;
          this.resetTransform();
          this.onUpdate();
          return this;
        }
        onUpdate() {
          if (this.dirty)
            return;
          this.emit("update", this, 16);
          this.dirty = true;
          this._boundsDirty = true;
        }
        /** The bounds of the graphic shape. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          const bounds = this._bounds;
          bounds.clear();
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            const action = instruction.action;
            if (action === "fill") {
              const data = instruction.data;
              bounds.addBounds(data.path.bounds);
            } else if (action === "texture") {
              const data = instruction.data;
              bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
            }
            if (action === "stroke") {
              const data = instruction.data;
              const padding = data.style.width / 2;
              const _bounds = data.path.bounds;
              bounds.addFrame(
                _bounds.minX - padding,
                _bounds.minY - padding,
                _bounds.maxX + padding,
                _bounds.maxY + padding
              );
            }
          }
          return bounds;
        }
        /**
         * Check to see if a point is contained within this geometry.
         * @param point - Point to check if it's contained.
         * @returns {boolean} `true` if the point is contained within geometry.
         */
        containsPoint(point) {
          if (!this.bounds.containsPoint(point.x, point.y))
            return false;
          const instructions = this.instructions;
          let hasHit = false;
          for (let k2 = 0; k2 < instructions.length; k2++) {
            const instruction = instructions[k2];
            const data = instruction.data;
            const path2 = data.path;
            if (!instruction.action || !path2)
              continue;
            const style = data.style;
            const shapes = path2.shapePath.shapePrimitives;
            for (let i3 = 0; i3 < shapes.length; i3++) {
              const shape = shapes[i3].shape;
              if (!style || !shape)
                continue;
              const transform2 = shapes[i3].transform;
              const transformedPoint = transform2 ? transform2.applyInverse(point, tmpPoint) : point;
              if (instruction.action === "fill") {
                hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
              } else {
                hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);
              }
              const holes = data.hole;
              if (holes) {
                const holeShapes = holes.shapePath?.shapePrimitives;
                if (holeShapes) {
                  for (let j2 = 0; j2 < holeShapes.length; j2++) {
                    if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                      hasHit = false;
                    }
                  }
                }
              }
              if (hasHit) {
                return true;
              }
            }
          }
          return hasHit;
        }
        /**
         * Destroys the GraphicsData object.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
         * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
         */
        destroy(options = false) {
          this._stateStack.length = 0;
          this._transform = null;
          this.emit("destroy", this);
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fillStyle.texture) {
              this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
              this._strokeStyle.texture.destroy(destroyTextureSource);
            }
          }
          this._fillStyle = null;
          this._strokeStyle = null;
          this.instructions = null;
          this._activePath = null;
          this._bounds = null;
          this._stateStack = null;
          this.customShader = null;
          this._transform = null;
        }
      };
      _GraphicsContext.defaultFillStyle = {
        /** The color to use for the fill. */
        color: 16777215,
        /** The alpha value to use for the fill. */
        alpha: 1,
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null
      };
      _GraphicsContext.defaultStrokeStyle = {
        /** The width of the stroke. */
        width: 1,
        /** The color to use for the stroke. */
        color: 16777215,
        /** The alpha value to use for the stroke. */
        alpha: 1,
        /** The alignment of the stroke. */
        alignment: 0.5,
        /** The miter limit to use. */
        miterLimit: 10,
        /** The line cap style to use. */
        cap: "butt",
        /** The line join style to use. */
        join: "miter",
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null
      };
      GraphicsContext = _GraphicsContext;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
  function generateTextStyleKey(style) {
    const key = [];
    let index = 0;
    for (let i3 = 0; i3 < valuesToIterateForKeys.length; i3++) {
      const prop = `_${valuesToIterateForKeys[i3]}`;
      key[index++] = style[prop];
    }
    index = addFillStyleKey(style._fill, key, index);
    index = addStokeStyleKey(style._stroke, key, index);
    index = addDropShadowKey(style.dropShadow, key, index);
    return key.join("-");
  }
  function addFillStyleKey(fillStyle, key, index) {
    if (!fillStyle)
      return index;
    key[index++] = fillStyle.color;
    key[index++] = fillStyle.alpha;
    key[index++] = fillStyle.fill?.styleKey;
    return index;
  }
  function addStokeStyleKey(strokeStyle, key, index) {
    if (!strokeStyle)
      return index;
    index = addFillStyleKey(strokeStyle, key, index);
    key[index++] = strokeStyle.width;
    key[index++] = strokeStyle.alignment;
    key[index++] = strokeStyle.cap;
    key[index++] = strokeStyle.join;
    key[index++] = strokeStyle.miterLimit;
    return index;
  }
  function addDropShadowKey(dropShadow, key, index) {
    if (!dropShadow)
      return index;
    key[index++] = dropShadow.alpha;
    key[index++] = dropShadow.angle;
    key[index++] = dropShadow.blur;
    key[index++] = dropShadow.distance;
    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();
    return index;
  }
  var valuesToIterateForKeys;
  var init_generateTextStyleKey = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
      init_Color();
      valuesToIterateForKeys = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize"
      ];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/TextStyle.mjs
  function convertV7Tov8Style(style) {
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
      const defaults2 = TextStyle.defaultDropShadow;
      style.dropShadow = {
        alpha: oldStyle.dropShadowAlpha ?? defaults2.alpha,
        angle: oldStyle.dropShadowAngle ?? defaults2.angle,
        blur: oldStyle.dropShadowBlur ?? defaults2.blur,
        color: oldStyle.dropShadowColor ?? defaults2.color,
        distance: oldStyle.dropShadowDistance ?? defaults2.distance
      };
    }
    if (oldStyle.strokeThickness !== void 0) {
      deprecation(v8_0_0, "strokeThickness is now a part of stroke");
      const color = oldStyle.stroke;
      let obj = {};
      if (Color.isColorLike(color)) {
        obj.color = color;
      } else if (color instanceof FillGradient || color instanceof FillPattern) {
        obj.fill = color;
      } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
        obj = color;
      } else {
        throw new Error("Invalid stroke value.");
      }
      style.stroke = {
        ...obj,
        width: oldStyle.strokeThickness
      };
    }
    if (Array.isArray(oldStyle.fillGradientStops)) {
      deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let fontSize;
      if (style.fontSize == null) {
        style.fontSize = TextStyle.defaultTextStyle.fontSize;
      } else if (typeof style.fontSize === "string") {
        fontSize = parseInt(style.fontSize, 10);
      } else {
        fontSize = style.fontSize;
      }
      const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);
      const fills = oldStyle.fillGradientStops.map((color) => Color.shared.setValue(color).toNumber());
      fills.forEach((number, index) => {
        const ratio = index / (fills.length - 1);
        gradientFill.addColorStop(ratio, number);
      });
      style.fill = {
        fill: gradientFill
      };
    }
  }
  var _TextStyle, TextStyle;
  var init_TextStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
      init_eventemitter3();
      init_Color();
      init_deprecation();
      init_FillGradient();
      init_FillPattern();
      init_GraphicsContext();
      init_convertFillInputToFillStyle();
      init_generateTextStyleKey();
      _TextStyle = class _TextStyle2 extends eventemitter3_default {
        constructor(style = {}) {
          super();
          convertV7Tov8Style(style);
          const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
          for (const key in fullStyle) {
            const thisKey = key;
            this[thisKey] = fullStyle[key];
          }
          this.update();
        }
        /**
         * Alignment for multiline text, does not affect single line text.
         * @member {'left'|'center'|'right'|'justify'}
         */
        get align() {
          return this._align;
        }
        set align(value) {
          this._align = value;
          this.update();
        }
        /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(value) {
          this._breakWords = value;
          this.update();
        }
        /** Set a drop shadow for the text. */
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(value) {
          if (value !== null && typeof value === "object") {
            this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value });
          } else {
            this._dropShadow = value ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
          }
          this.update();
        }
        /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          this._fontFamily = value;
          this.update();
        }
        /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (typeof value === "string") {
            this._fontSize = parseInt(value, 10);
          } else {
            this._fontSize = value;
          }
          this.update();
        }
        /**
         * The font style.
         * @member {'normal'|'italic'|'oblique'}
         */
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(value) {
          this._fontStyle = value.toLowerCase();
          this.update();
        }
        /**
         * The font variant.
         * @member {'normal'|'small-caps'}
         */
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(value) {
          this._fontVariant = value;
          this.update();
        }
        /**
         * The font weight.
         * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(value) {
          this._fontWeight = value;
          this.update();
        }
        /** The space between lines. */
        get leading() {
          return this._leading;
        }
        set leading(value) {
          this._leading = value;
          this.update();
        }
        /** The amount of spacing between letters, default is 0. */
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value) {
          this._letterSpacing = value;
          this.update();
        }
        /** The line height, a number that represents the vertical space that a letter uses. */
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          this._lineHeight = value;
          this.update();
        }
        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         */
        get padding() {
          return this._padding;
        }
        set padding(value) {
          this._padding = value;
          this.update();
        }
        /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
        get trim() {
          return this._trim;
        }
        set trim(value) {
          this._trim = value;
          this.update();
        }
        /**
         * The baseline of the text that is rendered.
         * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(value) {
          this._textBaseline = value;
          this.update();
        }
        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         * @member {'normal'|'pre'|'pre-line'}
         */
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(value) {
          this._whiteSpace = value;
          this.update();
        }
        /** Indicates if word wrap should be used. */
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(value) {
          this._wordWrap = value;
          this.update();
        }
        /** The width at which text will wrap, it needs wordWrap to be set to true. */
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(value) {
          this._wordWrapWidth = value;
          this.update();
        }
        /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
        get fill() {
          return this._originalFill;
        }
        set fill(value) {
          if (value === this._originalFill)
            return;
          this._originalFill = value;
          if (this._isFillStyle(value)) {
            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {
              this._fill = toFillStyle(
                { ...this._originalFill },
                GraphicsContext.defaultFillStyle
              );
            });
          }
          this._fill = toFillStyle(
            value === 0 ? "black" : value,
            GraphicsContext.defaultFillStyle
          );
          this.update();
        }
        /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
        get stroke() {
          return this._originalStroke;
        }
        set stroke(value) {
          if (value === this._originalStroke)
            return;
          this._originalStroke = value;
          if (this._isFillStyle(value)) {
            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {
              this._stroke = toStrokeStyle(
                { ...this._originalStroke },
                GraphicsContext.defaultStrokeStyle
              );
            });
          }
          this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
          this.update();
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this);
          return this._styleKey;
        }
        update() {
          this._styleKey = null;
          this.emit("update", this);
        }
        /** Resets all properties to the default values */
        reset() {
          const defaultStyle = _TextStyle2.defaultTextStyle;
          for (const key in defaultStyle) {
            this[key] = defaultStyle[key];
          }
        }
        get styleKey() {
          return this._styleKey || this._generateKey();
        }
        /**
         * Creates a new TextStyle object with the same values as this one.
         * @returns New cloned TextStyle object
         */
        clone() {
          return new _TextStyle2({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth
          });
        }
        /**
         * Destroys this text style.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
         */
        destroy(options = false) {
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fill?.texture) {
              this._fill.texture.destroy(destroyTextureSource);
            }
            if (this._originalFill?.texture) {
              this._originalFill.texture.destroy(destroyTextureSource);
            }
            if (this._stroke?.texture) {
              this._stroke.texture.destroy(destroyTextureSource);
            }
            if (this._originalStroke?.texture) {
              this._originalStroke.texture.destroy(destroyTextureSource);
            }
          }
          this._fill = null;
          this._stroke = null;
          this.dropShadow = null;
          this._originalStroke = null;
          this._originalFill = null;
        }
        _createProxy(value, cb) {
          return new Proxy(value, {
            set: (target, property, newValue) => {
              target[property] = newValue;
              cb?.(property, newValue);
              this.update();
              return true;
            }
          });
        }
        _isFillStyle(value) {
          return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
        }
      };
      _TextStyle.defaultDropShadow = {
        /** Set alpha for the drop shadow */
        alpha: 1,
        /** Set a angle of the drop shadow */
        angle: Math.PI / 6,
        /** Set a shadow blur radius */
        blur: 0,
        /** A fill style to be used on the  e.g., 'red', '#00FF00' */
        color: "black",
        /** Set a distance of the drop shadow */
        distance: 5
      };
      _TextStyle.defaultTextStyle = {
        /**
         * See {@link TextStyle.align}
         * @type {'left'|'center'|'right'|'justify'}
         */
        align: "left",
        /** See {@link TextStyle.breakWords} */
        breakWords: false,
        /** See {@link TextStyle.dropShadow} */
        dropShadow: null,
        /**
         * See {@link TextStyle.fill}
         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */
        fill: "black",
        /**
         * See {@link TextStyle.fontFamily}
         * @type {string|string[]}
         */
        fontFamily: "Arial",
        /**
         * See {@link TextStyle.fontSize}
         * @type {number|string}
         */
        fontSize: 26,
        /**
         * See {@link TextStyle.fontStyle}
         * @type {'normal'|'italic'|'oblique'}
         */
        fontStyle: "normal",
        /**
         * See {@link TextStyle.fontVariant}
         * @type {'normal'|'small-caps'}
         */
        fontVariant: "normal",
        /**
         * See {@link TextStyle.fontWeight}
         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        fontWeight: "normal",
        /** See {@link TextStyle.leading} */
        leading: 0,
        /** See {@link TextStyle.letterSpacing} */
        letterSpacing: 0,
        /** See {@link TextStyle.lineHeight} */
        lineHeight: 0,
        /** See {@link TextStyle.padding} */
        padding: 0,
        /**
         * See {@link TextStyle.stroke}
         * @type {string|number}
         */
        stroke: null,
        /**
         * See {@link TextStyle.textBaseline}
         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        textBaseline: "alphabetic",
        /** See {@link TextStyle.trim} */
        trim: false,
        /**
         * See {@link TextStyle.whiteSpace}
         * @type {'normal'|'pre'|'pre-line'}
         */
        whiteSpace: "pre",
        /** See {@link TextStyle.wordWrap} */
        wordWrap: false,
        /** See {@link TextStyle.wordWrapWidth} */
        wordWrapWidth: 100
      };
      TextStyle = _TextStyle;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
  function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds2;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      false
    );
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width / resolution;
    texture.frame.height = height / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
  }
  var tempBounds2;
  var init_getPo2TextureFromSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
      init_TexturePool();
      init_Bounds();
      tempBounds2 = new Bounds();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
      fontFamilies = style.fontFamily.split(",");
    }
    for (let i3 = fontFamilies.length - 1; i3 >= 0; i3--) {
      let fontFamily = fontFamilies[i3].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i3] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
  var genericFontFamilies;
  var init_fontStringFromTextStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
      "use strict";
      genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
  var init_CanvasTextMetrics = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
      init_adapter();
      init_fontStringFromTextStyle();
      contextSettings = {
        // TextMetrics requires getImageData readback for measuring fonts.
        willReadFrequently: true
      };
      _CanvasTextMetrics = class _CanvasTextMetrics2 {
        /**
         * Checking that we can use modern canvas 2D API.
         *
         * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
         * @see TextMetrics.experimentalLetterSpacing
         * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
         * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
         */
        static get experimentalLetterSpacingSupported() {
          let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
          if (result !== void 0) {
            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        /**
         * @param text - the text that was measured
         * @param style - the style that was measured
         * @param width - the measured width of the text
         * @param height - the measured height of the text
         * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
         * @param lineWidths - an array of the line widths for each line matched to `lines`
         * @param lineHeight - the measured line height for this style
         * @param maxLineWidth - the maximum line width for all measured lines
         * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
         */
        constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text;
          this.style = style;
          this.width = width;
          this.height = height;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }
        /**
         * Measures the supplied string of text and returns a Rectangle.
         * @param text - The text to measure.
         * @param style - The text style to use for measuring
         * @param canvas - optional specification of the canvas to use for measuring.
         * @param wordWrap
         * @returns Measured width and height of the text.
         */
        static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
          const textKey = `${text}:${style.styleKey}`;
          if (_CanvasTextMetrics2._measurementCache[textKey])
            return _CanvasTextMetrics2._measurementCache[textKey];
          const font = fontStringFromTextStyle(style);
          const fontProperties = _CanvasTextMetrics2.measureFont(font);
          if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
          }
          const context4 = _CanvasTextMetrics2.__context;
          context4.font = font;
          const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
          const lines = outputText.split(/(?:\r\n|\r|\n)/);
          const lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i3 = 0; i3 < lines.length; i3++) {
            const lineWidth = _CanvasTextMetrics2._measureText(lines[i3], style.letterSpacing, context4);
            lineWidths[i3] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          const strokeWidth = style._stroke?.width || 0;
          let width = maxLineWidth + strokeWidth;
          if (style.dropShadow) {
            width += style.dropShadow.distance;
          }
          const lineHeight = style.lineHeight || fontProperties.fontSize;
          let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
          if (style.dropShadow) {
            height += style.dropShadow.distance;
          }
          const measurements = new _CanvasTextMetrics2(
            text,
            style,
            width,
            height,
            lines,
            lineWidths,
            lineHeight + style.leading,
            maxLineWidth,
            fontProperties
          );
          return measurements;
        }
        static _measureText(text, letterSpacing, context4) {
          let useExperimentalLetterSpacing = false;
          if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics2.experimentalLetterSpacing) {
              context4.letterSpacing = `${letterSpacing}px`;
              context4.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context4.letterSpacing = "0px";
              context4.textLetterSpacing = "0px";
            }
          }
          const metrics = context4.measureText(text);
          let metricWidth = metrics.width;
          const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
          const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
          let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
          if (metricWidth > 0) {
            if (useExperimentalLetterSpacing) {
              metricWidth -= letterSpacing;
              boundsWidth -= letterSpacing;
            } else {
              const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
              metricWidth += val;
              boundsWidth += val;
            }
          }
          return Math.max(metricWidth, boundsWidth);
        }
        /**
         * Applies newlines to a string to have it optimally fit into the horizontal
         * bounds set by the Text object's wordWrapWidth property.
         * @param text - String to apply word wrapping to
         * @param style - the style to use when wrapping
         * @param canvas - optional specification of the canvas to use for measuring.
         * @returns New string with new lines applied where required
         */
        static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
          const context4 = canvas.getContext("2d", contextSettings);
          let width = 0;
          let line = "";
          let lines = "";
          const cache = /* @__PURE__ */ Object.create(null);
          const { letterSpacing, whiteSpace } = style;
          const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
          const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style.wordWrapWidth + letterSpacing;
          const tokens = _CanvasTextMetrics2._tokenize(text);
          for (let i3 = 0; i3 < tokens.length; i3++) {
            let token = tokens[i3];
            if (_CanvasTextMetrics2._isNewline(token)) {
              if (!collapseNewlines) {
                lines += _CanvasTextMetrics2._addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
              const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }
            const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context4);
            if (tokenWidth > wordWrapWidth) {
              if (line !== "") {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
                const characters = _CanvasTextMetrics2.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char = characters[j2];
                  let lastChar = char;
                  let k2 = 1;
                  while (characters[j2 + k2]) {
                    const nextChar = characters[j2 + k2];
                    if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                      char += nextChar;
                    } else {
                      break;
                    }
                    lastChar = nextChar;
                    k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context4);
                  if (characterWidth + width > wordWrapWidth) {
                    lines += _CanvasTextMetrics2._addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                  }
                  line += char;
                  width += characterWidth;
                }
              } else {
                if (line.length > 0) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  line = "";
                  width = 0;
                }
                const isLastToken = i3 === tokens.length - 1;
                lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
            } else {
              if (tokenWidth + width > wordWrapWidth) {
                canPrependSpaces = false;
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
                line += token;
                width += tokenWidth;
              }
            }
          }
          lines += _CanvasTextMetrics2._addLine(line, false);
          return lines;
        }
        /**
         * Convenience function for logging each line added during the wordWrap method.
         * @param line    - The line of text to add
         * @param newLine - Add new line character to end
         * @returns A formatted line
         */
        static _addLine(line, newLine = true) {
          line = _CanvasTextMetrics2._trimRight(line);
          line = newLine ? `${line}
` : line;
          return line;
        }
        /**
         * Gets & sets the widths of calculated characters in a cache object
         * @param key            - The key
         * @param letterSpacing  - The letter spacing
         * @param cache          - The cache
         * @param context        - The canvas context
         * @returns The from cache.
         */
        static _getFromCache(key, letterSpacing, cache, context4) {
          let width = cache[key];
          if (typeof width !== "number") {
            width = _CanvasTextMetrics2._measureText(key, letterSpacing, context4) + letterSpacing;
            cache[key] = width;
          }
          return width;
        }
        /**
         * Determines whether we should collapse breaking spaces.
         * @param whiteSpace - The TextStyle property whiteSpace
         * @returns Should collapse
         */
        static _collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        /**
         * Determines whether we should collapse newLine chars.
         * @param whiteSpace - The white space
         * @returns should collapse
         */
        static _collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        /**
         * Trims breaking whitespaces from string.
         * @param text - The text
         * @returns Trimmed string
         */
        static _trimRight(text) {
          if (typeof text !== "string") {
            return "";
          }
          for (let i3 = text.length - 1; i3 >= 0; i3--) {
            const char = text[i3];
            if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
              break;
            }
            text = text.slice(0, -1);
          }
          return text;
        }
        /**
         * Determines if char is a newline.
         * @param char - The character
         * @returns True if newline, False otherwise.
         */
        static _isNewline(char) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
        }
        /**
         * Determines if char is a breaking whitespace.
         *
         * It allows one to determine whether char should be a breaking whitespace
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param char - The character
         * @param [_nextChar] - The next character
         * @returns True if whitespace, False otherwise.
         */
        static isBreakingSpace(char, _nextChar) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
        }
        /**
         * Splits a string into words, breaking-spaces and newLine characters
         * @param text - The text
         * @returns A tokenized array
         */
        static _tokenize(text) {
          const tokens = [];
          let token = "";
          if (typeof text !== "string") {
            return tokens;
          }
          for (let i3 = 0; i3 < text.length; i3++) {
            const char = text[i3];
            const nextChar = text[i3 + 1];
            if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }
              tokens.push(char);
              continue;
            }
            token += char;
          }
          if (token !== "") {
            tokens.push(token);
          }
          return tokens;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to customise which words should break
         * Examples are if the token is CJK or numbers.
         * It must return a boolean.
         * @param _token - The token
         * @param breakWords - The style attr break words
         * @returns Whether to break word or not
         */
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to determine whether a pair of characters
         * should be broken by newlines
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param _char - The character
         * @param _nextChar - The next character
         * @param _token - The token/word the characters are from
         * @param _index - The index in the token of the char
         * @param _breakWords - The style attr break words
         * @returns whether to break word or not
         */
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It is called when a token (usually a word) has to be split into separate pieces
         * in order to determine the point to break a word.
         * It must return an array of characters.
         * @param token - The token to split
         * @returns The characters of the token
         * @see CanvasTextMetrics.graphemeSegmenter
         */
        static wordWrapSplit(token) {
          return _CanvasTextMetrics2.graphemeSegmenter(token);
        }
        /**
         * Calculates the ascent, descent and fontSize of a given font-style
         * @param font - String representing the style of the font
         * @returns Font properties object
         */
        static measureFont(font) {
          if (_CanvasTextMetrics2._fonts[font]) {
            return _CanvasTextMetrics2._fonts[font];
          }
          const context4 = _CanvasTextMetrics2._context;
          context4.font = font;
          const metrics = context4.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
          const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
          };
          _CanvasTextMetrics2._fonts[font] = properties;
          return properties;
        }
        /**
         * Clear font metrics in metrics cache.
         * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
         */
        static clearMetrics(font = "") {
          if (font) {
            delete _CanvasTextMetrics2._fonts[font];
          } else {
            _CanvasTextMetrics2._fonts = {};
          }
        }
        /**
         * Cached canvas element for measuring text
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _canvas() {
          if (!_CanvasTextMetrics2.__canvas) {
            let canvas;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              const context4 = c2.getContext("2d", contextSettings);
              if (context4?.measureText) {
                _CanvasTextMetrics2.__canvas = c2;
                return c2;
              }
              canvas = DOMAdapter.get().createCanvas();
            } catch (ex) {
              canvas = DOMAdapter.get().createCanvas();
            }
            canvas.width = canvas.height = 10;
            _CanvasTextMetrics2.__canvas = canvas;
          }
          return _CanvasTextMetrics2.__canvas;
        }
        /**
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _context() {
          if (!_CanvasTextMetrics2.__context) {
            _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
          }
          return _CanvasTextMetrics2.__context;
        }
      };
      _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
      _CanvasTextMetrics.BASELINE_SYMBOL = "M";
      _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
      _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
      _CanvasTextMetrics.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter === "function") {
          const segmenter = new Intl.Segmenter();
          return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
        }
        return (s2) => [...s2];
      })();
      _CanvasTextMetrics.experimentalLetterSpacing = false;
      _CanvasTextMetrics._fonts = {};
      _CanvasTextMetrics._newlines = [
        10,
        // line feed
        13
        // carriage return
      ];
      _CanvasTextMetrics._breakingSpaces = [
        9,
        // character tabulation
        32,
        // space
        8192,
        // en quad
        8193,
        // em quad
        8194,
        // en space
        8195,
        // em space
        8196,
        // three-per-em space
        8197,
        // four-per-em space
        8198,
        // six-per-em space
        8200,
        // punctuation space
        8201,
        // thin space
        8202,
        // hair space
        8287,
        // medium mathematical space
        12288
        // ideographic space
      ];
      _CanvasTextMetrics._measurementCache = {};
      CanvasTextMetrics = _CanvasTextMetrics;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  function getCanvasFillStyle(fillStyle, context4) {
    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
      return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
    } else if (!fillStyle.fill) {
      const pattern = context4.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix7 = fillStyle.matrix.copyTo(Matrix.shared);
      tempMatrix7.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
      pattern.setTransform(tempMatrix7);
      return pattern;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern = context4.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix7 = fillPattern.transform.copyTo(Matrix.shared);
      tempMatrix7.scale(
        fillPattern.texture.frame.width,
        fillPattern.texture.frame.height
      );
      pattern.setTransform(tempMatrix7);
      return pattern;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      if (fillGradient.type === "linear") {
        const gradient = context4.createLinearGradient(
          fillGradient.x0,
          fillGradient.y0,
          fillGradient.x1,
          fillGradient.y1
        );
        fillGradient.gradientStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
        });
        return gradient;
      }
    }
    warn("FillStyle not recognised", fillStyle);
    return "red";
  }
  var init_getCanvasFillStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_warn();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem;
  var init_CanvasTextSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_pow2();
      init_CanvasPool();
      init_TexturePool();
      init_getCanvasBoundingBox();
      init_deprecation();
      init_TextStyle();
      init_getPo2TextureFromSource();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      CanvasTextSystem = class {
        constructor(_renderer) {
          this._activeTextures = {};
          this._renderer = _renderer;
        }
        getTextureSize(text, resolution, style) {
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          width = Math.ceil(width - 1e-6);
          height = Math.ceil(height - 1e-6);
          width = nextPow2(width);
          height = nextPow2(height);
          return { width, height };
        }
        getTexture(options, resolution, style, _textKey) {
          if (typeof options === "string") {
            deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
            options = {
              text: options,
              style,
              resolution
            };
          }
          if (!(options.style instanceof TextStyle)) {
            options.style = new TextStyle(options.style);
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(
            options
          );
          this._renderer.texture.initSource(texture._source);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return texture;
        }
        createTextureAndCanvas(options) {
          const { text, style } = options;
          const resolution = options.resolution ?? this._renderer.resolution;
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
          const { canvas } = canvasAndContext;
          this.renderTextToCanvas(text, style, resolution, canvasAndContext);
          const texture = getPo2TextureFromSource(canvas, width, height, resolution);
          if (style.trim) {
            const trimmed = getCanvasBoundingBox(canvas, resolution);
            texture.frame.copyFrom(trimmed);
            texture.updateUvs();
          }
          return { texture, canvasAndContext };
        }
        getManagedTexture(text) {
          text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          const textKey = text._getKey();
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(text);
          this._activeTextures[textKey] = {
            canvasAndContext,
            texture,
            usageCount: 1
          };
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
            TexturePool.returnTexture(activeTexture.texture);
            const source7 = activeTexture.texture.source;
            source7.resource = null;
            source7.uploadMethodId = "unknown";
            source7.alphaMode = "no-premultiply-alpha";
            this._activeTextures[textKey] = null;
          }
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        /**
         * Renders text to its canvas, and updates its texture.
         *
         * By default this is used internally to ensure the texture is correct before rendering,
         * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
         * and then shared across multiple Sprites.
         * @param text
         * @param style
         * @param resolution
         * @param canvasAndContext
         */
        renderTextToCanvas(text, style, resolution, canvasAndContext) {
          const { canvas, context: context4 } = canvasAndContext;
          const font = fontStringFromTextStyle(style);
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const lines = measured.lines;
          const lineHeight = measured.lineHeight;
          const lineWidths = measured.lineWidths;
          const maxLineWidth = measured.maxLineWidth;
          const fontProperties = measured.fontProperties;
          const height = canvas.height;
          context4.resetTransform();
          context4.scale(resolution, resolution);
          context4.textBaseline = style.textBaseline;
          if (style._stroke?.width) {
            const strokeStyle = style._stroke;
            context4.lineWidth = strokeStyle.width;
            context4.miterLimit = strokeStyle.miterLimit;
            context4.lineJoin = strokeStyle.join;
            context4.lineCap = strokeStyle.cap;
          }
          context4.font = font;
          let linePositionX;
          let linePositionY;
          const passesCount = style.dropShadow ? 2 : 1;
          for (let i3 = 0; i3 < passesCount; ++i3) {
            const isShadowPass = style.dropShadow && i3 === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
              context4.fillStyle = "black";
              context4.strokeStyle = "black";
              const shadowOptions = style.dropShadow;
              const dropShadowColor = shadowOptions.color;
              const dropShadowAlpha = shadowOptions.alpha;
              context4.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
              const dropShadowBlur = shadowOptions.blur * resolution;
              const dropShadowDistance = shadowOptions.distance * resolution;
              context4.shadowBlur = dropShadowBlur;
              context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
              context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
              context4.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context4) : null;
              if (style._stroke?.width) {
                context4.strokeStyle = getCanvasFillStyle(style._stroke, context4);
              }
              context4.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
              linePositionYShift = 0;
            }
            const strokeWidth = style._stroke?.width ?? 0;
            for (let i22 = 0; i22 < lines.length; i22++) {
              linePositionX = strokeWidth / 2;
              linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
              if (style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i22];
              } else if (style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
              }
              if (style._stroke?.width) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText,
                  true
                );
              }
              if (style._fill !== void 0) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText
                );
              }
            }
          }
        }
        /**
         * Render the text with letter-spacing.
         * @param text - The text to draw
         * @param style
         * @param canvasAndContext
         * @param x - Horizontal position to draw the text
         * @param y - Vertical position to draw the text
         * @param isStroke - Is this drawing for the outside stroke of the
         *  text? If not, it's for the inside fill
         */
        _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
          const { context: context4 } = canvasAndContext;
          const letterSpacing = style.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (CanvasTextMetrics.experimentalLetterSpacing) {
              context4.letterSpacing = `${letterSpacing}px`;
              context4.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context4.letterSpacing = "0px";
              context4.textLetterSpacing = "0px";
            }
          }
          if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
              context4.strokeText(text, x2, y2);
            } else {
              context4.fillText(text, x2, y2);
            }
            return;
          }
          let currentPosition = x2;
          const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
          let previousWidth = context4.measureText(text).width;
          let currentWidth = 0;
          for (let i3 = 0; i3 < stringArray.length; ++i3) {
            const currentChar = stringArray[i3];
            if (isStroke) {
              context4.strokeText(currentChar, currentPosition, y2);
            } else {
              context4.fillText(currentChar, currentPosition, y2);
            }
            let textStr = "";
            for (let j2 = i3 + 1; j2 < stringArray.length; ++j2) {
              textStr += stringArray[j2];
            }
            currentWidth = context4.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      CanvasTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "canvasText"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/init.mjs
  var init_init9 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/init.mjs"() {
      init_Extensions();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      extensions.add(CanvasTextSystem);
      extensions.add(CanvasTextPipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
  var Graphics;
  var init_Graphics = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
      init_deprecation();
      init_ViewContainer();
      init_GraphicsContext();
      Graphics = class extends ViewContainer {
        /**
         * @param options - Options for the Graphics.
         */
        constructor(options) {
          if (options instanceof GraphicsContext) {
            options = { context: options };
          }
          const { context: context4, roundPixels, ...rest } = options || {};
          super({
            label: "Graphics",
            ...rest
          });
          this.renderPipeId = "graphics";
          if (!context4) {
            this._context = this._ownedContext = new GraphicsContext();
          } else {
            this._context = context4;
          }
          this._context.on("update", this.onViewUpdate, this);
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
        }
        set context(context4) {
          if (context4 === this._context)
            return;
          this._context.off("update", this.onViewUpdate, this);
          this._context = context4;
          this._context.on("update", this.onViewUpdate, this);
          this.onViewUpdate();
        }
        get context() {
          return this._context;
        }
        /**
         * The local bounds of the graphic.
         * @type {rendering.Bounds}
         */
        get bounds() {
          return this._context.bounds;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          bounds.addBounds(this._context.bounds);
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          return this._context.containsPoint(point);
        }
        /**
         * Destroys this graphics renderable and optionally its context.
         * @param options - Options parameter. A boolean will act as if all options
         *
         * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
         * then the context will still be destroyed.
         *
         * If you want to explicitly not destroy this context that this graphics created,
         * then you should pass destroy({ context: false })
         *
         * If the context was passed in as an argument to the constructor then it will not be destroyed
         * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
         * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
         * @param {boolean} [options.context=false] - Should destroy the context
         */
        destroy(options) {
          if (this._ownedContext && !options) {
            this._ownedContext.destroy(options);
          } else if (options === true || options?.context === true) {
            this._context.destroy(options);
          }
          this._ownedContext = null;
          this._context = null;
          super.destroy(options);
        }
        _callContextMethod(method, args) {
          this.context[method](...args);
          return this;
        }
        // --------------------------------------- GraphicsContext methods ---------------------------------------
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
         * pattern object, or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(...args) {
          return this._callContextMethod("setFillStyle", args);
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         * or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(...args) {
          return this._callContextMethod("setStrokeStyle", args);
        }
        fill(...args) {
          return this._callContextMethod("fill", args);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
         * complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(...args) {
          return this._callContextMethod("stroke", args);
        }
        texture(...args) {
          return this._callContextMethod("texture", args);
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          return this._callContextMethod("beginPath", []);
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         */
        cut() {
          return this._callContextMethod("cut", []);
        }
        arc(...args) {
          return this._callContextMethod("arc", args);
        }
        arcTo(...args) {
          return this._callContextMethod("arcTo", args);
        }
        arcToSvg(...args) {
          return this._callContextMethod("arcToSvg", args);
        }
        bezierCurveTo(...args) {
          return this._callContextMethod("bezierCurveTo", args);
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          return this._callContextMethod("closePath", []);
        }
        ellipse(...args) {
          return this._callContextMethod("ellipse", args);
        }
        circle(...args) {
          return this._callContextMethod("circle", args);
        }
        path(...args) {
          return this._callContextMethod("path", args);
        }
        lineTo(...args) {
          return this._callContextMethod("lineTo", args);
        }
        moveTo(...args) {
          return this._callContextMethod("moveTo", args);
        }
        quadraticCurveTo(...args) {
          return this._callContextMethod("quadraticCurveTo", args);
        }
        rect(...args) {
          return this._callContextMethod("rect", args);
        }
        roundRect(...args) {
          return this._callContextMethod("roundRect", args);
        }
        poly(...args) {
          return this._callContextMethod("poly", args);
        }
        regularPoly(...args) {
          return this._callContextMethod("regularPoly", args);
        }
        roundPoly(...args) {
          return this._callContextMethod("roundPoly", args);
        }
        roundShape(...args) {
          return this._callContextMethod("roundShape", args);
        }
        filletRect(...args) {
          return this._callContextMethod("filletRect", args);
        }
        chamferRect(...args) {
          return this._callContextMethod("chamferRect", args);
        }
        star(...args) {
          return this._callContextMethod("star", args);
        }
        svg(...args) {
          return this._callContextMethod("svg", args);
        }
        restore(...args) {
          return this._callContextMethod("restore", args);
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          return this._callContextMethod("save", []);
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this.context.getTransform();
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing
         * any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...args) {
          return this._callContextMethod("rotate", args);
        }
        scaleTransform(...args) {
          return this._callContextMethod("scale", args);
        }
        setTransform(...args) {
          return this._callContextMethod("setTransform", args);
        }
        transform(...args) {
          return this._callContextMethod("transform", args);
        }
        translateTransform(...args) {
          return this._callContextMethod("translate", args);
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          return this._callContextMethod("clear", []);
        }
        /**
         * The fill style to use.
         * @type {ConvertedFillStyle}
         */
        get fillStyle() {
          return this._context.fillStyle;
        }
        set fillStyle(value) {
          this._context.fillStyle = value;
        }
        /**
         * The stroke style to use.
         * @type {ConvertedStrokeStyle}
         */
        get strokeStyle() {
          return this._context.strokeStyle;
        }
        set strokeStyle(value) {
          this._context.strokeStyle = value;
        }
        /**
         * Creates a new Graphics object.
         * Note that only the context of the object is cloned, not its transform (position,scale,etc)
         * @param deep - Whether to create a deep clone of the graphics object. If false, the context
         * will be shared between the two objects (default false). If true, the context will be
         * cloned (recommended if you need to modify the context in any way).
         * @returns - A clone of the graphics object
         */
        clone(deep = false) {
          if (deep) {
            return new Graphics(this._context.clone());
          }
          this._ownedContext = null;
          const clone = new Graphics(this._context);
          return clone;
        }
        // -------- v7 deprecations ---------
        /**
         * @param width
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
         */
        lineStyle(width, color, alpha) {
          deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
          const strokeStyle = {};
          width && (strokeStyle.width = width);
          color && (strokeStyle.color = color);
          alpha && (strokeStyle.alpha = alpha);
          this.context.strokeStyle = strokeStyle;
          return this;
        }
        /**
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        beginFill(color, alpha) {
          deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          const fillStyle = {};
          color && (fillStyle.color = color);
          alpha && (fillStyle.alpha = alpha);
          this.context.fillStyle = fillStyle;
          return this;
        }
        /**
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        endFill() {
          deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          this.context.fill();
          const strokeStyle = this.context.strokeStyle;
          if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
            this.context.stroke();
          }
          return this;
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
         */
        drawCircle(...args) {
          deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
          return this._callContextMethod("circle", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
         */
        drawEllipse(...args) {
          deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
          return this._callContextMethod("ellipse", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
         */
        drawPolygon(...args) {
          deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
          return this._callContextMethod("poly", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
         */
        drawRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
          return this._callContextMethod("rect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
         */
        drawRoundedRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
          return this._callContextMethod("roundRect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#star} instead
         */
        drawStar(...args) {
          deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
          return this._callContextMethod("star", args);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  var localUniformMSDFBit, localUniformMSDFBitGl;
  var init_localUniformMSDFBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
      "use strict";
      localUniformMSDFBit = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
          ),
          main: (
            /* wgsl */
            ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
          )
        }
      };
      localUniformMSDFBitGl = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform float uDistance;
         `
          ),
          main: (
            /* glsl */
            ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  var mSDFBit, mSDFBitGl;
  var init_mSDFBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
      "use strict";
      mSDFBit = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* wgsl */
            `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
          )
        }
      };
      mSDFBitGl = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* glsl */
            `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
  var gpuProgram, glProgram, SdfShader;
  var init_SdfShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
      init_Matrix();
      init_maxRecommendedTextures();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      init_localUniformMSDFBit();
      init_mSDFBit();
      SdfShader = class extends Shader {
        constructor() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures2 = getMaxTexturesPerBatch();
          gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
            name: "sdf-shader",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures2),
              localUniformMSDFBit,
              mSDFBit,
              roundPixelsBit
            ]
          }));
          glProgram ?? (glProgram = compileHighShaderGlProgram({
            name: "sdf-shader",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              localUniformMSDFBitGl,
              mSDFBitGl,
              roundPixelsBitGl
            ]
          }));
          super({
            glProgram,
            gpuProgram,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont;
  var init_AbstractBitmapFont = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
      init_eventemitter3();
      init_deprecation();
      AbstractBitmapFont = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.chars = /* @__PURE__ */ Object.create(null);
          this.lineHeight = 0;
          this.fontFamily = "";
          this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
          this.baseLineOffset = 0;
          this.distanceField = { type: "none", range: 0 };
          this.pages = [];
          this.applyFillAsTint = true;
          this.baseMeasurementFontSize = 100;
          this.baseRenderedFontSize = 100;
        }
        /**
         * The name of the font face.
         * @deprecated since 8.0.0 Use `fontFamily` instead.
         */
        get font() {
          deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
          return this.fontFamily;
        }
        /**
         * The map of base page textures (i.e., sheets of glyphs).
         * @deprecated since 8.0.0 Use `pages` instead.
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        /**
         * The size of the font face in pixels.
         * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
         */
        get size() {
          deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
          return this.fontMetrics.fontSize;
        }
        /**
         * The kind of distance field for this font or "none".
         * @deprecated since 8.0.0 Use `distanceField.type` instead.
         */
        get distanceFieldRange() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
          return this.distanceField.range;
        }
        /**
         * The range of the distance field in pixels.
         * @deprecated since 8.0.0 Use `distanceField.range` instead.
         */
        get distanceFieldType() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
          return this.distanceField.type;
        }
        destroy(destroyTextures = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          for (const i3 in this.chars) {
            this.chars[i3].texture?.destroy();
          }
          this.chars = null;
          if (destroyTextures) {
            this.pages.forEach((page) => page.texture.destroy(true));
            this.pages = null;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i3 = 0, j2 = chars.length; i3 < j2; i3++) {
      const item = chars[i3];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  var init_resolveCharacters = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
  var _DynamicBitmapFont, DynamicBitmapFont;
  var init_DynamicBitmapFont = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
      init_Color();
      init_Rectangle();
      init_CanvasPool();
      init_ImageSource();
      init_Texture();
      init_deprecation();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_TextStyle();
      init_AbstractBitmapFont();
      init_resolveCharacters();
      _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
        /**
         * @param options - The options for the dynamic bitmap font.
         */
        constructor(options) {
          super();
          this.resolution = 1;
          this.pages = [];
          this._padding = 0;
          this._measureCache = /* @__PURE__ */ Object.create(null);
          this._currentChars = [];
          this._currentX = 0;
          this._currentY = 0;
          this._currentPageIndex = -1;
          this._skipKerning = false;
          const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
          this._textureSize = dynamicOptions.textureSize;
          this._mipmap = dynamicOptions.mipmap;
          const style = dynamicOptions.style.clone();
          if (dynamicOptions.overrideFill) {
            style._fill.color = 16777215;
            style._fill.alpha = 1;
            style._fill.texture = Texture.WHITE;
            style._fill.fill = null;
          }
          this.applyFillAsTint = dynamicOptions.overrideFill;
          const requestedFontSize = style.fontSize;
          style.fontSize = this.baseMeasurementFontSize;
          const font = fontStringFromTextStyle(style);
          if (dynamicOptions.overrideSize) {
            if (style._stroke) {
              style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
            }
          } else {
            style.fontSize = this.baseRenderedFontSize = requestedFontSize;
          }
          this._style = style;
          this._skipKerning = dynamicOptions.skipKerning ?? false;
          this.resolution = dynamicOptions.resolution ?? 1;
          this._padding = dynamicOptions.padding ?? 4;
          this.fontMetrics = CanvasTextMetrics.measureFont(font);
          this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
        }
        ensureCharacters(chars) {
          const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
          if (!charList.length)
            return;
          this._currentChars = [...this._currentChars, ...charList];
          let pageData;
          if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
          } else {
            pageData = this.pages[this._currentPageIndex];
          }
          let { canvas, context: context4 } = pageData.canvasAndContext;
          let textureSource = pageData.texture.source;
          const style = this._style;
          let currentX = this._currentX;
          let currentY = this._currentY;
          const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
          const padding = this._padding * fontScale;
          let maxCharHeight = 0;
          let skipTexture = false;
          for (let i3 = 0; i3 < charList.length; i3++) {
            const char = charList[i3];
            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
            const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * metrics.width);
            metrics.lineHeight = metrics.height;
            const width = metrics.width * fontScale;
            const height = metrics.height * fontScale;
            const paddedWidth = textureGlyphWidth + padding * 2;
            const paddedHeight = height + padding * 2;
            skipTexture = false;
            if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
              skipTexture = true;
              maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
            }
            if (currentX + paddedWidth > this._textureSize) {
              currentY += maxCharHeight;
              maxCharHeight = paddedHeight;
              currentX = 0;
              if (currentY + maxCharHeight > this._textureSize) {
                textureSource.update();
                const pageData2 = this._nextPage();
                canvas = pageData2.canvasAndContext.canvas;
                context4 = pageData2.canvasAndContext.context;
                textureSource = pageData2.texture.source;
                currentY = 0;
              }
            }
            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
            this.chars[char] = {
              id: char.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance,
              kerning: {}
            };
            if (skipTexture) {
              this._drawGlyph(
                context4,
                metrics,
                currentX + padding,
                currentY + padding,
                fontScale,
                style
              );
              const px = textureSource.width * fontScale;
              const py = textureSource.height * fontScale;
              const frame = new Rectangle(
                currentX / px * textureSource.width,
                currentY / py * textureSource.height,
                paddedWidth / px * textureSource.width,
                paddedHeight / py * textureSource.height
              );
              this.chars[char].texture = new Texture({
                source: textureSource,
                frame
              });
              currentX += Math.ceil(paddedWidth);
            }
          }
          textureSource.update();
          this._currentX = currentX;
          this._currentY = currentY;
          this._skipKerning && this._applyKerning(charList, context4);
        }
        /**
         * @deprecated since 8.0.0
         * The map of base page textures (i.e., sheets of glyphs).
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        _applyKerning(newChars, context4) {
          const measureCache = this._measureCache;
          for (let i3 = 0; i3 < newChars.length; i3++) {
            const first = newChars[i3];
            for (let j2 = 0; j2 < this._currentChars.length; j2++) {
              const second = this._currentChars[j2];
              let c1 = measureCache[first];
              if (!c1)
                c1 = measureCache[first] = context4.measureText(first).width;
              let c2 = measureCache[second];
              if (!c2)
                c2 = measureCache[second] = context4.measureText(second).width;
              let total = context4.measureText(first + second).width;
              let amount = total - (c1 + c2);
              if (amount) {
                this.chars[first].kerning[second] = amount;
              }
              total = context4.measureText(first + second).width;
              amount = total - (c1 + c2);
              if (amount) {
                this.chars[second].kerning[first] = amount;
              }
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++;
          const textureResolution = this.resolution;
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
            this._textureSize,
            this._textureSize,
            textureResolution
          );
          this._setupContext(canvasAndContext.context, this._style, textureResolution);
          const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
          const texture = new Texture({
            source: new ImageSource({
              resource: canvasAndContext.canvas,
              resolution,
              alphaMode: "premultiply-alpha-on-upload",
              autoGenerateMipmaps: this._mipmap
            })
          });
          const pageData = {
            canvasAndContext,
            texture
          };
          this.pages[this._currentPageIndex] = pageData;
          return pageData;
        }
        // canvas style!
        _setupContext(context4, style, resolution) {
          style.fontSize = this.baseRenderedFontSize;
          context4.scale(resolution, resolution);
          context4.font = fontStringFromTextStyle(style);
          style.fontSize = this.baseMeasurementFontSize;
          context4.textBaseline = style.textBaseline;
          const stroke = style._stroke;
          const strokeThickness = stroke?.width ?? 0;
          if (stroke) {
            context4.lineWidth = strokeThickness;
            context4.lineJoin = stroke.join;
            context4.miterLimit = stroke.miterLimit;
            context4.strokeStyle = getCanvasFillStyle(stroke, context4);
          }
          if (style._fill) {
            context4.fillStyle = getCanvasFillStyle(style._fill, context4);
          }
          if (style.dropShadow) {
            const shadowOptions = style.dropShadow;
            const rgb = Color.shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context4.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context4.shadowBlur = dropShadowBlur;
            context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
          } else {
            context4.shadowColor = "black";
            context4.shadowBlur = 0;
            context4.shadowOffsetX = 0;
            context4.shadowOffsetY = 0;
          }
        }
        _drawGlyph(context4, metrics, x2, y2, fontScale, style) {
          const char = metrics.text;
          const fontProperties = metrics.fontProperties;
          const stroke = style._stroke;
          const strokeThickness = (stroke?.width ?? 0) * fontScale;
          const tx = x2 + strokeThickness / 2;
          const ty = y2 - strokeThickness / 2;
          const descent = fontProperties.descent * fontScale;
          const lineHeight = metrics.lineHeight * fontScale;
          if (style.stroke && strokeThickness) {
            context4.strokeText(char, tx, ty + lineHeight - descent);
          }
          if (style._fill) {
            context4.fillText(char, tx, ty + lineHeight - descent);
          }
        }
        destroy() {
          super.destroy();
          for (let i3 = 0; i3 < this.pages.length; i3++) {
            const { canvasAndContext, texture } = this.pages[i3];
            CanvasPool.returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
      _DynamicBitmapFont.defaultOptions = {
        textureSize: 512,
        style: new TextStyle(),
        mipmap: true
      };
      DynamicBitmapFont = _DynamicBitmapFont;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
  function getBitmapTextLayout(chars, style, font, trimEnd) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      // use index to not modify the array as we use it a lot!
      positions: [],
      chars: []
    };
    const nextWord = (word) => {
      const start = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index = currentLine.chars.length - 1;
      if (trimEnd) {
        let lastChar = currentLine.chars[index];
        while (lastChar === " ") {
          currentLine.width -= font.chars[lastChar].xAdvance;
          lastChar = currentLine.chars[--index];
        }
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += font.lineHeight;
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    for (let i3 = 0; i3 < chars.length + 1; i3++) {
      let char;
      const isEnd = i3 === chars.length;
      if (!isEnd) {
        char = chars[i3];
      }
      const charData = font.chars[char] || font.chars[" "];
      const isSpace = /(?:\s)/.test(char);
      const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char === "\r" || char === "\n") {
          if (currentLine.width !== 0) {
            nextLine();
          }
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char);
        currentWord.width += nextCharWidth;
      }
      previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
      alignCenter(layoutData);
    } else if (style.align === "right") {
      alignRight(layoutData);
    } else if (style.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
      const line = measurementData.lines[i3];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
      const line = measurementData.lines[i3];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
      const line = measurementData.lines[i3];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }
  var init_getBitmapTextLayout = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
  var fontCount, BitmapFontManagerClass, BitmapFontManager;
  var init_BitmapFontManager = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
      init_Cache();
      init_deprecation();
      init_warn();
      init_TextStyle();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters();
      fontCount = 0;
      BitmapFontManagerClass = class {
        constructor() {
          this.ALPHA = [["a", "z"], ["A", "Z"], " "];
          this.NUMERIC = [["0", "9"]];
          this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
          this.ASCII = [[" ", "~"]];
          this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false
          };
        }
        /**
         * Get a font for the specified text and style.
         * @param text - The text to get the font for
         * @param style - The style to use
         */
        getFont(text, style) {
          let fontFamilyKey = `${style.fontFamily}-bitmap`;
          let overrideFill = true;
          if (style._fill.fill && !style._stroke) {
            fontFamilyKey += style._fill.fill.styleKey;
            overrideFill = false;
          } else if (style._stroke || style.dropShadow) {
            let key = style.styleKey;
            key = key.substring(0, key.lastIndexOf("-"));
            fontFamilyKey = `${key}-bitmap`;
            overrideFill = false;
          }
          if (!Cache.has(fontFamilyKey)) {
            const fnt = new DynamicBitmapFont({
              style,
              overrideFill,
              overrideSize: true,
              ...this.defaultOptions
            });
            fontCount++;
            if (fontCount > 50) {
              warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
            }
            fnt.once("destroy", () => {
              fontCount--;
              Cache.remove(fontFamilyKey);
            });
            Cache.set(
              fontFamilyKey,
              fnt
            );
          }
          const dynamicFont = Cache.get(fontFamilyKey);
          dynamicFont.ensureCharacters?.(text);
          return dynamicFont;
        }
        /**
         * Get the layout of a text for the specified style.
         * @param text - The text to get the layout for
         * @param style - The style to use
         * @param trimEnd - Whether to ignore whitespaces at the end of each line
         */
        getLayout(text, style, trimEnd = true) {
          const bitmapFont = this.getFont(text, style);
          return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);
        }
        /**
         * Measure the text using the specified style.
         * @param text - The text to measure
         * @param style - The style to use
         * @param trimEnd - Whether to ignore whitespaces at the end of each line
         */
        measureText(text, style, trimEnd = true) {
          return this.getLayout(text, style, trimEnd);
        }
        // eslint-disable-next-line max-len
        install(...args) {
          let options = args[0];
          if (typeof options === "string") {
            options = {
              name: options,
              style: args[1],
              chars: args[2]?.chars,
              resolution: args[2]?.resolution,
              padding: args[2]?.padding,
              skipKerning: args[2]?.skipKerning
            };
            deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
          }
          const name = options?.name;
          if (!name) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
          }
          options = { ...this.defaultOptions, ...options };
          const textStyle = options.style;
          const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
          const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
          const font = new DynamicBitmapFont({
            style,
            overrideFill,
            skipKerning: options.skipKerning,
            padding: options.padding,
            resolution: options.resolution,
            overrideSize: false
          });
          const flatChars = resolveCharacters(options.chars);
          font.ensureCharacters(flatChars.join(""));
          Cache.set(`${name}-bitmap`, font);
          font.once("destroy", () => Cache.remove(`${name}-bitmap`));
          return font;
        }
        /**
         * Uninstalls a bitmap font from the cache.
         * @param {string} name - The name of the bitmap font to uninstall.
         */
        uninstall(name) {
          const cacheKey = `${name}-bitmap`;
          const font = Cache.get(cacheKey);
          if (font) {
            font.destroy();
          }
        }
      };
      BitmapFontManager = new BitmapFontManagerClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }
  var BitmapTextPipe;
  var init_BitmapTextPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
      init_Cache();
      init_Extensions();
      init_PoolGroup();
      init_Graphics();
      init_SdfShader();
      init_BitmapFontManager();
      init_getBitmapTextLayout();
      BitmapTextPipe = class {
        constructor(renderer) {
          this._gpuBitmapText = {};
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText");
        }
        validateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        }
        addRenderable(bitmapText, instructionSet) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        destroyRenderable(bitmapText) {
          bitmapText.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableByUid(bitmapText.uid);
        }
        _destroyRenderableByUid(renderableUid) {
          const context4 = this._gpuBitmapText[renderableUid].context;
          if (context4.customShader) {
            BigPool.return(context4.customShader);
            context4.customShader = null;
          }
          BigPool.return(this._gpuBitmapText[renderableUid]);
          this._gpuBitmapText[renderableUid] = null;
        }
        updateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        _updateContext(bitmapText, proxyGraphics) {
          const { context: context4 } = proxyGraphics;
          const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
          context4.clear();
          if (bitmapFont.distanceField.type !== "none") {
            if (!context4.customShader) {
              context4.customShader = BigPool.get(SdfShader);
            }
          }
          const chars = Array.from(bitmapText.text);
          const style = bitmapText._style;
          let currentY = bitmapFont.baseLineOffset;
          const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
          let index = 0;
          const padding = style.padding;
          const scale = bitmapTextLayout.scale;
          let tx = bitmapTextLayout.width;
          let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
          if (style._stroke) {
            tx += style._stroke.width / scale;
            ty += style._stroke.width / scale;
          }
          context4.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
          const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
          for (let i3 = 0; i3 < bitmapTextLayout.lines.length; i3++) {
            const line = bitmapTextLayout.lines[i3];
            for (let j2 = 0; j2 < line.charPositions.length; j2++) {
              const char = chars[index++];
              const charData = bitmapFont.chars[char];
              if (charData?.texture) {
                context4.texture(
                  charData.texture,
                  tint ? tint : "black",
                  Math.round(line.charPositions[j2] + charData.xOffset),
                  Math.round(currentY + charData.yOffset)
                );
              }
            }
            currentY += bitmapFont.lineHeight;
          }
        }
        _getGpuBitmapText(bitmapText) {
          return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
        }
        initGpuText(bitmapText) {
          const proxyRenderable = BigPool.get(Graphics);
          this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
          this._updateContext(bitmapText, proxyRenderable);
          bitmapText.on("destroyed", this._destroyRenderableBound);
          return this._gpuBitmapText[bitmapText.uid];
        }
        _updateDistanceField(bitmapText) {
          const context4 = this._getGpuBitmapText(bitmapText).context;
          const fontFamily = bitmapText._style.fontFamily;
          const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
          const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
          const dx = Math.sqrt(a2 * a2 + b2 * b2);
          const dy = Math.sqrt(c2 * c2 + d2 * d2);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
          const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
          context4.customShader.resources.localUniforms.uniforms.uDistance = distance;
        }
        destroy() {
          for (const uid3 in this._gpuBitmapText) {
            this._destroyRenderableByUid(uid3);
          }
          this._gpuBitmapText = null;
          this._renderer = null;
        }
      };
      BitmapTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "bitmapText"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
  var init_init10 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
      init_Extensions();
      init_BitmapTextPipe();
      extensions.add(BitmapTextPipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
  var HTMLTextPipe;
  var init_HTMLTextPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
      init_Extensions();
      init_Texture();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      HTMLTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.runners.resolutionChange.add(this);
          this._renderer.renderableGC.addManagedHash(this, "_gpuText");
        }
        resolutionChange() {
          for (const i3 in this._gpuText) {
            const gpuText = this._gpuText[i3];
            if (!gpuText)
              continue;
            const text = gpuText.batchableSprite.renderable;
            if (text._autoResolution) {
              text._resolution = this._renderer.resolution;
              text.onViewUpdate();
            }
          }
        }
        validateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const newKey = htmlText._getKey();
          if (gpuText.textureNeedsUploading) {
            gpuText.textureNeedsUploading = false;
            return true;
          }
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(htmlText, instructionSet) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
        }
        updateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          batchableSprite._batcher.updateElement(batchableSprite);
        }
        destroyRenderable(htmlText) {
          htmlText.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableById(htmlText.uid);
        }
        _destroyRenderableById(htmlTextUid) {
          const gpuText = this._gpuText[htmlTextUid];
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[htmlTextUid] = null;
        }
        _updateText(htmlText) {
          const newKey = htmlText._getKey();
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(htmlText).catch((e2) => {
              console.error(e2);
            });
          }
          htmlText._didTextUpdate = false;
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        async _updateGpuText(htmlText) {
          htmlText._didTextUpdate = false;
          const gpuText = this._getGpuText(htmlText);
          if (gpuText.generatingTexture)
            return;
          const newKey = htmlText._getKey();
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          gpuText.generatingTexture = true;
          gpuText.currentKey = newKey;
          const resolution = htmlText.resolution ?? this._renderer.resolution;
          const texture = await this._renderer.htmlText.getManagedTexture(
            htmlText.text,
            resolution,
            htmlText._style,
            htmlText._getKey()
          );
          const batchableSprite = gpuText.batchableSprite;
          batchableSprite.texture = gpuText.texture = texture;
          gpuText.generatingTexture = false;
          gpuText.textureNeedsUploading = true;
          htmlText.onViewUpdate();
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        _getGpuText(htmlText) {
          return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
        }
        initGpuText(htmlText) {
          const gpuTextData = {
            texture: Texture.EMPTY,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite),
            textureNeedsUploading: false,
            generatingTexture: false
          };
          const batchableSprite = gpuTextData.batchableSprite;
          batchableSprite.renderable = htmlText;
          batchableSprite.transform = htmlText.groupTransform;
          batchableSprite.texture = Texture.EMPTY;
          batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
          htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
          this._gpuText[htmlText.uid] = gpuTextData;
          htmlText.on("destroyed", this._destroyRenderableBound);
          return gpuTextData;
        }
        destroy() {
          for (const i3 in this._gpuText) {
            this._destroyRenderableById(i3);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      HTMLTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "htmlText"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isSafari.mjs
  function isSafari() {
    const { userAgent } = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  var init_isSafari = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
  var nssvg, nsxhtml, HTMLTextRenderData;
  var init_HTMLTextRenderData = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
      "use strict";
      nssvg = "http://www.w3.org/2000/svg";
      nsxhtml = "http://www.w3.org/1999/xhtml";
      HTMLTextRenderData = class {
        constructor() {
          this.svgRoot = document.createElementNS(nssvg, "svg");
          this.foreignObject = document.createElementNS(nssvg, "foreignObject");
          this.domElement = document.createElementNS(nsxhtml, "div");
          this.styleElement = document.createElementNS(nsxhtml, "style");
          this.image = new Image();
          const { foreignObject, svgRoot, styleElement, domElement } = this;
          foreignObject.setAttribute("width", "10000");
          foreignObject.setAttribute("height", "10000");
          foreignObject.style.overflow = "hidden";
          svgRoot.appendChild(foreignObject);
          foreignObject.appendChild(styleElement);
          foreignObject.appendChild(domElement);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs
  function textStyleToCSS(style) {
    const stroke = style._stroke;
    const fill = style._fill;
    const cssStyleString = [
      `color: ${Color.shared.setValue(fill.color).toHex()}`,
      `font-size: ${style.fontSize}px`,
      `font-family: ${style.fontFamily}`,
      `font-weight: ${style.fontWeight}`,
      `font-style: ${style.fontStyle}`,
      `font-variant: ${style.fontVariant}`,
      `letter-spacing: ${style.letterSpacing}px`,
      `text-align: ${style.align}`,
      `padding: ${style.padding}px`,
      `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
      ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
      ...style.wordWrap ? [
        `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${style.wordWrapWidth}px`
      ] : [],
      ...stroke ? [strokeToCSS(stroke)] : [],
      ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
      ...style.cssOverrides
    ].join(";");
    const cssStyles = [`div { ${cssStyleString} }`];
    tagStyleToCSS(style.tagStyles, cssStyles);
    return cssStyles.join(" ");
  }
  function dropShadowToCSS(dropShadowStyle) {
    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position = `${x2}px ${y2}px`;
    if (dropShadowStyle.blur > 0) {
      return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  function strokeToCSS(stroke) {
    return [
      `-webkit-text-stroke-width: ${stroke.width}px`,
      `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      `text-stroke-width: ${stroke.width}px`,
      `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  function tagStyleToCSS(tagStyles, out2) {
    for (const i3 in tagStyles) {
      const tagStyle = tagStyles[i3];
      const cssTagStyle = [];
      for (const j2 in tagStyle) {
        if (transform[j2]) {
          cssTagStyle.push(transform[j2](tagStyle[j2]));
        } else if (templates[j2]) {
          cssTagStyle.push(templates[j2].replace("{{VALUE}}", tagStyle[j2]));
        }
      }
      out2.push(`${i3} { ${cssTagStyle.join(";")} }`);
    }
  }
  var templates, transform;
  var init_textStyleToCSS = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs"() {
      init_Color();
      templates = {
        fontSize: `font-size: {{VALUE}}px`,
        fontFamily: `font-family: {{VALUE}}`,
        fontWeight: `font-weight: {{VALUE}}`,
        fontStyle: `font-style: {{VALUE}}`,
        fontVariant: `font-variant: {{VALUE}}`,
        letterSpacing: `letter-spacing: {{VALUE}}px`,
        align: `text-align: {{VALUE}}`,
        padding: `padding: {{VALUE}}px`,
        whiteSpace: `white-space: {{VALUE}}`,
        lineHeight: `line-height: {{VALUE}}px`,
        wordWrapWidth: `max-width: {{VALUE}}px`
      };
      transform = {
        fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,
        breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
        stroke: strokeToCSS,
        dropShadow: dropShadowToCSS
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs
  var HTMLTextStyle;
  var init_HtmlTextStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs"() {
      init_warn();
      init_TextStyle();
      init_generateTextStyleKey();
      init_textStyleToCSS();
      HTMLTextStyle = class extends TextStyle {
        constructor(options = {}) {
          super(options);
          this._cssOverrides = [];
          this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
          this.tagStyles = options.tagStyles ?? {};
        }
        /** List of style overrides that will be applied to the HTML text. */
        set cssOverrides(value) {
          this._cssOverrides = value instanceof Array ? value : [value];
          this.update();
        }
        get cssOverrides() {
          return this._cssOverrides;
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
          return this._styleKey;
        }
        update() {
          this._cssStyle = null;
          super.update();
        }
        /**
         * Creates a new HTMLTextStyle object with the same values as this one.
         * @returns New cloned HTMLTextStyle object
         */
        clone() {
          return new HTMLTextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides
          });
        }
        get cssStyle() {
          if (!this._cssStyle) {
            this._cssStyle = textStyleToCSS(this);
          }
          return this._cssStyle;
        }
        /**
         * Add a style override, this can be any CSS property
         * it will override any built-in style. This is the
         * property and the value as a string (e.g., `color: red`).
         * This will override any other internal style.
         * @param {string} value - CSS style(s) to add.
         * @example
         * style.addOverride('background-color: red');
         */
        addOverride(...value) {
          const toAdd = value.filter((v2) => !this.cssOverrides.includes(v2));
          if (toAdd.length > 0) {
            this.cssOverrides.push(...toAdd);
            this.update();
          }
        }
        /**
         * Remove any overrides that match the value.
         * @param {string} value - CSS style to remove.
         * @example
         * style.removeOverride('background-color: red');
         */
        removeOverride(...value) {
          const toRemove = value.filter((v2) => this.cssOverrides.includes(v2));
          if (toRemove.length > 0) {
            this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
            this.update();
          }
        }
        set fill(value) {
          if (typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
          }
          super.fill = value;
        }
        set stroke(value) {
          if (value && typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
          }
          super.stroke = value;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
  function extractFontFamilies(text, style) {
    const fontFamily = style.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text.match(regex);
    function addFontFamily(fontFamily2) {
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    }
    if (Array.isArray(fontFamily)) {
      for (let i3 = 0; i3 < fontFamily.length; i3++) {
        addFontFamily(fontFamily[i3]);
      }
    } else {
      addFontFamily(fontFamily);
    }
    if (matches) {
      matches.forEach((match) => {
        const fontFamily2 = match.split(":")[1].trim();
        addFontFamily(fontFamily2);
      });
    }
    for (const i3 in style.tagStyles) {
      const fontFamily2 = style.tagStyles[i3].fontFamily;
      addFontFamily(fontFamily2);
    }
    return fontFamilies;
  }
  var init_extractFontFamilies = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
  async function loadFontAsBase64(url) {
    const response = await DOMAdapter.get().fetch(url);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataSrc;
  }
  var init_loadFontAsBase64 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
  async function loadFontCSS(style, url) {
    const dataSrc = await loadFontAsBase64(url);
    return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
  }
  var init_loadFontCSS = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
      init_loadFontAsBase64();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
  async function getFontCss(fontFamilies, style, defaultOptions) {
    const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i3) => {
      if (!FontStylePromiseCache.has(fontFamily)) {
        const { url } = Cache.get(`${fontFamily}-and-url`);
        if (i3 === 0) {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: style.fontWeight,
            fontStyle: style.fontStyle,
            fontFamily
          }, url));
        } else {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: defaultOptions.fontWeight,
            fontStyle: defaultOptions.fontStyle,
            fontFamily
          }, url));
        }
      }
      return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
  }
  var FontStylePromiseCache;
  var init_getFontCss = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
      init_Cache();
      init_loadFontCSS();
      FontStylePromiseCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
  function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const { width, height } = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }
  var init_getSVGUrl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      image.width,
      image.height,
      resolution
    );
    const { context: context4 } = canvasAndContext;
    context4.clearRect(0, 0, image.width, image.height);
    context4.drawImage(image, 0, 0);
    return canvasAndContext;
  }
  var init_getTemporaryCanvasFromImage = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
      init_CanvasPool();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
  function loadSVGImage(image, url, delay) {
    return new Promise(async (resolve) => {
      if (delay) {
        await new Promise((resolve2) => setTimeout(resolve2, 100));
      }
      image.onload = () => {
        resolve();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
      image.crossOrigin = "anonymous";
    });
  }
  var init_loadSVGImage = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
  function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const doublePadding = style.padding * 2;
    return {
      width: contentBounds.width - doublePadding,
      height: contentBounds.height - doublePadding
    };
  }
  var tempHTMLTextRenderData;
  var init_measureHtmlText = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
      init_HTMLTextRenderData();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
  var HTMLTextSystem;
  var init_HTMLTextSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
      init_Extensions();
      init_CanvasPool();
      init_TexturePool();
      init_types2();
      init_isSafari();
      init_warn();
      init_PoolGroup();
      init_getPo2TextureFromSource();
      init_HTMLTextRenderData();
      init_HtmlTextStyle();
      init_extractFontFamilies();
      init_getFontCss();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadSVGImage();
      init_measureHtmlText();
      HTMLTextSystem = class {
        constructor(renderer) {
          this._activeTextures = {};
          this._renderer = renderer;
          this._createCanvas = renderer.type === RendererType.WEBGPU;
        }
        getTexture(options) {
          return this._buildTexturePromise(
            options.text,
            options.resolution,
            options.style
          );
        }
        getManagedTexture(text, resolution, style, textKey) {
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
          }
          const promise2 = this._buildTexturePromise(text, resolution, style).then((texture) => {
            this._activeTextures[textKey].texture = texture;
            return texture;
          });
          this._activeTextures[textKey] = {
            texture: null,
            promise: promise2,
            usageCount: 1
          };
          return promise2;
        }
        async _buildTexturePromise(text, resolution, style) {
          const htmlTextData = BigPool.get(HTMLTextRenderData);
          const fontFamilies = extractFontFamilies(text, style);
          const fontCSS = await getFontCss(
            fontFamilies,
            style,
            HTMLTextStyle.defaultTextStyle
          );
          const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const image = htmlTextData.image;
          const uvSafeOffset = 2;
          image.width = (width | 0) + uvSafeOffset;
          image.height = (height | 0) + uvSafeOffset;
          const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
          await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
          const resource = image;
          let canvasAndContext;
          if (this._createCanvas) {
            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
          }
          const texture = getPo2TextureFromSource(
            canvasAndContext ? canvasAndContext.canvas : resource,
            image.width - uvSafeOffset,
            image.height - uvSafeOffset,
            resolution
          );
          if (this._createCanvas) {
            this._renderer.texture.initSource(texture.source);
            CanvasPool.returnCanvasAndContext(canvasAndContext);
          }
          BigPool.return(htmlTextData);
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          if (!activeTexture)
            return;
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
              this._cleanUp(activeTexture);
            } else {
              activeTexture.promise.then((texture) => {
                activeTexture.texture = texture;
                this._cleanUp(activeTexture);
              }).catch(() => {
                warn("HTMLTextSystem: Failed to clean texture");
              });
            }
            this._activeTextures[textKey] = null;
          }
        }
        _cleanUp(activeTexture) {
          TexturePool.returnTexture(activeTexture.texture);
          activeTexture.texture.source.resource = null;
          activeTexture.texture.source.uploadMethodId = "unknown";
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      HTMLTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "htmlText"
      };
      HTMLTextSystem.defaultFontOptions = {
        fontFamily: "Arial",
        fontStyle: "normal",
        fontWeight: "normal"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/init.mjs
  var init_init11 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
      init_Extensions();
      init_HTMLTextPipe();
      init_HTMLTextSystem();
      extensions.add(HTMLTextSystem);
      extensions.add(HTMLTextPipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry, MeshGeometry;
  var init_MeshGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      init_deprecation();
      _MeshGeometry = class _MeshGeometry2 extends Geometry {
        constructor(...args) {
          let options = args[0] ?? {};
          if (options instanceof Float32Array) {
            deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
            options = {
              positions: options,
              uvs: args[1],
              indices: args[2]
            };
          }
          options = { ..._MeshGeometry2.defaultOptions, ...options };
          const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
          const shrinkToFit = options.shrinkBuffersToFit;
          const positionBuffer = new Buffer2({
            data: positions,
            label: "attribute-mesh-positions",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const uvBuffer = new Buffer2({
            data: uvs,
            label: "attribute-mesh-uvs",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer2({
            data: indices,
            label: "index-mesh-buffer",
            shrinkToFit,
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          super({
            attributes: {
              aPosition: {
                buffer: positionBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              },
              aUV: {
                buffer: uvBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              }
            },
            indexBuffer,
            topology: options.topology
          });
          this.batchMode = "auto";
        }
        /** The positions of the mesh. */
        get positions() {
          return this.attributes.aPosition.buffer.data;
        }
        set positions(value) {
          this.attributes.aPosition.buffer.data = value;
        }
        /** The UVs of the mesh. */
        get uvs() {
          return this.attributes.aUV.buffer.data;
        }
        set uvs(value) {
          this.attributes.aUV.buffer.data = value;
        }
        /** The indices of the mesh. */
        get indices() {
          return this.indexBuffer.data;
        }
        set indices(value) {
          this.indexBuffer.data = value;
        }
      };
      _MeshGeometry.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: false
      };
      MeshGeometry = _MeshGeometry;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  var localUniformBit, localUniformBitGroup2, localUniformBitGl;
  var init_localUniformBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
      "use strict";
      localUniformBit = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* wgsl */
            `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        }
      };
      localUniformBitGroup2 = {
        ...localUniformBit,
        vertex: {
          ...localUniformBit.vertex,
          // replace the group!
          header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
        }
      };
      localUniformBitGl = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* glsl */
            `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
  var tilingBit, tilingBitGl;
  var init_tilingBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
      "use strict";
      tilingBit = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
          )
        }
      };
      tilingBitGl = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
          ),
          main: (
            /* glsl */
            `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var gpuProgram2, glProgram2, TilingSpriteShader;
  var init_TilingSpriteShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      init_Texture();
      init_tilingBit();
      TilingSpriteShader = class extends Shader {
        constructor() {
          gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBit,
              tilingBit,
              roundPixelsBit
            ]
          }));
          glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBitGl,
              tilingBitGl,
              roundPixelsBitGl
            ]
          }));
          const tilingUniforms = new UniformGroup({
            uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
          });
          super({
            glProgram: glProgram2,
            gpuProgram: gpuProgram2,
            resources: {
              localUniforms: new UniformGroup({
                uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" }
              }),
              tilingUniforms,
              uTexture: Texture.EMPTY.source,
              uSampler: Texture.EMPTY.source.style
            }
          });
        }
        updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
          const tilingUniforms = this.resources.tilingUniforms;
          const textureWidth = texture.width;
          const textureHeight = texture.height;
          const textureMatrix = texture.textureMatrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * textureWidth / width,
            matrix.b * textureWidth / height,
            matrix.c * textureHeight / width,
            matrix.d * textureHeight / height,
            matrix.tx / width,
            matrix.ty / height
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = width;
          tilingUniforms.uniforms.uSizeAnchor[1] = height;
          tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
          tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
          if (texture) {
            this.resources.uTexture = texture.source;
            this.resources.uSampler = texture.source.style;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
  var QuadGeometry;
  var init_QuadGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
      init_MeshGeometry();
      QuadGeometry = class extends MeshGeometry {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
  function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
  }
  var init_setPositions = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index < size) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index++;
    }
  }
  var init_applyMatrix = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width = texture.frame.width;
    const height = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite._applyAnchorToTexture) {
      anchorX = tilingSprite.anchor.x;
      anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = Matrix.shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }
  var init_setUvs = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
      init_Matrix();
      init_applyMatrix();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  var sharedQuad, TilingSpritePipe;
  var init_TilingSpritePipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
      init_Extensions();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_types2();
      init_colorToUniform();
      init_BatchableMesh();
      init_MeshGeometry();
      init_TilingSpriteShader();
      init_QuadGeometry();
      init_setPositions();
      init_setUvs();
      sharedQuad = new QuadGeometry();
      TilingSpritePipe = class {
        constructor(renderer) {
          this._state = State.default2d;
          this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash");
        }
        validateRenderable(renderable) {
          const tilingSpriteData = this._getTilingSpriteData(renderable);
          const couldBatch = tilingSpriteData.canBatch;
          this._updateCanBatch(renderable);
          const canBatch = tilingSpriteData.canBatch;
          if (canBatch && canBatch === couldBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source) {
              return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
            }
          }
          return couldBatch !== canBatch;
        }
        addRenderable(tilingSprite, instructionSet) {
          const batcher = this._renderer.renderPipes.batch;
          this._updateCanBatch(tilingSprite);
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { geometry, canBatch } = tilingSpriteData;
          if (canBatch) {
            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
            const batchableMesh = tilingSpriteData.batchableMesh;
            if (tilingSprite.didViewUpdate) {
              this._updateBatchableMesh(tilingSprite);
              batchableMesh.geometry = geometry;
              batchableMesh.renderable = tilingSprite;
              batchableMesh.transform = tilingSprite.groupTransform;
              batchableMesh.texture = tilingSprite._texture;
            }
            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
            batcher.addToBatch(batchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
            this.updateRenderable(tilingSprite);
            instructionSet.add(tilingSprite);
          }
        }
        execute(tilingSprite) {
          const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
          shader.groups[0] = this._renderer.globalUniforms.bindGroup;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = tilingSprite.groupTransform;
          localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
          color32BitToUniform(
            tilingSprite.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
          this._renderer.encoder.draw({
            geometry: sharedQuad,
            shader,
            state: this._state
          });
        }
        updateRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { canBatch } = tilingSpriteData;
          if (canBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (tilingSprite.didViewUpdate)
              this._updateBatchableMesh(tilingSprite);
            batchableMesh._batcher.updateElement(batchableMesh);
          } else if (tilingSprite.didViewUpdate) {
            const { shader } = tilingSpriteData;
            shader.updateUniforms(
              tilingSprite.width,
              tilingSprite.height,
              tilingSprite._tileTransform.matrix,
              tilingSprite.anchor.x,
              tilingSprite.anchor.y,
              tilingSprite.texture
            );
          }
        }
        destroyRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          tilingSpriteData.batchableMesh = null;
          tilingSpriteData.shader?.destroy();
          this._tilingSpriteDataHash[tilingSprite.uid] = null;
          tilingSprite.off("destroyed", this._destroyRenderableBound);
        }
        _getTilingSpriteData(renderable) {
          return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
        }
        _initTilingSpriteData(tilingSprite) {
          const geometry = new MeshGeometry({
            indices: sharedQuad.indices,
            positions: sharedQuad.positions.slice(),
            uvs: sharedQuad.uvs.slice()
          });
          this._tilingSpriteDataHash[tilingSprite.uid] = {
            canBatch: true,
            renderable: tilingSprite,
            geometry
          };
          tilingSprite.on("destroyed", this._destroyRenderableBound);
          return this._tilingSpriteDataHash[tilingSprite.uid];
        }
        _updateBatchableMesh(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const { geometry } = renderableData;
          const style = tilingSprite.texture.source.style;
          if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
          }
          setUvs(tilingSprite, geometry.uvs);
          setPositions(tilingSprite, geometry.positions);
        }
        destroy() {
          for (const i3 in this._tilingSpriteDataHash) {
            this.destroyRenderable(this._tilingSpriteDataHash[i3].renderable);
          }
          this._tilingSpriteDataHash = null;
          this._renderer = null;
        }
        _updateCanBatch(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const texture = tilingSprite.texture;
          let _nonPowOf2wrapping = true;
          if (this._renderer.type === RendererType.WEBGL) {
            _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
          }
          renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
          return renderableData.canBatch;
        }
      };
      TilingSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "tilingSprite"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
  var init_init12 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
      init_Extensions();
      init_TilingSpritePipe();
      extensions.add(TilingSpritePipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
  var _PlaneGeometry, PlaneGeometry;
  var init_PlaneGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
      init_deprecation();
      init_MeshGeometry();
      _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
        constructor(...args) {
          super({});
          let options = args[0] ?? {};
          if (typeof options === "number") {
            deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
            options = {
              width: options,
              height: args[1],
              verticesX: args[2],
              verticesY: args[3]
            };
          }
          this.build(options);
        }
        /**
         * Refreshes plane coordinates
         * @param options - Options to be applied to plane geometry
         */
        build(options) {
          options = { ..._PlaneGeometry2.defaultOptions, ...options };
          this.verticesX = this.verticesX ?? options.verticesX;
          this.verticesY = this.verticesY ?? options.verticesY;
          this.width = this.width ?? options.width;
          this.height = this.height ?? options.height;
          const total = this.verticesX * this.verticesY;
          const verts = [];
          const uvs = [];
          const indices = [];
          const verticesX = this.verticesX - 1;
          const verticesY = this.verticesY - 1;
          const sizeX = this.width / verticesX;
          const sizeY = this.height / verticesY;
          for (let i3 = 0; i3 < total; i3++) {
            const x2 = i3 % this.verticesX;
            const y2 = i3 / this.verticesX | 0;
            verts.push(x2 * sizeX, y2 * sizeY);
            uvs.push(x2 / verticesX, y2 / verticesY);
          }
          const totalSub = verticesX * verticesY;
          for (let i3 = 0; i3 < totalSub; i3++) {
            const xpos = i3 % verticesX;
            const ypos = i3 / verticesX | 0;
            const value = ypos * this.verticesX + xpos;
            const value2 = ypos * this.verticesX + xpos + 1;
            const value3 = (ypos + 1) * this.verticesX + xpos;
            const value4 = (ypos + 1) * this.verticesX + xpos + 1;
            indices.push(
              value,
              value2,
              value3,
              value2,
              value4,
              value3
            );
          }
          this.buffers[0].data = new Float32Array(verts);
          this.buffers[1].data = new Float32Array(uvs);
          this.indexBuffer.data = new Uint32Array(indices);
          this.buffers[0].update();
          this.buffers[1].update();
          this.indexBuffer.update();
        }
      };
      _PlaneGeometry.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
      };
      PlaneGeometry = _PlaneGeometry;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
  var _NineSliceGeometry, NineSliceGeometry;
  var init_NineSliceGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
      init_PlaneGeometry();
      _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
        constructor(options = {}) {
          options = { ..._NineSliceGeometry2.defaultOptions, ...options };
          super({
            width: options.width,
            height: options.height,
            verticesX: 4,
            verticesY: 4
          });
          this.update(options);
        }
        /**
         * Updates the NineSliceGeometry with the options.
         * @param options - The options of the NineSliceGeometry.
         */
        update(options) {
          this.width = options.width ?? this.width;
          this.height = options.height ?? this.height;
          this._originalWidth = options.originalWidth ?? this._originalWidth;
          this._originalHeight = options.originalHeight ?? this._originalHeight;
          this._leftWidth = options.leftWidth ?? this._leftWidth;
          this._rightWidth = options.rightWidth ?? this._rightWidth;
          this._topHeight = options.topHeight ?? this._topHeight;
          this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
          this.updateUvs();
          this.updatePositions();
        }
        /** Updates the positions of the vertices. */
        updatePositions() {
          const positions = this.positions;
          const w2 = this._leftWidth + this._rightWidth;
          const scaleW = this.width > w2 ? 1 : this.width / w2;
          const h2 = this._topHeight + this._bottomHeight;
          const scaleH = this.height > h2 ? 1 : this.height / h2;
          const scale = Math.min(scaleW, scaleH);
          positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;
          positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;
          positions[25] = positions[27] = positions[29] = positions[31] = this.height;
          positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;
          positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;
          positions[6] = positions[14] = positions[22] = positions[30] = this.width;
          this.getBuffer("aPosition").update();
        }
        /** Updates the UVs of the vertices. */
        updateUvs() {
          const uvs = this.uvs;
          uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
          uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
          uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
          uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
          const _uvw = 1 / this._originalWidth;
          const _uvh = 1 / this._originalHeight;
          uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
          uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
          uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
          uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
          this.getBuffer("aUV").update();
        }
      };
      _NineSliceGeometry.defaultOptions = {
        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        width: 100,
        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        height: 100,
        /** The width of the left column. */
        leftWidth: 10,
        /** The height of the top row. */
        topHeight: 10,
        /** The width of the right column. */
        rightWidth: 10,
        /** The height of the bottom row. */
        bottomHeight: 10,
        /** The original width of the texture */
        originalWidth: 100,
        /** The original height of the texture */
        originalHeight: 100
      };
      NineSliceGeometry = _NineSliceGeometry;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
  var NineSliceSpritePipe;
  var init_NineSliceSpritePipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableMesh();
      init_NineSliceGeometry();
      NineSliceSpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableMesh = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableMesh.geometry);
          BigPool.return(batchableMesh);
          this._gpuSpriteHash[sprite.uid] = null;
          sprite.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          batchableSprite.geometry.update(sprite);
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableMesh = BigPool.get(BatchableMesh);
          batchableMesh.geometry = BigPool.get(NineSliceGeometry);
          batchableMesh.renderable = sprite;
          batchableMesh.transform = sprite.groupTransform;
          batchableMesh.texture = sprite._texture;
          batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableMesh;
          if (!sprite.didViewUpdate) {
            this._updateBatchableSprite(sprite, batchableMesh);
          }
          sprite.on("destroyed", this._destroyRenderableBound);
          return batchableMesh;
        }
        destroy() {
          for (const i3 in this._gpuSpriteHash) {
            const batchableMesh = this._gpuSpriteHash[i3];
            batchableMesh.geometry.destroy();
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      NineSliceSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "nineSliceSprite"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
  var init_init13 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
      init_Extensions();
      init_NineSliceSpritePipe();
      extensions.add(NineSliceSpritePipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/FilterPipe.mjs
  var FilterPipe;
  var init_FilterPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
      init_Extensions();
      FilterPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        push(filterEffect, container, instructionSet) {
          const renderPipes3 = this._renderer.renderPipes;
          renderPipes3.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
          });
        }
        pop(_filterEffect, _container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        execute(instruction) {
          if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
          } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      FilterPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "filter"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs
  function getFastGlobalBounds(target, bounds) {
    bounds.clear();
    _getGlobalBoundsRecursive(target, bounds);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    if (!target.renderGroup) {
      bounds.applyMatrix(target.parentRenderGroup.worldTransform);
    } else {
      bounds.applyMatrix(target.renderGroup.localTransform);
    }
    return bounds;
  }
  function _getGlobalBoundsRecursive(target, bounds) {
    if (target.localDisplayStatus !== 7 || !target.measurable) {
      return;
    }
    const manageEffects = !!target.effects.length;
    let localBounds = bounds;
    if (target.renderGroup || manageEffects) {
      localBounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, target.worldTransform);
    } else {
      if (target.renderPipeId) {
        const viewBounds = target.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          target.groupTransform
        );
      }
      const children = target.children;
      for (let i3 = 0; i3 < children.length; i3++) {
        _getGlobalBoundsRecursive(children[i3], localBounds);
      }
    }
    if (manageEffects) {
      let advanced = false;
      for (let i3 = 0; i3 < target.effects.length; i3++) {
        if (target.effects[i3].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(target.parentRenderGroup.worldTransform);
          }
          target.effects[i3].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix4).invert());
        bounds.addBounds(localBounds, target.relativeGroupTransform);
      }
      bounds.addBounds(localBounds);
      boundsPool.return(localBounds);
    } else if (target.renderGroup) {
      bounds.addBounds(localBounds, target.relativeGroupTransform);
      boundsPool.return(localBounds);
    }
  }
  var tempMatrix4;
  var init_getFastGlobalBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
      tempMatrix4 = new Matrix();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const tempMatrix7 = bounds.matrix;
    for (let i3 = 0; i3 < renderables.length; i3++) {
      const renderable = renderables[i3];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      bounds.matrix = renderable.worldTransform;
      renderable.addBounds(bounds);
    }
    bounds.matrix = tempMatrix7;
    return bounds;
  }
  var init_getRenderableBounds = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/FilterSystem.mjs
  var quadGeometry, FilterSystem;
  var init_FilterSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_BindGroup();
      init_Geometry();
      init_UniformGroup();
      init_Texture();
      init_TexturePool();
      init_types2();
      init_Bounds();
      init_getFastGlobalBounds();
      init_getRenderableBounds();
      init_warn();
      quadGeometry = new Geometry({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
      FilterSystem = class {
        constructor(renderer) {
          this._filterStackIndex = 0;
          this._filterStack = [];
          this._filterGlobalUniforms = new UniformGroup({
            uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
          });
          this._globalFilterBindGroup = new BindGroup({});
          this.renderer = renderer;
        }
        /**
         * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
         * @readonly
         */
        get activeBackTexture() {
          return this._activeFilterData?.backTexture;
        }
        push(instruction) {
          const renderer = this.renderer;
          const filters = instruction.filterEffect.filters;
          if (!this._filterStack[this._filterStackIndex]) {
            this._filterStack[this._filterStackIndex] = this._getFilterData();
          }
          const filterData = this._filterStack[this._filterStackIndex];
          this._filterStackIndex++;
          if (filters.length === 0) {
            filterData.skip = true;
            return;
          }
          const bounds = filterData.bounds;
          if (instruction.renderables) {
            getGlobalRenderableBounds(instruction.renderables, bounds);
          } else if (instruction.filterEffect.filterArea) {
            bounds.clear();
            bounds.addRect(instruction.filterEffect.filterArea);
            bounds.applyMatrix(instruction.container.worldTransform);
          } else {
            getFastGlobalBounds(instruction.container, bounds);
          }
          const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
          let resolution = Infinity;
          let padding = 0;
          let antialias = true;
          let blendRequired = false;
          let enabled = false;
          let clipToViewport = true;
          for (let i3 = 0; i3 < filters.length; i3++) {
            const filter = filters[i3];
            resolution = Math.min(resolution, filter.resolution === "inherit" ? colorTextureSource._resolution : filter.resolution);
            padding += filter.padding;
            if (filter.antialias === "off") {
              antialias = false;
            } else if (filter.antialias === "inherit") {
              antialias && (antialias = colorTextureSource.antialias);
            }
            if (!filter.clipToViewport) {
              clipToViewport = false;
            }
            const isCompatible = !!(filter.compatibleRenderers & renderer.type);
            if (!isCompatible) {
              enabled = false;
              break;
            }
            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
              warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
              enabled = false;
              break;
            }
            enabled = filter.enabled || enabled;
            blendRequired = blendRequired || filter.blendRequired;
          }
          if (!enabled) {
            filterData.skip = true;
            return;
          }
          bounds.scale(resolution);
          if (clipToViewport) {
            const viewPort = renderer.renderTarget.rootViewPort;
            bounds.fitBounds(0, viewPort.width, 0, viewPort.height);
          }
          bounds.ceil().scale(1 / resolution).pad(padding | 0);
          if (!bounds.isPositive) {
            filterData.skip = true;
            return;
          }
          filterData.skip = false;
          filterData.bounds = bounds;
          filterData.blendRequired = blendRequired;
          filterData.container = instruction.container;
          filterData.filterEffect = instruction.filterEffect;
          filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
          filterData.inputTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            resolution,
            antialias
          );
          renderer.renderTarget.bind(filterData.inputTexture, true);
          renderer.globalUniforms.push({
            offset: bounds
          });
        }
        pop() {
          const renderer = this.renderer;
          this._filterStackIndex--;
          const filterData = this._filterStack[this._filterStackIndex];
          if (filterData.skip) {
            return;
          }
          this._activeFilterData = filterData;
          const inputTexture = filterData.inputTexture;
          const bounds = filterData.bounds;
          let backTexture = Texture.EMPTY;
          renderer.renderTarget.finishRenderPass();
          if (filterData.blendRequired) {
            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
          }
          filterData.backTexture = backTexture;
          const filters = filterData.filterEffect.filters;
          this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
          this._globalFilterBindGroup.setResource(backTexture.source, 3);
          renderer.globalUniforms.pop();
          if (filters.length === 1) {
            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(inputTexture);
          } else {
            let flip = filterData.inputTexture;
            let flop = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              flip.source._resolution,
              false
            );
            let i3 = 0;
            for (i3 = 0; i3 < filters.length - 1; ++i3) {
              const filter = filters[i3];
              filter.apply(this, flip, flop, true);
              const t2 = flip;
              flip = flop;
              flop = t2;
            }
            filters[i3].apply(this, flip, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(flip);
            TexturePool.returnTexture(flop);
          }
          if (filterData.blendRequired) {
            TexturePool.returnTexture(backTexture);
          }
        }
        getBackTexture(lastRenderSurface, bounds, previousBounds) {
          const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
          const backTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            backgroundResolution,
            false
          );
          let x2 = bounds.minX;
          let y2 = bounds.minY;
          if (previousBounds) {
            x2 -= previousBounds.minX;
            y2 -= previousBounds.minY;
          }
          x2 = Math.floor(x2 * backgroundResolution);
          y2 = Math.floor(y2 * backgroundResolution);
          const width = Math.ceil(bounds.width * backgroundResolution);
          const height = Math.ceil(bounds.height * backgroundResolution);
          this.renderer.renderTarget.copyToTexture(
            lastRenderSurface,
            backTexture,
            { x: x2, y: y2 },
            { width, height },
            { x: 0, y: 0 }
          );
          return backTexture;
        }
        applyFilter(filter, input, output, clear) {
          const renderer = this.renderer;
          const filterData = this._filterStack[this._filterStackIndex];
          const bounds = filterData.bounds;
          const offset = Point.shared;
          const previousRenderSurface = filterData.previousRenderSurface;
          const isFinalTarget = previousRenderSurface === output;
          let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          let currentIndex = this._filterStackIndex - 1;
          while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
            --currentIndex;
          }
          if (currentIndex > 0) {
            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
          }
          const filterUniforms = this._filterGlobalUniforms;
          const uniforms = filterUniforms.uniforms;
          const outputFrame = uniforms.uOutputFrame;
          const inputSize = uniforms.uInputSize;
          const inputPixel = uniforms.uInputPixel;
          const inputClamp = uniforms.uInputClamp;
          const globalFrame = uniforms.uGlobalFrame;
          const outputTexture = uniforms.uOutputTexture;
          if (isFinalTarget) {
            let lastIndex = this._filterStackIndex;
            while (lastIndex > 0) {
              lastIndex--;
              const filterData2 = this._filterStack[this._filterStackIndex - 1];
              if (!filterData2.skip) {
                offset.x = filterData2.bounds.minX;
                offset.y = filterData2.bounds.minY;
                break;
              }
            }
            outputFrame[0] = bounds.minX - offset.x;
            outputFrame[1] = bounds.minY - offset.y;
          } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
          }
          outputFrame[2] = input.frame.width;
          outputFrame[3] = input.frame.height;
          inputSize[0] = input.source.width;
          inputSize[1] = input.source.height;
          inputSize[2] = 1 / inputSize[0];
          inputSize[3] = 1 / inputSize[1];
          inputPixel[0] = input.source.pixelWidth;
          inputPixel[1] = input.source.pixelHeight;
          inputPixel[2] = 1 / inputPixel[0];
          inputPixel[3] = 1 / inputPixel[1];
          inputClamp[0] = 0.5 * inputPixel[2];
          inputClamp[1] = 0.5 * inputPixel[3];
          inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
          inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
          const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
          globalFrame[0] = offset.x * resolution;
          globalFrame[1] = offset.y * resolution;
          globalFrame[2] = rootTexture.source.width * resolution;
          globalFrame[3] = rootTexture.source.height * resolution;
          const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
          renderer.renderTarget.bind(output, !!clear);
          if (output instanceof Texture) {
            outputTexture[0] = output.frame.width;
            outputTexture[1] = output.frame.height;
          } else {
            outputTexture[0] = renderTarget.width;
            outputTexture[1] = renderTarget.height;
          }
          outputTexture[2] = renderTarget.isRoot ? -1 : 1;
          filterUniforms.update();
          if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
          } else {
            this._globalFilterBindGroup.setResource(filterUniforms, 0);
          }
          this._globalFilterBindGroup.setResource(input.source, 1);
          this._globalFilterBindGroup.setResource(input.source.style, 2);
          filter.groups[0] = this._globalFilterBindGroup;
          renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter,
            state: filter._state,
            topology: "triangle-list"
          });
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
        }
        _getFilterData() {
          return {
            skip: false,
            inputTexture: null,
            bounds: new Bounds(),
            container: null,
            filterEffect: null,
            blendRequired: false,
            previousRenderSurface: null
          };
        }
        /**
         * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
         *
         * Use `outputMatrix * vTextureCoord` in the shader.
         * @param outputMatrix - The matrix to output to.
         * @param {Sprite} sprite - The sprite to map to.
         * @returns The mapped matrix.
         */
        calculateSpriteMatrix(outputMatrix, sprite) {
          const data = this._activeFilterData;
          const mappedMatrix = outputMatrix.set(
            data.inputTexture._source.width,
            0,
            0,
            data.inputTexture._source.height,
            data.bounds.minX,
            data.bounds.minY
          );
          const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
          worldTransform.invert();
          mappedMatrix.prepend(worldTransform);
          mappedMatrix.scale(
            1 / sprite.texture.frame.width,
            1 / sprite.texture.frame.height
          );
          mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
          return mappedMatrix;
        }
      };
      FilterSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "filter"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/init.mjs
  var init_init14 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/init.mjs"() {
      init_Extensions();
      init_FilterPipe();
      init_FilterSystem();
      extensions.add(FilterSystem);
      extensions.add(FilterPipe);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-browser/browserAll.mjs
  var browserAll_exports = {};
  var init_browserAll = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
      init_init();
      init_init2();
      init_init3();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
      init_init14();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-browser/browserExt.mjs
  var browserExt;
  var init_browserExt = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-browser/browserExt.mjs"() {
      init_Extensions();
      browserExt = {
        extension: {
          type: ExtensionType.Environment,
          name: "browser",
          priority: -1
        },
        test: () => true,
        load: async () => {
          await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
  var webworkerAll_exports = {};
  var init_webworkerAll = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
      init_init2();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
      init_init14();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
  var webworkerExt;
  var init_webworkerExt = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs"() {
      init_Extensions();
      webworkerExt = {
        extension: {
          type: ExtensionType.Environment,
          name: "webworker",
          priority: 0
        },
        test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
        load: async () => {
          await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/Filter.mjs
  var _Filter, Filter;
  var init_Filter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/Filter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_State();
      _Filter = class _Filter2 extends Shader {
        /**
         * @param options - The optional parameters of this filter.
         */
        constructor(options) {
          options = { ..._Filter2.defaultOptions, ...options };
          super(options);
          this.enabled = true;
          this._state = State.for2d();
          this.blendMode = options.blendMode;
          this.padding = options.padding;
          if (typeof options.antialias === "boolean") {
            this.antialias = options.antialias ? "on" : "off";
          } else {
            this.antialias = options.antialias;
          }
          this.resolution = options.resolution;
          this.blendRequired = options.blendRequired;
          this.clipToViewport = options.clipToViewport;
          this.addResource("uTexture", 0, 1);
        }
        /**
         * Applies the filter
         * @param filterManager - The renderer to retrieve the filter from
         * @param input - The input render target.
         * @param output - The target to output to.
         * @param clearMode - Should the output be cleared before rendering to it
         */
        apply(filterManager, input, output, clearMode) {
          filterManager.applyFilter(this, input, output, clearMode);
        }
        /**
         * Get the blend mode of the filter.
         * @default "normal"
         */
        get blendMode() {
          return this._state.blendMode;
        }
        /** Sets the blend mode of the filter. */
        set blendMode(value) {
          this._state.blendMode = value;
        }
        /**
         * A short hand function to create a filter based of a vertex and fragment shader src.
         * @param options
         * @returns A shiny new PixiJS filter!
         */
        static from(options) {
          const { gpu, gl, ...rest } = options;
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new _Filter2({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            ...rest
          });
        }
      };
      _Filter.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: false,
        clipToViewport: true
      };
      Filter = _Filter;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs
  var blendTemplateFrag;
  var init_blend_template_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs"() {
      blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uBlend;\n\nuniform sampler2D uTexture;\nuniform sampler2D uBackTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(uBackTexture, vTextureCoord);\n    vec4 front = texture(uTexture, vTextureCoord);\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\n    \n    {MAIN}\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs
  var blendTemplateVert;
  var init_blend_template_vert = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs"() {
      blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs
  var blendTemplate;
  var init_blend_template_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs"() {
      blendTemplate = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(uBackTexture, uSampler, uv);\n   var front = textureSample(uTexture, uSampler, uv);\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
  function compileBlendModeShader(options) {
    const { source: source7, functions, main } = options;
    return source7.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
  }
  var BlendModeFilter;
  var init_BlendModeFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_Texture();
      init_Filter();
      init_blend_template_frag();
      init_blend_template_vert();
      init_blend_template_wgsl();
      BlendModeFilter = class extends Filter {
        constructor(options) {
          const gpuOptions = options.gpu;
          const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: gpuSource,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: gpuSource,
              entryPoint: "mainFragment"
            }
          });
          const glOptions = options.gl;
          const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });
          const glProgram3 = GlProgram.from({
            vertex: blendTemplateVert,
            fragment: glSource
          });
          const uniformGroup = new UniformGroup({
            uBlend: {
              value: 1,
              type: "f32"
            }
          });
          super({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            blendRequired: true,
            resources: {
              blendUniforms: uniformGroup,
              uBackTexture: Texture.EMPTY
            }
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs
  var hslgl;
  var init_GLhls = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs"() {
      "use strict";
      hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs
  var hslgpu;
  var init_GPUhls = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs"() {
      "use strict";
      hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs
  var ColorBlend;
  var init_ColorBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      ColorBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      ColorBlend.extension = {
        name: "color",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs
  var ColorBurnBlend;
  var init_ColorBurnBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      ColorBurnBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
              functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      ColorBurnBlend.extension = {
        name: "color-burn",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs
  var ColorDodgeBlend;
  var init_ColorDodgeBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      ColorDodgeBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      ColorDodgeBlend.extension = {
        name: "color-dodge",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs
  var DarkenBlend;
  var init_DarkenBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      DarkenBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      DarkenBlend.extension = {
        name: "darken",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs
  var DifferenceBlend;
  var init_DifferenceBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      DifferenceBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
              functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      DifferenceBlend.extension = {
        name: "difference",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs
  var DivideBlend;
  var init_DivideBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      DivideBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      DivideBlend.extension = {
        name: "divide",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs
  var ExclusionBlend;
  var init_ExclusionBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      ExclusionBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      ExclusionBlend.extension = {
        name: "exclusion",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs
  var HardLightBlend;
  var init_HardLightBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      HardLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
              functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      HardLightBlend.extension = {
        name: "hard-light",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs
  var HardMixBlend;
  var init_HardMixBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      HardMixBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
              functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      HardMixBlend.extension = {
        name: "hard-mix",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs
  var LightenBlend;
  var init_LightenBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      LightenBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      LightenBlend.extension = {
        name: "lighten",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs
  var LinearBurnBlend;
  var init_LinearBurnBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      LinearBurnBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      LinearBurnBlend.extension = {
        name: "linear-burn",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs
  var LinearDodgeBlend;
  var init_LinearDodgeBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      LinearDodgeBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      LinearDodgeBlend.extension = {
        name: "linear-dodge",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs
  var LinearLightBlend;
  var init_LinearLightBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      LinearLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      LinearLightBlend.extension = {
        name: "linear-light",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs
  var LuminosityBlend;
  var init_LuminosityBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      LuminosityBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      LuminosityBlend.extension = {
        name: "luminosity",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs
  var NegationBlend;
  var init_NegationBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      NegationBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      NegationBlend.extension = {
        name: "negation",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs
  var OverlayBlend;
  var init_OverlayBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      OverlayBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );
   
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      OverlayBlend.extension = {
        name: "overlay",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs
  var PinLightBlend;
  var init_PinLightBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      PinLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      PinLightBlend.extension = {
        name: "pin-light",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs
  var SaturationBlend;
  var init_SaturationBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      SaturationBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
              functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
            }
          });
        }
      };
      SaturationBlend.extension = {
        name: "saturation",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs
  var SoftLightBlend;
  var init_SoftLightBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      SoftLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      SoftLightBlend.extension = {
        name: "soft-light",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs
  var SubtractBlend;
  var init_SubtractBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      SubtractBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
            },
            gpu: {
              functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      SubtractBlend.extension = {
        name: "subtract",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs
  var VividLightBlend;
  var init_VividLightBlend = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs"() {
      init_Extensions();
      init_BlendModeFilter();
      VividLightBlend = class extends BlendModeFilter {
        constructor() {
          super({
            gl: {
              functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
              main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
            },
            gpu: {
              functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
              main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
            }
          });
        }
      };
      VividLightBlend.extension = {
        name: "vivid-light",
        type: ExtensionType.BlendMode
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
  async function loadEnvironmentExtensions(skip) {
    if (skip)
      return;
    for (let i3 = 0; i3 < environments.length; i3++) {
      const env = environments[i3];
      if (env.value.test()) {
        await env.value.load();
        return;
      }
    }
  }
  async function autoDetectEnvironment(add) {
    return loadEnvironmentExtensions(!add);
  }
  var environments;
  var init_autoDetectEnvironment = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs"() {
      init_Extensions();
      environments = [];
      extensions.handleByNamedList(ExtensionType.Environment, environments);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e2) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var unsafeEval;
  var init_unsafeEvalSupported = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
  var CLEAR;
  var init_const7 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
      "use strict";
      CLEAR = /* @__PURE__ */ ((CLEAR2) => {
        CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
        CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
        CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
        CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
        CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
        CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
        CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
        CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
        return CLEAR2;
      })(CLEAR || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
  var SystemRunner;
  var init_SystemRunner = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
      "use strict";
      SystemRunner = class {
        /**
         * @param name - The function name that will be executed on the listeners added to this Runner.
         */
        constructor(name) {
          this.items = [];
          this._name = name;
        }
        /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
        /**
         * Dispatch/Broadcast Runner to all listeners added to the queue.
         * @param {...any} params - (optional) parameters to pass to each listener
         */
        /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          const { name, items } = this;
          for (let i3 = 0, len = items.length; i3 < len; i3++) {
            items[i3][name](a0, a1, a2, a3, a4, a5, a6, a7);
          }
          return this;
        }
        /**
         * Add a listener to the Runner
         *
         * Runners do not need to have scope or functions passed to them.
         * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
         * as the name provided to the Runner when it was created.
         *
         * Eg A listener passed to this Runner will require a 'complete' function.
         *
         * ```
         * import { Runner } from 'pixi.js';
         *
         * const complete = new Runner('complete');
         * ```
         *
         * The scope used will be the object itself.
         * @param {any} item - The object that will be listening.
         */
        add(item) {
          if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
          }
          return this;
        }
        /**
         * Remove a single listener from the dispatch queue.
         * @param {any} item - The listener that you would like to remove.
         */
        remove(item) {
          const index = this.items.indexOf(item);
          if (index !== -1) {
            this.items.splice(index, 1);
          }
          return this;
        }
        /**
         * Check to see if the listener is already in the Runner
         * @param {any} item - The listener that you would like to check.
         */
        contains(item) {
          return this.items.indexOf(item) !== -1;
        }
        /** Remove all listeners from the Runner */
        removeAll() {
          this.items.length = 0;
          return this;
        }
        /** Remove all references, don't use after this. */
        destroy() {
          this.removeAll();
          this.items = null;
          this._name = null;
        }
        /**
         * `true` if there are no this Runner contains no listeners
         * @readonly
         */
        get empty() {
          return this.items.length === 0;
        }
        /**
         * The name of the runner.
         * @readonly
         */
        get name() {
          return this._name;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners, _AbstractRenderer, AbstractRenderer;
  var init_AbstractRenderer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
      init_Color();
      init_autoDetectEnvironment();
      init_Container();
      init_unsafeEvalSupported();
      init_deprecation();
      init_const7();
      init_SystemRunner();
      init_eventemitter3();
      defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
        /**
         * Set up a system with a collection of SystemClasses and runners.
         * Systems are attached dynamically to this class when added.
         * @param config - the config for the system manager
         */
        constructor(config3) {
          super();
          this.runners = /* @__PURE__ */ Object.create(null);
          this.renderPipes = /* @__PURE__ */ Object.create(null);
          this._initOptions = {};
          this._systemsHash = /* @__PURE__ */ Object.create(null);
          this.type = config3.type;
          this.name = config3.name;
          this.config = config3;
          const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
          this._addRunners(...combinedRunners);
          this._unsafeEvalCheck();
        }
        /**
         * Initialize the renderer.
         * @param options - The options to use to create the renderer.
         */
        async init(options = {}) {
          const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
          await loadEnvironmentExtensions(skip);
          this._addSystems(this.config.systems);
          this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
          for (const systemName in this._systemsHash) {
            const system = this._systemsHash[systemName];
            const defaultSystemOptions = system.constructor.defaultOptions;
            options = { ...defaultSystemOptions, ...options };
          }
          options = { ..._AbstractRenderer2.defaultOptions, ...options };
          this._roundPixels = options.roundPixels ? 1 : 0;
          for (let i3 = 0; i3 < this.runners.init.items.length; i3++) {
            await this.runners.init.items[i3].init(options);
          }
          this._initOptions = options;
        }
        render(args, deprecated) {
          let options = args;
          if (options instanceof Container) {
            options = { container: options };
            if (deprecated) {
              deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
              options.target = deprecated.renderTexture;
            }
          }
          options.target || (options.target = this.view.renderTarget);
          if (options.target === this.view.renderTarget) {
            this._lastObjectRendered = options.container;
            options.clearColor = this.background.colorRgba;
          }
          if (options.clearColor) {
            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
          }
          if (!options.transform) {
            options.container.updateLocalTransform();
            options.transform = options.container.localTransform;
          }
          this.runners.prerender.emit(options);
          this.runners.renderStart.emit(options);
          this.runners.render.emit(options);
          this.runners.renderEnd.emit(options);
          this.runners.postrender.emit(options);
        }
        /**
         * Resizes the WebGL view to the specified width and height.
         * @param desiredScreenWidth - The desired width of the screen.
         * @param desiredScreenHeight - The desired height of the screen.
         * @param resolution - The resolution / device pixel ratio of the renderer.
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          const previousResolution = this.view.resolution;
          this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
          if (resolution !== void 0 && resolution !== previousResolution) {
            this.runners.resolutionChange.emit(resolution);
          }
        }
        clear(options = {}) {
          const renderer = this;
          options.target || (options.target = renderer.renderTarget.renderTarget);
          options.clearColor || (options.clearColor = this.background.colorRgba);
          options.clear ?? (options.clear = CLEAR.ALL);
          const { clear, clearColor, target } = options;
          Color.shared.setValue(clearColor ?? this.background.colorRgba);
          renderer.renderTarget.clear(target, clear, Color.shared.toArray());
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.view.resolution;
        }
        set resolution(value) {
          this.view.resolution = value;
          this.runners.resolutionChange.emit(value);
        }
        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         * @member {number}
         * @readonly
         * @default 800
         */
        get width() {
          return this.view.texture.frame.width;
        }
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         * @default 600
         */
        get height() {
          return this.view.texture.frame.height;
        }
        // NOTE: this was `view` in v7
        /**
         * The canvas element that everything is drawn to.
         * @type {environment.ICanvas}
         */
        get canvas() {
          return this.view.canvas;
        }
        /**
         * the last object rendered by the renderer. Useful for other plugins like interaction managers
         * @readonly
         */
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        /**
         * Flag if we are rendering to the screen vs renderTexture
         * @readonly
         * @default true
         */
        get renderingToScreen() {
          const renderer = this;
          return renderer.renderTarget.renderingToScreen;
        }
        /**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         */
        get screen() {
          return this.view.screen;
        }
        /**
         * Create a bunch of runners based of a collection of ids
         * @param runnerIds - the runner ids to add
         */
        _addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new SystemRunner(runnerId);
          });
        }
        _addSystems(systems3) {
          let i3;
          for (i3 in systems3) {
            const val = systems3[i3];
            this._addSystem(val.value, val.name);
          }
        }
        /**
         * Add a new system to the renderer.
         * @param ClassRef - Class reference
         * @param name - Property name for system, if not specified
         *        will use a static `name` property on the class itself. This
         *        name will be assigned as s property on the Renderer so make
         *        sure it doesn't collide with properties on Renderer.
         * @returns Return instance of renderer
         */
        _addSystem(ClassRef, name) {
          const system = new ClassRef(this);
          if (this[name]) {
            throw new Error(`Whoops! The name "${name}" is already in use`);
          }
          this[name] = system;
          this._systemsHash[name] = system;
          for (const i3 in this.runners) {
            this.runners[i3].add(system);
          }
          return this;
        }
        _addPipes(pipes, pipeAdaptors) {
          const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
            acc[adaptor.name] = adaptor.value;
            return acc;
          }, {});
          pipes.forEach((pipe3) => {
            const PipeClass = pipe3.value;
            const name = pipe3.name;
            const Adaptor = adaptors[name];
            this.renderPipes[name] = new PipeClass(
              this,
              Adaptor ? new Adaptor() : null
            );
          });
        }
        destroy(options = false) {
          this.runners.destroy.items.reverse();
          this.runners.destroy.emit(options);
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          });
          this._systemsHash = null;
          this.renderPipes = null;
        }
        /**
         * Generate a texture from a container.
         * @param options - options or container target to use when generating the texture
         * @returns a texture
         */
        generateTexture(options) {
          return this.textureGenerator.generateTexture(options);
        }
        /**
         * Whether the renderer will round coordinates to whole pixels when rendering.
         * Can be overridden on a per scene item basis.
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        /**
         * Overridable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         * @ignore
         */
        _unsafeEvalCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
      };
      _AbstractRenderer.defaultOptions = {
        /**
         * Default resolution / device pixel ratio of the renderer.
         * @default 1
         */
        resolution: 1,
        /**
         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
         * performance issues when using WebGL.
         *
         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
         * driver version blacklisted by the
         * browser.
         *
         * If your application requires high performance rendering, you may wish to set this to false.
         * We recommend one of two options if you decide to set this flag to false:
         *
         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
         *    not supported.
         *
         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
         *    device & browser combination does not support high performance WebGL.
         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
         * @default false
         */
        failIfMajorPerformanceCaveat: false,
        /**
         * Should round pixels be forced when rendering?
         * @default false
         */
        roundPixels: false
      };
      AbstractRenderer = _AbstractRenderer;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
  function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas = DOMAdapter.get().createCanvas();
        let gl = canvas.getContext("webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }
  var _isWebGLSupported;
  var init_isWebGLSupported = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs"() {
      init_adapter();
      init_AbstractRenderer();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
  async function isWebGPUSupported(options = {}) {
    if (_isWebGPUSupported !== void 0)
      return _isWebGPUSupported;
    _isWebGPUSupported = await (async () => {
      const gpu = DOMAdapter.get().getNavigator().gpu;
      if (!gpu) {
        return false;
      }
      try {
        const adapter = await gpu.requestAdapter(options);
        await adapter.requestDevice();
        return true;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGPUSupported;
  }
  var _isWebGPUSupported;
  var init_isWebGPUSupported = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor;
  var init_GpuGraphicsAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_maxRecommendedTextures();
      init_getTextureBatchBindGroup();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      GpuGraphicsAdaptor = class {
        init() {
          const localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "graphics",
            bits: [
              colorBit,
              generateTextureBatchBit(getMaxTexturesPerBatch()),
              localUniformBitGroup2,
              roundPixelsBit
            ]
          });
          this.shader = new Shader({
            gpuProgram: gpuProgram3,
            resources: {
              // added on the fly!
              localUniforms
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context4 = renderable.context;
          const shader = context4.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context4);
          const encoder = renderer.encoder;
          encoder.setPipelineFromGeometryProgramAndState(
            batcher.geometry,
            shader.gpuProgram,
            graphicsPipe.state
          );
          encoder.setGeometry(batcher.geometry, shader.gpuProgram);
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
          const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
          encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
          const batches = instructions.instructions;
          for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
            const batch = batches[i3];
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
              const textureBatch = batch.textures;
              batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
              batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
                batch.bindGroup,
                shader.gpuProgram,
                1
              );
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GpuGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
  var textureBit, textureBitGl;
  var init_textureBit = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
      "use strict";
      textureBit = {
        name: "texture-bit",
        vertex: {
          header: (
            /* wgsl */
            `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
          ),
          main: (
            /* wgsl */
            `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
          )
        }
      };
      textureBitGl = {
        name: "texture-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureMatrix;
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
        uniform sampler2D uTexture;

         
        `
          ),
          main: (
            /* glsl */
            `
            outColor = texture(uTexture, vUV);
        `
          )
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter;
  var init_GpuMeshAdapter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GpuMeshAdapter = class {
        init() {
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "mesh",
            bits: [
              localUniformBit,
              textureBit,
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram: gpuProgram3,
            resources: {
              uTexture: Texture.EMPTY._source,
              uSampler: Texture.EMPTY._source.style,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
          } else if (!shader.gpuProgram) {
            warn("Mesh shader has no gpuProgram", mesh.shader);
            return;
          }
          const gpuProgram3 = shader.gpuProgram;
          if (gpuProgram3.autoAssignGlobalUniforms) {
            shader.groups[0] = renderer.globalUniforms.bindGroup;
          }
          if (gpuProgram3.autoAssignLocalUniforms) {
            const localUniforms = meshPipe.localUniforms;
            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
          }
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuMeshAdapter.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState, GpuBatchAdaptor;
  var init_GpuBatchAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
      init_Extensions();
      init_State();
      init_getTextureBatchBindGroup();
      tempState = State.for2d();
      GpuBatchAdaptor = class {
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          const program = shader.gpuProgram;
          this._shader = shader;
          this._geometry = geometry;
          encoder.setGeometry(geometry, program);
          tempState.blendMode = "normal";
          renderer.pipeline.getPipeline(
            geometry,
            program,
            tempState
          );
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.resetBindGroup(1);
          encoder.setBindGroup(0, globalUniformsBindGroup, program);
        }
        execute(batchPipe, batch) {
          const program = this._shader.gpuProgram;
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          if (!batch.bindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          }
          tempState.blendMode = batch.blendMode;
          const gpuBindGroup = renderer.bindGroup.getBindGroup(
            batch.bindGroup,
            program,
            1
          );
          const pipeline = renderer.pipeline.getPipeline(
            this._geometry,
            program,
            tempState
          );
          batch.bindGroup._touch(renderer.textureGC.count);
          encoder.setPipeline(pipeline);
          encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      };
      GpuBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
  var CustomRenderPipe;
  var init_CustomRenderPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
      init_Extensions();
      CustomRenderPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        updateRenderable() {
        }
        destroyRenderable() {
        }
        validateRenderable() {
          return false;
        }
        addRenderable(container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(container);
        }
        execute(container) {
          if (!container.isRenderable)
            return;
          container.render(this._renderer);
        }
        destroy() {
          this._renderer = null;
        }
      };
      CustomRenderPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "customRender"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i3 = 0; i3 < instructionSet.instructionSize; i3++) {
      const instruction = instructions[i3];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }
  var init_executeInstructions = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
  var RenderGroupPipe;
  var init_RenderGroupPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
      init_Extensions();
      init_executeInstructions();
      RenderGroupPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderGroup(renderGroup, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderGroup);
        }
        execute(renderGroup) {
          if (!renderGroup.isRenderable)
            return;
          this._renderer.globalUniforms.push({
            worldTransformMatrix: renderGroup.worldTransform,
            worldColor: renderGroup.worldColorAlpha
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.globalUniforms.pop();
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs
  function buildInstructions(renderGroup, rendererOrPipes) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    const renderPipes3 = renderer.renderPipes;
    renderPipes3.batch.buildStart(instructionSet);
    renderPipes3.blendMode.buildStart();
    renderPipes3.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    collectAllRenderablesAdvanced(root, instructionSet, renderer, true);
    renderPipes3.batch.buildEnd(instructionSet);
    renderPipes3.blendMode.buildEnd(instructionSet);
  }
  function collectAllRenderables(container, instructionSet, rendererOrPipes) {
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    if (container.globalDisplayStatus < 7 || !container.includeInBuild)
      return;
    if (container.sortableChildren) {
      container.sortChildren();
    }
    if (container.isSimple) {
      collectAllRenderablesSimple(container, instructionSet, renderer);
    } else {
      collectAllRenderablesAdvanced(container, instructionSet, renderer, false);
    }
  }
  function collectAllRenderablesSimple(container, instructionSet, renderer) {
    if (container.renderPipeId) {
      const renderable = container;
      const { renderPipes: renderPipes3, renderableGC } = renderer;
      renderPipes3.blendMode.setBlendMode(renderable, container.groupBlendMode, instructionSet);
      const rp = renderPipes3;
      rp[renderable.renderPipeId].addRenderable(renderable, instructionSet);
      renderableGC.addRenderable(renderable, instructionSet);
      renderable.didViewUpdate = false;
    }
    if (!container.renderGroup) {
      const children = container.children;
      const length = children.length;
      for (let i3 = 0; i3 < length; i3++) {
        collectAllRenderables(children[i3], instructionSet, renderer);
      }
    }
  }
  function collectAllRenderablesAdvanced(container, instructionSet, renderer, isRoot) {
    const { renderPipes: renderPipes3, renderableGC } = renderer;
    if (!isRoot && container.renderGroup) {
      renderPipes3.renderGroup.addRenderGroup(container.renderGroup, instructionSet);
    } else {
      for (let i3 = 0; i3 < container.effects.length; i3++) {
        const effect = container.effects[i3];
        const pipe3 = renderPipes3[effect.pipe];
        pipe3.push(effect, container, instructionSet);
      }
      const renderable = container;
      const renderPipeId = renderable.renderPipeId;
      if (renderPipeId) {
        renderPipes3.blendMode.setBlendMode(renderable, renderable.groupBlendMode, instructionSet);
        const pipe3 = renderPipes3[renderPipeId];
        pipe3.addRenderable(renderable, instructionSet);
        renderableGC.addRenderable(renderable, instructionSet);
        renderable.didViewUpdate = false;
      }
      const children = container.children;
      if (children.length) {
        for (let i3 = 0; i3 < children.length; i3++) {
          collectAllRenderables(children[i3], instructionSet, renderer);
        }
      }
      for (let i3 = container.effects.length - 1; i3 >= 0; i3--) {
        const effect = container.effects[i3];
        const pipe3 = renderPipes3[effect.pipe];
        pipe3.pop(effect, container, instructionSet);
      }
    }
  }
  var init_buildInstructions = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
  function clearList(list, index) {
    index || (index = 0);
    for (let j2 = index; j2 < list.length; j2++) {
      if (list[j2]) {
        list[j2] = null;
      } else {
        break;
      }
    }
  }
  var init_clearList = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/clearList.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs
  function collectRenderGroups(renderGroup, out2 = []) {
    out2.push(renderGroup);
    for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
      collectRenderGroups(renderGroup.renderGroupChildren[i3], out2);
    }
    return out2;
  }
  var init_collectRenderGroups = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
  function mixHexColors(color1, color2, ratio) {
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 + (r2 - r1) * ratio;
    const g3 = g1 + (g2 - g1) * ratio;
    const b3 = b1 + (b2 - b1) * ratio;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_mixHexColors = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs
  function mixColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      return localBGRColor + parentBGRColor - WHITE_BGR;
    }
    return mixHexColors(localBGRColor, parentBGRColor, 0.5);
  }
  function mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {
    const parentAlpha = (parentColor >> 24 & 255) / 255;
    const globalAlpha = localAlpha * parentAlpha * 255;
    const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);
    const parentBGRColor = parentColor & 16777215;
    let sharedBGRColor;
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;
    } else {
      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);
    }
    return sharedBGRColor + (globalAlpha << 24);
  }
  var WHITE_BGR;
  var init_mixColors = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs"() {
      init_mixHexColors();
      WHITE_BGR = 16777215;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
  function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const renderGroupDepth = Number(j2);
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index = childrenAtDepth.index;
      for (let i3 = 0; i3 < index; i3++) {
        const child = list[i3];
        if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
          updateTransformAndChildren(child, updateTick, 0);
        }
      }
      clearList(list, index);
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
        updateRenderGroupTransforms(renderGroup.renderGroupChildren[i3], updateChildRenderGroups);
      }
    }
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
      const renderGroupParent = renderGroup.renderGroupParent;
      renderGroup.worldTransform.appendFrom(
        root.relativeGroupTransform,
        renderGroupParent.worldTransform
      );
      renderGroup.worldColor = mixColors(
        root.groupColor,
        renderGroupParent.worldColor
      );
      worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
      renderGroup.worldTransform.copyFrom(root.localTransform);
      renderGroup.worldColor = root.localColor;
      worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent = container.parent;
    if (parent && !parent.renderGroup) {
      updateFlags = updateFlags | container._updateFlags;
      container.relativeGroupTransform.appendFrom(
        localTransform,
        parent.relativeGroupTransform
      );
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, parent, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.renderGroup) {
      const children = container.children;
      const length = children.length;
      for (let i3 = 0; i3 < length; i3++) {
        updateTransformAndChildren(children[i3], updateTick, updateFlags);
      }
      const renderGroup = container.parentRenderGroup;
      const renderable = container;
      if (renderable.renderPipeId && !renderGroup.structureDidChange) {
        renderGroup.updateRenderable(renderable);
      }
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = mixColors(
        container.localColor,
        parent.groupColor
      );
      let groupAlpha = container.localAlpha * parent.groupAlpha;
      groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
      container.groupAlpha = groupAlpha;
      container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }
  var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
  var init_updateRenderGroupTransforms = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
      init_Container();
      init_clearList();
      init_mixColors();
      tempContainer = new Container();
      UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
  function validateRenderables(renderGroup, renderPipes3) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i3 = 0; i3 < index; i3++) {
      const container = list[i3];
      const renderable = container;
      const pipe3 = renderPipes3[renderable.renderPipeId];
      rebuildRequired = pipe3.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
  }
  var init_validateRenderables = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
  function updateRenderables(renderGroup) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    for (let i3 = 0; i3 < index; i3++) {
      const container = list[i3];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
    clearList(list, index);
  }
  var tempMatrix5, RenderGroupSystem;
  var init_RenderGroupSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_buildInstructions();
      init_clearList();
      init_collectRenderGroups();
      init_executeInstructions();
      init_updateRenderGroupTransforms();
      init_validateRenderables();
      tempMatrix5 = new Matrix();
      RenderGroupSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        render({ container, transform: transform2 }) {
          container.isRenderGroup = true;
          const parent = container.parent;
          const renderGroupParent = container.renderGroup.renderGroupParent;
          container.parent = null;
          container.renderGroup.renderGroupParent = null;
          const renderer = this._renderer;
          const renderGroups = collectRenderGroups(container.renderGroup, []);
          let originalLocalTransform = tempMatrix5;
          if (transform2) {
            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
            container.renderGroup.localTransform.copyFrom(transform2);
          }
          const renderPipes3 = renderer.renderPipes;
          for (let i3 = 0; i3 < renderGroups.length; i3++) {
            const renderGroup = renderGroups[i3];
            renderGroup.runOnRender();
            renderGroup.instructionSet.renderPipes = renderPipes3;
            if (!renderGroup.structureDidChange) {
              validateRenderables(renderGroup, renderPipes3);
            } else {
              clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
            }
            updateRenderGroupTransforms(renderGroup);
            if (renderGroup.structureDidChange) {
              renderGroup.structureDidChange = false;
              buildInstructions(renderGroup, renderer);
            } else {
              updateRenderables(renderGroup);
            }
            renderGroup.childrenRenderablesToUpdate.index = 0;
            renderer.renderPipes.batch.upload(renderGroup.instructionSet);
          }
          renderer.globalUniforms.start({
            worldTransformMatrix: transform2 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
            worldColor: container.renderGroup.worldColorAlpha
          });
          executeInstructions(container.renderGroup, renderPipes3);
          if (renderPipes3.uniformBatch) {
            renderPipes3.uniformBatch.renderEnd();
          }
          if (transform2) {
            container.renderGroup.localTransform.copyFrom(originalLocalTransform);
          }
          container.parent = parent;
          container.renderGroup.renderGroupParent = renderGroupParent;
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
  var SpritePipe;
  var init_SpritePipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableSprite();
      SpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableSprite = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableSprite);
          this._gpuSpriteHash[sprite.uid] = null;
          sprite.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableSprite = BigPool.get(BatchableSprite);
          batchableSprite.renderable = sprite;
          batchableSprite.transform = sprite.groupTransform;
          batchableSprite.texture = sprite._texture;
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableSprite;
          sprite.on("destroyed", this._destroyRenderableBound);
          return batchableSprite;
        }
        destroy() {
          for (const i3 in this._gpuSpriteHash) {
            BigPool.return(this._gpuSpriteHash[i3]);
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      SpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "sprite"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/const.mjs
  var DATA_URI, VERSION;
  var init_const8 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/const.mjs"() {
      init_eventemitter3();
      DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
      VERSION = "8.5.2";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/global/globalHooks.mjs
  var ApplicationInitHook, RendererInitHook;
  var init_globalHooks = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/global/globalHooks.mjs"() {
      init_Extensions();
      init_const8();
      ApplicationInitHook = class {
        static init() {
          globalThis.__PIXI_APP_INIT__?.(this, VERSION);
        }
        static destroy() {
        }
      };
      ApplicationInitHook.extension = ExtensionType.Application;
      RendererInitHook = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        init() {
          globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
        }
        destroy() {
          this._renderer = null;
        }
      };
      RendererInitHook.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
  var _BatcherPipe, BatcherPipe;
  var init_BatcherPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
      init_Extensions();
      init_State();
      init_DefaultBatcher();
      _BatcherPipe = class _BatcherPipe2 {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
          this._activeBatches = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init?.(this);
        }
        static getBatcher(name) {
          return new this._availableBatchers[name]();
        }
        buildStart(instructionSet) {
          let batchers = this._batchersByInstructionSet[instructionSet.uid];
          if (!batchers) {
            batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
            batchers.default || (batchers.default = new DefaultBatcher());
          }
          this._activeBatches = batchers;
          this._activeBatch = this._activeBatches.default;
          for (const i3 in this._activeBatches) {
            this._activeBatches[i3].begin();
          }
        }
        addToBatch(batchableObject, instructionSet) {
          if (this._activeBatch.name !== batchableObject.batcherName) {
            this._activeBatch.break(instructionSet);
            let batch = this._activeBatches[batchableObject.batcherName];
            if (!batch) {
              batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
              batch.begin();
            }
            this._activeBatch = batch;
          }
          this._activeBatch.add(batchableObject);
        }
        break(instructionSet) {
          this._activeBatch.break(instructionSet);
        }
        buildEnd(instructionSet) {
          this._activeBatch.break(instructionSet);
          const batches = this._activeBatches;
          for (const i3 in batches) {
            const batch = batches[i3];
            const geometry = batch.geometry;
            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
          }
        }
        upload(instructionSet) {
          const batchers = this._batchersByInstructionSet[instructionSet.uid];
          for (const i3 in batchers) {
            const batcher = batchers[i3];
            const geometry = batcher.geometry;
            if (batcher.dirty) {
              batcher.dirty = false;
              geometry.buffers[0].update(batcher.attributeSize * 4);
            }
          }
        }
        execute(batch) {
          if (batch.action === "startBatch") {
            const batcher = batch.batcher;
            const geometry = batcher.geometry;
            const shader = batcher.shader;
            this._adaptor.start(this, geometry, shader);
          }
          this._adaptor.execute(this, batch);
        }
        destroy() {
          this.state = null;
          this.renderer = null;
          this._adaptor = null;
          for (const i3 in this._activeBatches) {
            this._activeBatches[i3].destroy();
          }
          this._activeBatches = null;
        }
      };
      _BatcherPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "batch"
      };
      _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
      BatcherPipe = _BatcherPipe;
      extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
      extensions.add(DefaultBatcher);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
  var fragment2;
  var init_mask_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
      fragment2 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
  var vertex2;
  var init_mask_vert = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
      vertex2 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
  var source;
  var init_mask_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
      source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
  var MaskFilter;
  var init_MaskFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_TextureMatrix();
      init_Filter();
      init_mask_frag();
      init_mask_vert();
      init_mask_wgsl();
      MaskFilter = class extends Filter {
        constructor(options) {
          const { sprite, ...rest } = options;
          const textureMatrix = new TextureMatrix(sprite.texture);
          const filterUniforms = new UniformGroup({
            uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
            uAlpha: { value: 1, type: "f32" },
            uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
          });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source,
              entryPoint: "mainVertex"
            },
            fragment: {
              source,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex2,
            fragment: fragment2,
            name: "mask-filter"
          });
          super({
            ...rest,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              filterUniforms,
              uMaskTexture: sprite.texture.source
            }
          });
          this.sprite = sprite;
          this._textureMatrix = textureMatrix;
        }
        set inverse(value) {
          this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
        }
        get inverse() {
          return this.resources.filterUniforms.uniforms.uInverse === 1;
        }
        apply(filterManager, input, output, clearMode) {
          this._textureMatrix.texture = this.sprite.texture;
          filterManager.calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.uFilterMatrix,
            this.sprite
          ).prepend(this._textureMatrix.mapCoord);
          this.resources.uMaskTexture = this.sprite.texture.source;
          filterManager.applyFilter(this, input, output, clearMode);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
  var init_AlphaMaskPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_MaskFilter();
      init_Bounds();
      init_getGlobalBounds();
      init_buildInstructions();
      init_Sprite();
      init_PoolGroup();
      init_Texture();
      init_TexturePool();
      init_types2();
      tempBounds3 = new Bounds();
      AlphaMaskEffect = class extends FilterEffect {
        constructor() {
          super();
          this.filters = [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY),
            inverse: false,
            resolution: "inherit",
            antialias: "inherit"
          })];
        }
        get sprite() {
          return this.filters[0].sprite;
        }
        set sprite(value) {
          this.filters[0].sprite = value;
        }
        get inverse() {
          return this.filters[0].inverse;
        }
        set inverse(value) {
          this.filters[0].inverse = value;
        }
      };
      AlphaMaskPipe = class {
        constructor(renderer) {
          this._activeMaskStage = [];
          this._renderer = renderer;
        }
        push(mask, maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskBegin",
            mask,
            inverse: maskedContainer._maskOptions.inverse,
            canBundle: false,
            maskedContainer
          });
          mask.inverse = maskedContainer._maskOptions.inverse;
          if (mask.renderMaskToTexture) {
            const maskContainer = mask.mask;
            maskContainer.includeInBuild = true;
            collectAllRenderables(
              maskContainer,
              instructionSet,
              renderer
            );
            maskContainer.includeInBuild = false;
          }
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask,
            maskedContainer,
            inverse: maskedContainer._maskOptions.inverse,
            canBundle: false
          });
        }
        pop(mask, _maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask,
            inverse: _maskedContainer._maskOptions.inverse,
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderMask = instruction.mask.renderMaskToTexture;
          if (instruction.action === "pushMaskBegin") {
            const filterEffect = BigPool.get(AlphaMaskEffect);
            filterEffect.inverse = instruction.inverse;
            if (renderMask) {
              instruction.mask.mask.measurable = true;
              const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
              instruction.mask.mask.measurable = false;
              bounds.ceil();
              const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
              const filterTexture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                colorTextureSource._resolution,
                colorTextureSource.antialias
              );
              renderer.renderTarget.push(filterTexture, true);
              renderer.globalUniforms.push({
                offset: bounds,
                worldColor: 4294967295
              });
              const sprite = filterEffect.sprite;
              sprite.texture = filterTexture;
              sprite.worldTransform.tx = bounds.minX;
              sprite.worldTransform.ty = bounds.minY;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer,
                filterTexture
              });
            } else {
              filterEffect.sprite = instruction.mask.mask;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer
              });
            }
          } else if (instruction.action === "pushMaskEnd") {
            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
            if (renderMask) {
              if (renderer.type === RendererType.WEBGL) {
                renderer.renderTarget.finishRenderPass();
              }
              renderer.renderTarget.pop();
              renderer.globalUniforms.pop();
            }
            renderer.filter.push({
              renderPipeId: "filter",
              action: "pushFilter",
              container: maskData.maskedContainer,
              filterEffect: maskData.filterEffect,
              canBundle: false
            });
          } else if (instruction.action === "popMaskEnd") {
            renderer.filter.pop();
            const maskData = this._activeMaskStage.pop();
            if (renderMask) {
              TexturePool.returnTexture(maskData.filterTexture);
            }
            BigPool.return(maskData.filterEffect);
          }
        }
        destroy() {
          this._renderer = null;
          this._activeMaskStage = null;
        }
      };
      AlphaMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "alphaMask"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe;
  var init_ColorMaskPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
      init_Extensions();
      ColorMaskPipe = class {
        constructor(renderer) {
          this._colorStack = [];
          this._colorStackIndex = 0;
          this._currentColor = 0;
          this._renderer = renderer;
        }
        buildStart() {
          this._colorStack[0] = 15;
          this._colorStackIndex = 1;
          this._currentColor = 15;
        }
        push(mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
          const currentColor = this._colorStack[this._colorStackIndex];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
          this._colorStackIndex++;
        }
        pop(_mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          this._colorStackIndex--;
          const currentColor = colorStack[this._colorStackIndex - 1];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
        }
        execute(instruction) {
          const renderer = this._renderer;
          renderer.colorMask.setMask(instruction.colorMask);
        }
        destroy() {
          this._colorStack = null;
        }
      };
      ColorMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe;
  var init_StencilMaskPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
      init_Extensions();
      init_buildInstructions();
      init_const7();
      init_const3();
      StencilMaskPipe = class {
        constructor(renderer) {
          this._maskStackHash = {};
          this._maskHash = /* @__PURE__ */ new WeakMap();
          this._renderer = renderer;
        }
        push(mask, _container, instructionSet) {
          var _a;
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask,
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const maskContainer = effect.mask;
          maskContainer.includeInBuild = true;
          if (!this._maskHash.has(effect)) {
            this._maskHash.set(effect, {
              instructionsStart: 0,
              instructionsLength: 0
            });
          }
          const maskData = this._maskHash.get(effect);
          maskData.instructionsStart = instructionSet.instructionSize;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer
          );
          maskContainer.includeInBuild = false;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask,
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
          maskData.instructionsLength = instructionsLength;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
        }
        pop(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const maskData = this._maskHash.get(mask);
          for (let i3 = 0; i3 < maskData.instructionsLength; i3++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: false
          });
        }
        execute(instruction) {
          var _a;
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
          if (instruction.action === "pushMaskBegin") {
            renderer.renderTarget.ensureDepthStencil();
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
            maskStackIndex++;
            renderer.colorMask.setMask(0);
          } else if (instruction.action === "pushMaskEnd") {
            if (instruction.inverse) {
              renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          } else if (instruction.action === "popMaskBegin") {
            renderer.colorMask.setMask(0);
            if (maskStackIndex !== 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            } else {
              renderer.renderTarget.clear(null, CLEAR.STENCIL);
              renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
            }
            maskStackIndex--;
          } else if (instruction.action === "popMaskEnd") {
            if (instruction.inverse) {
              renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          }
          this._maskStackHash[renderTargetUid] = maskStackIndex;
        }
        destroy() {
          this._renderer = null;
          this._maskStackHash = null;
          this._maskHash = null;
        }
      };
      StencilMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "stencilMask"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem, BackgroundSystem;
  var init_BackgroundSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
      init_Color();
      init_Extensions();
      _BackgroundSystem = class _BackgroundSystem2 {
        constructor() {
          this.clearBeforeRender = true;
          this._backgroundColor = new Color(0);
          this.color = this._backgroundColor;
          this.alpha = 1;
        }
        /**
         * initiates the background system
         * @param options - the options for the background colors
         */
        init(options) {
          options = { ..._BackgroundSystem2.defaultOptions, ...options };
          this.clearBeforeRender = options.clearBeforeRender;
          this.color = options.background || options.backgroundColor || this._backgroundColor;
          this.alpha = options.backgroundAlpha;
          this._backgroundColor.setAlpha(options.backgroundAlpha);
        }
        /** The background color to fill if not transparent */
        get color() {
          return this._backgroundColor;
        }
        set color(value) {
          this._backgroundColor.setValue(value);
        }
        /** The background color alpha. Setting this to 0 will make the canvas transparent. */
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value) {
          this._backgroundColor.setAlpha(value);
        }
        /** The background color as an [R, G, B, A] array. */
        get colorRgba() {
          return this._backgroundColor.toArray();
        }
        /**
         * destroys the background system
         * @internal
         * @ignore
         */
        destroy() {
        }
      };
      _BackgroundSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "background",
        priority: 0
      };
      _BackgroundSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.backgroundAlpha}
         * @default 1
         */
        backgroundAlpha: 1,
        /**
         * {@link WebGLOptions.backgroundColor}
         * @default 0x000000
         */
        backgroundColor: 0,
        /**
         * {@link WebGLOptions.clearBeforeRender}
         * @default true
         */
        clearBeforeRender: true
      };
      BackgroundSystem = _BackgroundSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS, BlendModePipe;
  var init_BlendModePipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_warn();
      BLEND_MODE_FILTERS = {};
      extensions.handle(ExtensionType.BlendMode, (value) => {
        if (!value.name) {
          throw new Error("BlendMode extension must have a name property");
        }
        BLEND_MODE_FILTERS[value.name] = value.ref;
      }, (value) => {
        delete BLEND_MODE_FILTERS[value.name];
      });
      BlendModePipe = class {
        constructor(renderer) {
          this._isAdvanced = false;
          this._filterHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        /**
         * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
         * @param renderable - The renderable we are adding to the instruction set
         * @param blendMode - The blend mode of the renderable
         * @param instructionSet - The instruction set we are adding to
         */
        setBlendMode(renderable, blendMode, instructionSet) {
          if (this._activeBlendMode === blendMode) {
            if (this._isAdvanced)
              this._renderableList.push(renderable);
            return;
          }
          this._activeBlendMode = blendMode;
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
          this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
          if (this._isAdvanced) {
            this._beginAdvancedBlendMode(instructionSet);
            this._renderableList.push(renderable);
          }
        }
        _beginAdvancedBlendMode(instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          const blendMode = this._activeBlendMode;
          if (!BLEND_MODE_FILTERS[blendMode]) {
            warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return;
          }
          let filterEffect = this._filterHash[blendMode];
          if (!filterEffect) {
            filterEffect = this._filterHash[blendMode] = new FilterEffect();
            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
          }
          const instruction = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect,
            canBundle: false
          };
          this._renderableList = instruction.renderables;
          instructionSet.add(instruction);
        }
        _endAdvancedBlendMode(instructionSet) {
          this._renderableList = null;
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        /**
         * called when the instruction build process is starting this will reset internally to the default blend mode
         * @internal
         * @ignore
         */
        buildStart() {
          this._isAdvanced = false;
        }
        /**
         * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
         * active, we add the final render instructions added to the instruction set
         * @param instructionSet - The instruction set we are adding to
         * @internal
         * @ignore
         */
        buildEnd(instructionSet) {
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
        }
        /**
         * @internal
         * @ignore
         */
        destroy() {
          this._renderer = null;
          this._renderableList = null;
          for (const i3 in this._filterHash) {
            this._filterHash[i3].destroy();
          }
          this._filterHash = null;
        }
      };
      BlendModePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "blendMode"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var imageTypes, _ExtractSystem, ExtractSystem;
  var init_ExtractSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
      init_Extensions();
      init_Container();
      init_Texture();
      imageTypes = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
      };
      _ExtractSystem = class _ExtractSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
        }
        _normalizeOptions(options, defaults2 = {}) {
          if (options instanceof Container || options instanceof Texture) {
            return {
              target: options,
              ...defaults2
            };
          }
          return {
            ...defaults2,
            ...options
          };
        }
        /**
         * Will return a HTML Image of the target
         * @param options - The options for creating the image, or the target to extract
         * @returns - HTML Image of the target
         */
        async image(options) {
          const image = new Image();
          image.src = await this.base64(options);
          return image;
        }
        /**
         * Will return a base64 encoded string of this target. It works by calling
         * `Extract.canvas` and then running toDataURL on that.
         * @param options - The options for creating the image, or the target to extract
         */
        async base64(options) {
          options = this._normalizeOptions(
            options,
            _ExtractSystem2.defaultImageOptions
          );
          const { format, quality } = options;
          const canvas = this.canvas(options);
          if (canvas.toBlob !== void 0) {
            return new Promise((resolve, reject) => {
              canvas.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, imageTypes[format], quality);
            });
          }
          if (canvas.toDataURL !== void 0) {
            return canvas.toDataURL(imageTypes[format], quality);
          }
          if (canvas.convertToBlob !== void 0) {
            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            });
          }
          throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        /**
         * Creates a Canvas element, renders this target to it and then returns it.
         * @param options - The options for creating the canvas, or the target to extract
         * @returns - A Canvas element with the texture rendered on.
         */
        canvas(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          if (target instanceof Texture) {
            return renderer.texture.generateCanvas(target);
          }
          const texture = renderer.textureGenerator.generateTexture(options);
          const canvas = renderer.texture.generateCanvas(texture);
          texture.destroy();
          return canvas;
        }
        /**
         * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
         * order, with integer values between 0 and 255 (included).
         * @param options - The options for extracting the image, or the target to extract
         * @returns - One-dimensional array containing the pixel data of the entire texture
         */
        pixels(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
          const pixelInfo = renderer.texture.getPixels(texture);
          if (target instanceof Container) {
            texture.destroy();
          }
          return pixelInfo;
        }
        /**
         * Will return a texture of the target
         * @param options - The options for creating the texture, or the target to extract
         * @returns - A texture of the target
         */
        texture(options) {
          options = this._normalizeOptions(options);
          if (options.target instanceof Texture)
            return options.target;
          return this._renderer.textureGenerator.generateTexture(options);
        }
        /**
         * Will extract a HTMLImage of the target and download it
         * @param options - The options for downloading and extracting the image, or the target to extract
         */
        download(options) {
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const link = document.createElement("a");
          link.download = options.filename ?? "image.png";
          link.href = canvas.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        /**
         * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
         * @param options - The options for logging the image, or the target to log
         */
        log(options) {
          const width = options.width ?? 200;
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const base64 = canvas.toDataURL();
          console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
          const style = [
            "font-size: 1px;",
            `padding: ${width}px ${300}px;`,
            `background: url(${base64}) no-repeat;`,
            "background-size: contain;"
          ].join(" ");
          console.log("%c ", style);
        }
        destroy() {
          this._renderer = null;
        }
      };
      _ExtractSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "extract"
      };
      _ExtractSystem.defaultImageOptions = {
        /** The format of the image. */
        format: "png",
        /** The quality of the image. */
        quality: 1
      };
      ExtractSystem = _ExtractSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture;
  var init_RenderTexture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
      init_TextureSource();
      init_Texture();
      RenderTexture = class extends Texture {
        static create(options) {
          return new RenderTexture({
            source: new TextureSource(options)
          });
        }
        /**
         * Resizes the render texture.
         * @param width - The new width of the render texture.
         * @param height - The new height of the render texture.
         * @param resolution - The new resolution of the render texture.
         * @returns This texture.
         */
        resize(width, height, resolution) {
          this.source.resize(width, height, resolution);
          return this;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect2, tempBounds4, noColor, GenerateTextureSystem;
  var init_GenerateTextureSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_Matrix();
      init_Rectangle();
      init_Bounds();
      init_getLocalBounds();
      init_Container();
      init_RenderTexture();
      tempRect2 = new Rectangle();
      tempBounds4 = new Bounds();
      noColor = [0, 0, 0, 0];
      GenerateTextureSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * A Useful function that returns a texture of the display object that can then be used to create sprites
         * This can be quite useful if your container is complicated and needs to be reused multiple times.
         * @param {GenerateTextureOptions | Container} options - Generate texture options.
         * @param {Container} [options.container] - If not given, the renderer's resolution is used.
         * @param {Rectangle} options.region - The region of the container, that shall be rendered,
         * @param {number} [options.resolution] - The resolution of the texture being generated.
         *        if no region is specified, defaults to the local bounds of the container.
         * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
         * @returns a shiny new texture of the container passed in
         */
        generateTexture(options) {
          if (options instanceof Container) {
            options = {
              target: options,
              frame: void 0,
              textureSourceOptions: {},
              resolution: void 0
            };
          }
          const resolution = options.resolution || this._renderer.resolution;
          const antialias = options.antialias || this._renderer.view.antialias;
          const container = options.target;
          let clearColor = options.clearColor;
          if (clearColor) {
            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
          } else {
            clearColor = noColor;
          }
          const region = options.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds4).rectangle;
          region.width = Math.max(region.width, 1 / resolution) | 0;
          region.height = Math.max(region.height, 1 / resolution) | 0;
          const target = RenderTexture.create({
            ...options.textureSourceOptions,
            width: region.width,
            height: region.height,
            resolution,
            antialias
          });
          const transform2 = Matrix.shared.translate(-region.x, -region.y);
          this._renderer.render({
            container,
            transform: transform2,
            target,
            clearColor
          });
          target.source.updateMipmaps();
          return target;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GenerateTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGenerator"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem;
  var init_GlobalUniformSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_colorToUniform();
      init_BindGroup();
      init_types2();
      init_UniformGroup();
      GlobalUniformSystem = class {
        constructor(renderer) {
          this._stackIndex = 0;
          this._globalUniformDataStack = [];
          this._uniformsPool = [];
          this._activeUniforms = [];
          this._bindGroupPool = [];
          this._activeBindGroups = [];
          this._renderer = renderer;
        }
        reset() {
          this._stackIndex = 0;
          for (let i3 = 0; i3 < this._activeUniforms.length; i3++) {
            this._uniformsPool.push(this._activeUniforms[i3]);
          }
          for (let i3 = 0; i3 < this._activeBindGroups.length; i3++) {
            this._bindGroupPool.push(this._activeBindGroups[i3]);
          }
          this._activeUniforms.length = 0;
          this._activeBindGroups.length = 0;
        }
        start(options) {
          this.reset();
          this.push(options);
        }
        bind({
          size,
          projectionMatrix,
          worldTransformMatrix,
          worldColor,
          offset
        }) {
          const renderTarget = this._renderer.renderTarget.renderTarget;
          const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
            projectionData: renderTarget,
            worldTransformMatrix: new Matrix(),
            worldColor: 4294967295,
            offset: new Point()
          };
          const globalUniformData = {
            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
            resolution: size || renderTarget.size,
            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
            worldColor: worldColor || currentGlobalUniformData.worldColor,
            offset: offset || currentGlobalUniformData.offset,
            bindGroup: null
          };
          const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
          this._activeUniforms.push(uniformGroup);
          const uniforms = uniformGroup.uniforms;
          uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
          uniforms.uResolution = globalUniformData.resolution;
          uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
          uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
          uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
          color32BitToUniform(
            globalUniformData.worldColor,
            uniforms.uWorldColorAlpha,
            0
          );
          uniformGroup.update();
          let bindGroup;
          if (this._renderer.renderPipes.uniformBatch) {
            bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
          } else {
            bindGroup = this._bindGroupPool.pop() || new BindGroup();
            this._activeBindGroups.push(bindGroup);
            bindGroup.setResource(uniformGroup, 0);
          }
          globalUniformData.bindGroup = bindGroup;
          this._currentGlobalUniformData = globalUniformData;
        }
        push(options) {
          this.bind(options);
          this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
          this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
          if (this._renderer.type === RendererType.WEBGL) {
            this._currentGlobalUniformData.bindGroup.resources[0].update();
          }
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup;
        }
        get globalUniformData() {
          return this._currentGlobalUniformData;
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
          const globalUniforms = new UniformGroup({
            uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
            uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }, {
            isStatic: true
          });
          return globalUniforms;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlobalUniformSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "globalUniforms"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
  var uid2, SchedulerSystem;
  var init_SchedulerSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
      init_Extensions();
      init_Ticker();
      uid2 = 1;
      SchedulerSystem = class {
        constructor() {
          this._tasks = [];
          this._offset = 0;
        }
        /** Initializes the scheduler system and starts the ticker. */
        init() {
          Ticker.system.add(this._update, this);
        }
        /**
         * Schedules a repeating task.
         * @param func - The function to execute.
         * @param duration - The interval duration in milliseconds.
         * @param useOffset - this will spread out tasks so that they do not all run at the same time
         * @returns The unique identifier for the scheduled task.
         */
        repeat(func, duration, useOffset = true) {
          const id = uid2++;
          let offset = 0;
          if (useOffset) {
            this._offset += 1e3;
            offset = this._offset;
          }
          this._tasks.push({
            func,
            duration,
            start: performance.now(),
            offset,
            last: performance.now(),
            repeat: true,
            id
          });
          return id;
        }
        /**
         * Cancels a scheduled task.
         * @param id - The unique identifier of the task to cancel.
         */
        cancel(id) {
          for (let i3 = 0; i3 < this._tasks.length; i3++) {
            if (this._tasks[i3].id === id) {
              this._tasks.splice(i3, 1);
              return;
            }
          }
        }
        /**
         * Updates and executes the scheduled tasks.
         * @private
         */
        _update() {
          const now = performance.now();
          for (let i3 = 0; i3 < this._tasks.length; i3++) {
            const task = this._tasks[i3];
            if (now - task.offset - task.last >= task.duration) {
              const elapsed = now - task.start;
              task.func(elapsed);
              task.last = now;
            }
          }
        }
        /**
         * Destroys the scheduler system and removes all tasks.
         * @internal
         * @ignore
         */
        destroy() {
          Ticker.system.remove(this._update, this);
          this._tasks.length = 0;
        }
      };
      SchedulerSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/sayHello.mjs
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }
  var saidHello;
  var init_sayHello = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/sayHello.mjs"() {
      init_adapter();
      init_const8();
      saidHello = false;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem;
  var init_HelloSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
      init_Extensions();
      init_sayHello();
      init_types2();
      HelloSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * It all starts here! This initiates every system, passing in the options for any system by name.
         * @param options - the config for the renderer and all its systems
         */
        init(options) {
          if (options.hello) {
            let name = this._renderer.name;
            if (this._renderer.type === RendererType.WEBGL) {
              name += ` ${this._renderer.context.webGLVersion}`;
            }
            sayHello(name);
          }
        }
      };
      HelloSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "hello",
        priority: -2
      };
      HelloSystem.defaultOptions = {
        /** {@link WebGLOptions.hello} */
        hello: false
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/clean.mjs
  function cleanHash(hash) {
    let clean = false;
    for (const i3 in hash) {
      if (hash[i3] == void 0) {
        clean = true;
        break;
      }
    }
    if (!clean)
      return hash;
    const cleanHash2 = /* @__PURE__ */ Object.create(null);
    for (const i3 in hash) {
      const value = hash[i3];
      if (value) {
        cleanHash2[i3] = value;
      }
    }
    return cleanHash2;
  }
  function cleanArray(arr) {
    let offset = 0;
    for (let i3 = 0; i3 < arr.length; i3++) {
      if (arr[i3] == void 0) {
        offset++;
      } else {
        arr[i3 - offset] = arr[i3];
      }
    }
    arr.length = arr.length - offset;
    return arr;
  }
  var init_clean = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/data/clean.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
  var _RenderableGCSystem, RenderableGCSystem;
  var init_RenderableGCSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
      init_Extensions();
      init_clean();
      _RenderableGCSystem = class _RenderableGCSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._managedRenderables = [];
          this._managedHashes = [];
          this._managedArrays = [];
          this._renderer = renderer;
        }
        init(options) {
          options = { ..._RenderableGCSystem2.defaultOptions, ...options };
          this.maxUnusedTime = options.renderableGCMaxUnusedTime;
          this._frequency = options.renderableGCFrequency;
          this.enabled = options.renderableGCActive;
        }
        get enabled() {
          return !!this._handler;
        }
        set enabled(value) {
          if (this.enabled === value)
            return;
          if (value) {
            this._handler = this._renderer.scheduler.repeat(
              () => this.run(),
              this._frequency,
              false
            );
            this._hashHandler = this._renderer.scheduler.repeat(
              () => {
                for (const hash of this._managedHashes) {
                  hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);
                }
              },
              this._frequency
            );
            this._arrayHandler = this._renderer.scheduler.repeat(
              () => {
                for (const array of this._managedArrays) {
                  cleanArray(array.context[array.hash]);
                }
              },
              this._frequency
            );
          } else {
            this._renderer.scheduler.cancel(this._handler);
            this._renderer.scheduler.cancel(this._hashHandler);
            this._renderer.scheduler.cancel(this._arrayHandler);
          }
        }
        addManagedHash(context4, hash) {
          this._managedHashes.push({ context: context4, hash });
        }
        addManagedArray(context4, hash) {
          this._managedArrays.push({ context: context4, hash });
        }
        prerender() {
          this._now = performance.now();
        }
        addRenderable(renderable, instructionSet) {
          if (!this.enabled)
            return;
          renderable._lastUsed = this._now;
          if (renderable._lastInstructionTick === -1) {
            this._managedRenderables.push(renderable);
            renderable.once("destroyed", this._removeRenderable, this);
          }
          renderable._lastInstructionTick = instructionSet.tick;
        }
        /** Runs the scheduled garbage collection */
        run() {
          const now = performance.now();
          const managedRenderables = this._managedRenderables;
          const renderPipes3 = this._renderer.renderPipes;
          let offset = 0;
          for (let i3 = 0; i3 < managedRenderables.length; i3++) {
            const renderable = managedRenderables[i3];
            if (renderable === null) {
              offset++;
              continue;
            }
            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
            const currentIndex = renderGroup?.instructionSet?.tick ?? -1;
            if (renderable._lastInstructionTick !== currentIndex && now - renderable._lastUsed > this.maxUnusedTime) {
              if (!renderable.destroyed) {
                const rp = renderPipes3;
                rp[renderable.renderPipeId].destroyRenderable(renderable);
              }
              renderable._lastInstructionTick = -1;
              offset++;
              renderable.off("destroyed", this._removeRenderable, this);
            } else {
              managedRenderables[i3 - offset] = renderable;
            }
          }
          managedRenderables.length = managedRenderables.length - offset;
        }
        destroy() {
          this.enabled = false;
          this._renderer = null;
          this._managedRenderables.length = 0;
          this._managedHashes.length = 0;
          this._managedArrays.length = 0;
        }
        _removeRenderable(renderable) {
          const index = this._managedRenderables.indexOf(renderable);
          if (index >= 0) {
            renderable.off("destroyed", this._removeRenderable, this);
            this._managedRenderables[index] = null;
          }
        }
      };
      _RenderableGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "renderableGC",
        priority: 0
      };
      _RenderableGCSystem.defaultOptions = {
        /**
         * If set to true, this will enable the garbage collector on the GPU.
         * @default true
         */
        renderableGCActive: true,
        /**
         * The maximum idle frames before a texture is destroyed by garbage collection.
         * @default 60 * 60
         */
        renderableGCMaxUnusedTime: 6e4,
        /**
         * Frames between two garbage collections.
         * @default 600
         */
        renderableGCFrequency: 3e4
      };
      RenderableGCSystem = _RenderableGCSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem, TextureGCSystem;
  var init_TextureGCSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
      init_Extensions();
      _TextureGCSystem = class _TextureGCSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
          this.count = 0;
          this.checkCount = 0;
        }
        init(options) {
          options = { ..._TextureGCSystem2.defaultOptions, ...options };
          this.checkCountMax = options.textureGCCheckCountMax;
          this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
          this.active = options.textureGCActive;
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         */
        postrender() {
          if (!this._renderer.renderingToScreen) {
            return;
          }
          this.count++;
          if (!this.active)
            return;
          this.checkCount++;
          if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
          }
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         */
        run() {
          const managedTextures = this._renderer.texture.managedTextures;
          for (let i3 = 0; i3 < managedTextures.length; i3++) {
            const texture = managedTextures[i3];
            if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
              texture._touched = -1;
              texture.unload();
            }
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      _TextureGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGC"
      };
      _TextureGCSystem.defaultOptions = {
        /**
         * If set to true, this will enable the garbage collector on the GPU.
         * @default true
         */
        textureGCActive: true,
        /**
         * @deprecated since 8.3.0
         * @see {@link TextureGCSystem.textureGCMaxIdle}
         */
        textureGCAMaxIdle: null,
        /**
         * The maximum idle frames before a texture is destroyed by garbage collection.
         * @default 60 * 60
         */
        textureGCMaxIdle: 60 * 60,
        /**
         * Frames between two garbage collections.
         * @default 600
         */
        textureGCCheckCountMax: 600
      };
      TextureGCSystem = _TextureGCSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget, RenderTarget;
  var init_RenderTarget = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
      init_uid();
      init_TextureSource();
      init_Texture();
      _RenderTarget = class _RenderTarget2 {
        /**
         * @param [descriptor] - Options for creating a render target.
         */
        constructor(descriptor = {}) {
          this.uid = uid("renderTarget");
          this.colorTextures = [];
          this.dirtyId = 0;
          this.isRoot = false;
          this._size = new Float32Array(2);
          this._managedColorTextures = false;
          descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
          this.stencil = descriptor.stencil;
          this.depth = descriptor.depth;
          this.isRoot = descriptor.isRoot;
          if (typeof descriptor.colorTextures === "number") {
            this._managedColorTextures = true;
            for (let i3 = 0; i3 < descriptor.colorTextures; i3++) {
              this.colorTextures.push(
                new TextureSource({
                  width: descriptor.width,
                  height: descriptor.height,
                  resolution: descriptor.resolution,
                  antialias: descriptor.antialias
                })
              );
            }
          } else {
            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
            const colorSource = this.colorTexture.source;
            this.resize(colorSource.width, colorSource.height, colorSource._resolution);
          }
          this.colorTexture.source.on("resize", this.onSourceResize, this);
          if (descriptor.depthStencilTexture || this.stencil) {
            if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
              this.depthStencilTexture = descriptor.depthStencilTexture.source;
            } else {
              this.ensureDepthStencilTexture();
            }
          }
        }
        get size() {
          const _size = this._size;
          _size[0] = this.pixelWidth;
          _size[1] = this.pixelHeight;
          return _size;
        }
        get width() {
          return this.colorTexture.source.width;
        }
        get height() {
          return this.colorTexture.source.height;
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
          return this.colorTexture.source._resolution;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        onSourceResize(source7) {
          this.resize(source7.width, source7.height, source7._resolution, true);
        }
        /**
         * This will ensure a depthStencil texture is created for this render target.
         * Most likely called by the mask system to make sure we have stencil buffer added.
         * @internal
         * @ignore
         */
        ensureDepthStencilTexture() {
          if (!this.depthStencilTexture) {
            this.depthStencilTexture = new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: false,
              antialias: false,
              mipLevelCount: 1
              // sampleCount: handled by the render target system..
            });
          }
        }
        resize(width, height, resolution = this.resolution, skipColorTexture = false) {
          this.dirtyId++;
          this.colorTextures.forEach((colorTexture, i3) => {
            if (skipColorTexture && i3 === 0)
              return;
            colorTexture.source.resize(width, height, resolution);
          });
          if (this.depthStencilTexture) {
            this.depthStencilTexture.source.resize(width, height, resolution);
          }
        }
        destroy() {
          this.colorTexture.source.off("resize", this.onSourceResize, this);
          if (this._managedColorTextures) {
            this.colorTextures.forEach((texture) => {
              texture.destroy();
            });
          }
          if (this.depthStencilTexture) {
            this.depthStencilTexture.destroy();
            delete this.depthStencilTexture;
          }
        }
      };
      _RenderTarget.defaultOptions = {
        /** the width of the RenderTarget */
        width: 0,
        /** the height of the RenderTarget */
        height: 0,
        /** the resolution of the RenderTarget */
        resolution: 1,
        /** an array of textures, or a number indicating how many color textures there should be */
        colorTextures: 1,
        /** should this render target have a stencil buffer? */
        stencil: false,
        /** should this render target have a depth buffer? */
        depth: false,
        /** should this render target be antialiased? */
        antialias: false,
        // save on perf by default!
        /** is this a root element, true if this is gl context owners render target */
        isRoot: false
      };
      RenderTarget = _RenderTarget;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  function getCanvasTexture(canvas, options) {
    if (!canvasCache.has(canvas)) {
      const texture = new Texture({
        source: new CanvasSource({
          resource: canvas,
          ...options
        })
      });
      const onDestroy = () => {
        if (canvasCache.get(canvas) === texture) {
          canvasCache.delete(canvas);
        }
      };
      texture.once("destroy", onDestroy);
      texture.source.once("destroy", onDestroy);
      canvasCache.set(canvas, texture);
    }
    return canvasCache.get(canvas);
  }
  function hasCachedCanvasTexture(canvas) {
    return canvasCache.has(canvas);
  }
  var canvasCache;
  var init_getCanvasTexture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
      init_CanvasSource();
      init_Texture();
      canvasCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem, ViewSystem;
  var init_ViewSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Rectangle();
      init_deprecation();
      init_RenderTarget();
      init_getCanvasTexture();
      _ViewSystem = class _ViewSystem2 {
        /**
         * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
         * @member {boolean}
         */
        get autoDensity() {
          return this.texture.source.autoDensity;
        }
        set autoDensity(value) {
          this.texture.source.autoDensity = value;
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.texture.source._resolution;
        }
        set resolution(value) {
          this.texture.source.resize(
            this.texture.source.width,
            this.texture.source.height,
            value
          );
        }
        /**
         * initiates the view system
         * @param options - the options for the view
         */
        init(options) {
          options = {
            ..._ViewSystem2.defaultOptions,
            ...options
          };
          if (options.view) {
            deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
            options.canvas = options.view;
          }
          this.screen = new Rectangle(0, 0, options.width, options.height);
          this.canvas = options.canvas || DOMAdapter.get().createCanvas();
          this.antialias = !!options.antialias;
          this.texture = getCanvasTexture(this.canvas, options);
          this.renderTarget = new RenderTarget({
            colorTextures: [this.texture],
            depth: !!options.depth,
            isRoot: true
          });
          this.texture.source.transparent = options.backgroundAlpha < 1;
          this.resolution = options.resolution;
        }
        /**
         * Resizes the screen and canvas to the specified dimensions.
         * @param desiredScreenWidth - The new width of the screen.
         * @param desiredScreenHeight - The new height of the screen.
         * @param resolution
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.screen.width = this.texture.frame.width;
          this.screen.height = this.texture.frame.height;
        }
        /**
         * Destroys this System and optionally removes the canvas from the dom.
         * @param {options | false} options - The options for destroying the view, or "false".
         * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
         */
        destroy(options = false) {
          const removeView = typeof options === "boolean" ? options : !!options?.removeView;
          if (removeView && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
        }
      };
      _ViewSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "view",
        priority: 0
      };
      _ViewSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.width}
         * @default 800
         */
        width: 800,
        /**
         * {@link WebGLOptions.height}
         * @default 600
         */
        height: 600,
        /**
         * {@link WebGLOptions.autoDensity}
         * @default false
         */
        autoDensity: false,
        /**
         * {@link WebGLOptions.antialias}
         * @default false
         */
        antialias: false
      };
      ViewSystem = _ViewSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems, SharedRenderPipes;
  var init_SharedSystems = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
      init_CustomRenderPipe();
      init_RenderGroupPipe();
      init_RenderGroupSystem();
      init_SpritePipe();
      init_globalHooks();
      init_BatcherPipe();
      init_AlphaMaskPipe();
      init_ColorMaskPipe();
      init_StencilMaskPipe();
      init_BackgroundSystem();
      init_BlendModePipe();
      init_ExtractSystem();
      init_GenerateTextureSystem();
      init_GlobalUniformSystem();
      init_SchedulerSystem();
      init_HelloSystem();
      init_RenderableGCSystem();
      init_TextureGCSystem();
      init_ViewSystem();
      SharedSystems = [
        BackgroundSystem,
        GlobalUniformSystem,
        HelloSystem,
        ViewSystem,
        RenderGroupSystem,
        TextureGCSystem,
        GenerateTextureSystem,
        ExtractSystem,
        RendererInitHook,
        RenderableGCSystem,
        SchedulerSystem
      ];
      SharedRenderPipes = [
        BlendModePipe,
        BatcherPipe,
        SpritePipe,
        RenderGroupPipe,
        AlphaMaskPipe,
        StencilMaskPipe,
        ColorMaskPipe,
        CustomRenderPipe
      ];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem;
  var init_BindGroupSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
      init_Extensions();
      BindGroupSystem = class {
        constructor(renderer) {
          this._hash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_hash");
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getBindGroup(bindGroup, program, groupIndex) {
          bindGroup._updateKey();
          const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
          return gpuBindGroup;
        }
        _createBindGroup(group, program, groupIndex) {
          const device = this._gpu.device;
          const groupLayout = program.layout[groupIndex];
          const entries = [];
          const renderer = this._renderer;
          for (const j2 in groupLayout) {
            const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
            let gpuResource;
            if (resource._resourceType === "uniformGroup") {
              const uniformGroup = resource;
              renderer.ubo.updateUniformGroup(uniformGroup);
              const buffer = uniformGroup.buffer;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "buffer") {
              const buffer = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "bufferResource") {
              const bufferResource = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
                offset: bufferResource.offset,
                size: bufferResource.size
              };
            } else if (resource._resourceType === "textureSampler") {
              const sampler = resource;
              gpuResource = renderer.texture.getGpuSampler(sampler);
            } else if (resource._resourceType === "textureSource") {
              const texture = resource;
              gpuResource = renderer.texture.getGpuSource(texture).createView({});
            }
            entries.push({
              binding: groupLayout[j2],
              resource: gpuResource
            });
          }
          const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
          const gpuBindGroup = device.createBindGroup({
            layout,
            entries
          });
          this._hash[group._key] = gpuBindGroup;
          return gpuBindGroup;
        }
        destroy() {
          for (const key of Object.keys(this._hash)) {
            this._hash[key] = null;
          }
          this._hash = null;
          this._renderer = null;
        }
      };
      BindGroupSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "bindGroup"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var GpuBufferSystem;
  var init_GpuBufferSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
      init_Extensions();
      init_fastCopy();
      GpuBufferSystem = class {
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._managedBuffers = [];
          renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getGPUBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        }
        updateBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
          const data = buffer.data;
          if (buffer._updateID && data) {
            buffer._updateID = 0;
            this._gpu.device.queue.writeBuffer(
              gpuBuffer,
              0,
              data.buffer,
              0,
              // round to the nearest 4 bytes
              (buffer._updateSize || data.byteLength) + 3 & ~3
            );
          }
          return gpuBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          for (const id in this._gpuBuffers) {
            this._gpuBuffers[id].destroy();
          }
          this._gpuBuffers = {};
        }
        createGPUBuffer(buffer) {
          if (!this._gpuBuffers[buffer.uid]) {
            buffer.on("update", this.updateBuffer, this);
            buffer.on("change", this.onBufferChange, this);
            buffer.on("destroy", this.onBufferDestroy, this);
            this._managedBuffers.push(buffer);
          }
          const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
          buffer._updateID = 0;
          if (buffer.data) {
            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
            gpuBuffer.unmap();
          }
          this._gpuBuffers[buffer.uid] = gpuBuffer;
          return gpuBuffer;
        }
        onBufferChange(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer._updateID = 0;
          this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
        }
        /**
         * Disposes buffer
         * @param buffer - buffer with data
         */
        onBufferDestroy(buffer) {
          this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
          this._destroyBuffer(buffer);
        }
        destroy() {
          this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
          this._managedBuffers = null;
          this._gpuBuffers = null;
        }
        _destroyBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer.off("update", this.updateBuffer, this);
          buffer.off("change", this.onBufferChange, this);
          buffer.off("destroy", this.onBufferDestroy, this);
          this._gpuBuffers[buffer.uid] = null;
        }
      };
      GpuBufferSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem;
  var init_GpuColorMaskSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
      init_Extensions();
      GpuColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.pipeline.setColorMask(colorMask);
        }
        destroy() {
          this._renderer = null;
          this._colorMaskCache = null;
        }
      };
      GpuColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem;
  var init_GpuDeviceSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
      init_adapter();
      init_Extensions();
      GpuDeviceSystem = class {
        /**
         * @param {WebGPURenderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._renderer = renderer;
        }
        async init(options) {
          if (this._initPromise)
            return this._initPromise;
          this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {
            this.gpu = gpu;
            this._renderer.runners.contextChange.emit(this.gpu);
          });
          return this._initPromise;
        }
        /**
         * Handle the context change event
         * @param gpu
         */
        contextChange(gpu) {
          this._renderer.gpu = gpu;
        }
        /**
         * Helper class to create a WebGL Context
         * @param {object} options - An options object that gets passed in to the canvas element containing the
         *    context attributes
         * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
         * @returns {WebGLRenderingContext} the WebGL context
         */
        async _createDeviceAndAdaptor(options) {
          const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
            powerPreference: options.powerPreference,
            forceFallbackAdapter: options.forceFallbackAdapter
          });
          const requiredFeatures = [
            "texture-compression-bc",
            "texture-compression-astc",
            "texture-compression-etc2"
          ].filter((feature) => adapter.features.has(feature));
          const device = await adapter.requestDevice({
            requiredFeatures
          });
          return { adapter, device };
        }
        destroy() {
          this.gpu = null;
          this._renderer = null;
        }
      };
      GpuDeviceSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "device"
      };
      GpuDeviceSystem.defaultOptions = {
        /**
         * {@link WebGPUOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * Force the use of the fallback adapter
         * @default false
         */
        forceFallbackAdapter: false
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem;
  var init_GpuEncoderSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
      init_Extensions();
      GpuEncoderSystem = class {
        constructor(renderer) {
          this._boundBindGroup = /* @__PURE__ */ Object.create(null);
          this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        renderStart() {
          this.commandFinished = new Promise((resolve) => {
            this._resolveCommandFinished = resolve;
          });
          this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        }
        beginRenderPass(gpuRenderTarget) {
          this.endRenderPass();
          this._clearCache();
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        }
        endRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
          }
          this.renderPassEncoder = null;
        }
        setViewport(viewport) {
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        }
        setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
          const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
          this.setPipeline(pipeline);
        }
        setPipeline(pipeline) {
          if (this._boundPipeline === pipeline)
            return;
          this._boundPipeline = pipeline;
          this.renderPassEncoder.setPipeline(pipeline);
        }
        _setVertexBuffer(index, buffer) {
          if (this._boundVertexBuffer[index] === buffer)
            return;
          this._boundVertexBuffer[index] = buffer;
          this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
        }
        _setIndexBuffer(buffer) {
          if (this._boundIndexBuffer === buffer)
            return;
          this._boundIndexBuffer = buffer;
          const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
        }
        resetBindGroup(index) {
          this._boundBindGroup[index] = null;
        }
        setBindGroup(index, bindGroup, program) {
          if (this._boundBindGroup[index] === bindGroup)
            return;
          this._boundBindGroup[index] = bindGroup;
          bindGroup._touch(this._renderer.textureGC.count);
          const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
          this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
        }
        setGeometry(geometry, program) {
          const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
          for (const i3 in buffersToBind) {
            this._setVertexBuffer(i3, geometry.attributes[buffersToBind[i3]].buffer);
          }
          if (geometry.indexBuffer) {
            this._setIndexBuffer(geometry.indexBuffer);
          }
        }
        _setShaderBindGroups(shader, skipSync) {
          for (const i3 in shader.groups) {
            const bindGroup = shader.groups[i3];
            if (!skipSync) {
              this._syncBindGroup(bindGroup);
            }
            this.setBindGroup(i3, bindGroup, shader.gpuProgram);
          }
        }
        _syncBindGroup(bindGroup) {
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource.isUniformGroup) {
              this._renderer.ubo.updateUniformGroup(resource);
            }
          }
        }
        draw(options) {
          const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
          this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
          this.setGeometry(geometry, shader.gpuProgram);
          this._setShaderBindGroups(shader, skipSync);
          if (geometry.indexBuffer) {
            this.renderPassEncoder.drawIndexed(
              size || geometry.indexBuffer.data.length,
              instanceCount || geometry.instanceCount,
              start || 0
            );
          } else {
            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);
          }
        }
        finishRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
            this.renderPassEncoder = null;
          }
        }
        postrender() {
          this.finishRenderPass();
          this._gpu.device.queue.submit([this.commandEncoder.finish()]);
          this._resolveCommandFinished();
          this.commandEncoder = null;
        }
        // restores a render pass if finishRenderPass was called
        // not optimised as really used for debugging!
        // used when we want to stop drawing and log a texture..
        restoreRenderPass() {
          const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            false,
            [0, 0, 0, 1]
          );
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
          const boundPipeline = this._boundPipeline;
          const boundVertexBuffer = { ...this._boundVertexBuffer };
          const boundIndexBuffer = this._boundIndexBuffer;
          const boundBindGroup = { ...this._boundBindGroup };
          this._clearCache();
          const viewport = this._renderer.renderTarget.viewport;
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          this.setPipeline(boundPipeline);
          for (const i3 in boundVertexBuffer) {
            this._setVertexBuffer(i3, boundVertexBuffer[i3]);
          }
          for (const i3 in boundBindGroup) {
            this.setBindGroup(i3, boundBindGroup[i3], null);
          }
          this._setIndexBuffer(boundIndexBuffer);
        }
        _clearCache() {
          for (let i3 = 0; i3 < 16; i3++) {
            this._boundBindGroup[i3] = null;
            this._boundVertexBuffer[i3] = null;
          }
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        destroy() {
          this._renderer = null;
          this._gpu = null;
          this._boundBindGroup = null;
          this._boundVertexBuffer = null;
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
      };
      GpuEncoderSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "encoder",
        priority: 1
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem;
  var init_GpuStencilSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
      init_Extensions();
      init_const3();
      GpuStencilSystem = class {
        constructor(renderer) {
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this._activeRenderTarget = renderTarget;
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          const renderer = this._renderer;
          renderer.pipeline.setStencilMode(stencilMode);
          renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
        }
        destroy() {
          this._renderer.renderTarget.onRenderTargetChange.remove(this);
          this._renderer = null;
          this._activeRenderTarget = null;
          this._renderTargetStencilState = null;
        }
      };
      GpuStencilSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
  var UboSystem;
  var init_UboSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
      init_unsafeEvalSupported();
      init_Buffer();
      init_const4();
      UboSystem = class {
        constructor(adaptor) {
          this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
          this._adaptor = adaptor;
          this._systemCheck();
        }
        /**
         * Overridable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         */
        _systemCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
        ensureUniformGroup(uniformGroup) {
          const uniformData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
        }
        getUniformGroupData(uniformGroup) {
          return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
        }
        _initUniformGroup(uniformGroup) {
          const uniformGroupSignature = uniformGroup._signature;
          let uniformData = this._syncFunctionHash[uniformGroupSignature];
          if (!uniformData) {
            const elements = Object.keys(uniformGroup.uniformStructures).map((i3) => uniformGroup.uniformStructures[i3]);
            const layout = this._adaptor.createUboElements(elements);
            const syncFunction = this._generateUboSync(layout.uboElements);
            uniformData = this._syncFunctionHash[uniformGroupSignature] = {
              layout,
              syncFunction
            };
          }
          return this._syncFunctionHash[uniformGroupSignature];
        }
        _generateUboSync(uboElements) {
          return this._adaptor.generateUboSync(uboElements);
        }
        syncUniformGroup(uniformGroup, data, offset) {
          const uniformGroupData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformGroupData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
          data || (data = uniformGroup.buffer.data);
          offset || (offset = 0);
          uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);
          return true;
        }
        updateUniformGroup(uniformGroup) {
          if (uniformGroup.isStatic && !uniformGroup._dirtyId)
            return false;
          uniformGroup._dirtyId = 0;
          const synced = this.syncUniformGroup(uniformGroup);
          uniformGroup.buffer.update();
          return synced;
        }
        destroy() {
          this._syncFunctionHash = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
  function createUboElementsWGSL(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let offset = 0;
    for (let i3 = 0; i3 < uboElements.length; i3++) {
      const uboElement = uboElements[i3];
      let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
      const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
      if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, align) * uboElement.data.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_ALIGN_SIZE_DATA;
  var init_createUboElementsWGSL = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
      "use strict";
      WGSL_ALIGN_SIZE_DATA = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
  var uniformParsers;
  var init_uniformParsers = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
      "use strict";
      uniformParsers = [
        // uploading pixi matrix object to mat3
        {
          type: "mat3x3<f32>",
          test: (data) => {
            const value = data.value;
            return value.a !== void 0;
          },
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        // uploading a pixi rectangle as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        // uploading a pixi point as a vec2
        {
          type: "vec2<f32>",
          test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        // uploading a pixi color as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        // uploading a pixi color as a vec3
        {
          type: "vec3<f32>",
          test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
      ];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i3 = 0; i3 < uboElements.length; i3++) {
      const uboElement = uboElements[i3];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const uniformParser = uniformParsers[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `name = "${name}";`,
            `offset += ${offset - prev};`,
            uniformParsers[j2][parserCode] || uniformParsers[j2].ubo
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            /* wgsl */
            `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      "offset",
      fragmentSrc
    );
  }
  var init_createUboSyncFunction = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
      init_uniformParsers();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
  var init_uboSyncFunctions = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
      "use strict";
      uboSyncFunctionsSTD40 = {
        f32: `
        data[offset] = v;`,
        i32: `
        data[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": loopMatrix(3, 2),
        "mat4x2<f32>": loopMatrix(4, 2),
        "mat2x3<f32>": loopMatrix(2, 3),
        "mat4x3<f32>": loopMatrix(4, 3),
        "mat2x4<f32>": loopMatrix(2, 4),
        "mat3x4<f32>": loopMatrix(3, 4)
      };
      uboSyncFunctionsWGSL = {
        ...uboSyncFunctionsSTD40,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder = (align - size) / 4;
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
  }
  var init_generateArraySyncWGSL = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
      init_createUboElementsWGSL();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboWgsl",
      generateArraySyncWGSL,
      uboSyncFunctionsWGSL
    );
  }
  var init_createUboSyncFunctionWGSL = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncWGSL();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
  var GpuUboSystem;
  var init_GpuUboSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsWGSL();
      init_createUboSyncFunctionWGSL();
      GpuUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsWGSL,
            generateUboSync: createUboSyncFunctionWGSL
          });
        }
      };
      GpuUboSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource;
  var init_BufferResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
      init_eventemitter3();
      init_uid();
      BufferResource = class extends eventemitter3_default {
        /**
         * Create a new Buffer Resource.
         * @param options - The options for the buffer resource
         * @param options.buffer - The underlying buffer that this resource is using
         * @param options.offset - The offset of the buffer this resource is using.
         * If not provided, then it will use the offset of the buffer.
         * @param options.size - The size of the buffer this resource is using.
         * If not provided, then it will use the size of the buffer.
         */
        constructor({ buffer, offset, size }) {
          super();
          this.uid = uid("buffer");
          this._resourceType = "bufferResource";
          this._touched = 0;
          this._resourceId = uid("resource");
          this._bufferResource = true;
          this.destroyed = false;
          this.buffer = buffer;
          this.offset = offset | 0;
          this.size = size;
          this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
          this._resourceId = uid("resource");
          this.emit("change", this);
        }
        /**
         * Destroys this resource. Make sure the underlying buffer is not used anywhere else
         * if you want to destroy it as well, or code will explode
         * @param destroyBuffer - Should the underlying buffer be destroyed as well?
         */
        destroy(destroyBuffer = false) {
          this.destroyed = true;
          if (destroyBuffer) {
            this.buffer.destroy();
          }
          this.emit("change", this);
          this.buffer = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
  var UboBatch;
  var init_UboBatch = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
      "use strict";
      UboBatch = class {
        constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
          this._minUniformOffsetAlignment = 256;
          this.byteIndex = 0;
          this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
          this.data = new Float32Array(65535);
        }
        clear() {
          this.byteIndex = 0;
        }
        addEmptyGroup(size) {
          if (size > this._minUniformOffsetAlignment / 4) {
            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
          }
          const start = this.byteIndex;
          let newSize = start + size * 4;
          newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
          if (newSize > this.data.length * 4) {
            throw new Error("UniformBufferBatch: ubo batch got too big");
          }
          this.byteIndex = newSize;
          return start;
        }
        addGroup(array) {
          const offset = this.addEmptyGroup(array.length);
          for (let i3 = 0; i3 < array.length; i3++) {
            this.data[offset / 4 + i3] = array[i3];
          }
          return offset;
        }
        destroy() {
          this._buffer.destroy();
          this._buffer = null;
          this.data = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment, GpuUniformBatchPipe;
  var init_GpuUniformBatchPipe = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
      init_Extensions();
      init_Buffer();
      init_BufferResource();
      init_const4();
      init_UboBatch();
      init_BindGroup();
      minUniformOffsetAlignment = 128;
      GpuUniformBatchPipe = class {
        constructor(renderer) {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._buffers = [];
          this._bindGroups = [];
          this._bufferResources = [];
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
          this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
          const totalBuffers = 256 / minUniformOffsetAlignment;
          for (let i3 = 0; i3 < totalBuffers; i3++) {
            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
            if (i3 === 0)
              usage |= BufferUsage.COPY_SRC;
            this._buffers.push(new Buffer2({
              data: this._batchBuffer.data,
              usage
            }));
          }
        }
        renderEnd() {
          this._uploadBindGroups();
          this._resetBindGroups();
        }
        _resetBindGroups() {
          for (const i3 in this._bindGroupHash) {
            this._bindGroupHash[i3] = null;
          }
          this._batchBuffer.clear();
        }
        // just works for single bind groups for now
        getUniformBindGroup(group, duplicate) {
          if (!duplicate && this._bindGroupHash[group.uid]) {
            return this._bindGroupHash[group.uid];
          }
          this._renderer.ubo.ensureUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addEmptyGroup(data.length);
          this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
          this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
          return this._bindGroupHash[group.uid];
        }
        getUboResource(group) {
          this._renderer.ubo.updateUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addGroup(data);
          return this._getBufferResource(offset / minUniformOffsetAlignment);
        }
        getArrayBindGroup(data) {
          const offset = this._batchBuffer.addGroup(data);
          return this._getBindGroup(offset / minUniformOffsetAlignment);
        }
        getArrayBufferResource(data) {
          const offset = this._batchBuffer.addGroup(data);
          const index = offset / minUniformOffsetAlignment;
          return this._getBufferResource(index);
        }
        _getBufferResource(index) {
          if (!this._bufferResources[index]) {
            const buffer = this._buffers[index % 2];
            this._bufferResources[index] = new BufferResource({
              buffer,
              offset: (index / 2 | 0) * 256,
              size: minUniformOffsetAlignment
            });
          }
          return this._bufferResources[index];
        }
        _getBindGroup(index) {
          if (!this._bindGroups[index]) {
            const bindGroup = new BindGroup({
              0: this._getBufferResource(index)
            });
            this._bindGroups[index] = bindGroup;
          }
          return this._bindGroups[index];
        }
        _uploadBindGroups() {
          const bufferSystem = this._renderer.buffer;
          const firstBuffer = this._buffers[0];
          firstBuffer.update(this._batchBuffer.byteIndex);
          bufferSystem.updateBuffer(firstBuffer);
          const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
          for (let i3 = 1; i3 < this._buffers.length; i3++) {
            const buffer = this._buffers[i3];
            commandEncoder.copyBufferToBuffer(
              bufferSystem.getGPUBuffer(firstBuffer),
              minUniformOffsetAlignment,
              bufferSystem.getGPUBuffer(buffer),
              0,
              this._batchBuffer.byteIndex
            );
          }
          this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        }
        destroy() {
          for (let i3 = 0; i3 < this._bindGroups.length; i3++) {
            this._bindGroups[i3].destroy();
          }
          this._bindGroups = null;
          this._bindGroupHash = null;
          for (let i3 = 0; i3 < this._buffers.length; i3++) {
            this._buffers[i3].destroy();
          }
          this._buffers = null;
          for (let i3 = 0; i3 < this._bufferResources.length; i3++) {
            this._bufferResources[i3].destroy();
          }
          this._bufferResources = null;
          this._batchBuffer.destroy();
          this._bindGroupHash = null;
          this._renderer = null;
        }
      };
      GpuUniformBatchPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "uniformBatch"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
  function ensureAttributes(geometry, extractedData) {
    for (const i3 in geometry.attributes) {
      const attribute = geometry.attributes[i3];
      const attributeData = extractedData[i3];
      if (attributeData) {
        attribute.format ?? (attribute.format = attributeData.format);
        attribute.offset ?? (attribute.offset = attributeData.offset);
        attribute.instance ?? (attribute.instance = attributeData.instance);
      } else {
        warn(`Attribute ${i3} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    const { buffers, attributes } = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      const buffer = buffers[j2];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
      attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }
  var init_ensureAttributes = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
      init_warn();
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi;
  var init_GpuStencilModesToPixi = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
      init_const3();
      GpuStencilModesToPixi = [];
      GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
      GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        stencilFront: {
          compare: "equal",
          passOp: "increment-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
        stencilFront: {
          compare: "equal",
          passOp: "decrement-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "decrement-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "equal",
          passOp: "keep"
        },
        stencilBack: {
          compare: "equal",
          passOp: "keep"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "not-equal",
          passOp: "replace"
        },
        stencilBack: {
          compare: "not-equal",
          passOp: "replace"
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
  }
  var topologyStringToId, PipelineSystem;
  var init_PipelineSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_ensureAttributes();
      init_const3();
      init_createIdFromString();
      init_GpuStencilModesToPixi();
      topologyStringToId = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
      };
      PipelineSystem = class {
        constructor(renderer) {
          this._moduleCache = /* @__PURE__ */ Object.create(null);
          this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
          this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
          this._pipeCache = /* @__PURE__ */ Object.create(null);
          this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
          this._colorMask = 15;
          this._multisampleCount = 1;
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.setStencilMode(STENCIL_MODES.DISABLED);
          this._updatePipeHash();
        }
        setMultisampleCount(multisampleCount) {
          if (this._multisampleCount === multisampleCount)
            return;
          this._multisampleCount = multisampleCount;
          this._updatePipeHash();
        }
        setRenderTarget(renderTarget) {
          this._multisampleCount = renderTarget.msaaSamples;
          this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
          this._updatePipeHash();
        }
        setColorMask(colorMask) {
          if (this._colorMask === colorMask)
            return;
          this._colorMask = colorMask;
          this._updatePipeHash();
        }
        setStencilMode(stencilMode) {
          if (this._stencilMode === stencilMode)
            return;
          this._stencilMode = stencilMode;
          this._stencilState = GpuStencilModesToPixi[stencilMode];
          this._updatePipeHash();
        }
        setPipeline(geometry, program, state, passEncoder) {
          const pipeline = this.getPipeline(geometry, program, state);
          passEncoder.setPipeline(pipeline);
        }
        getPipeline(geometry, program, state, topology) {
          if (!geometry._layoutKey) {
            ensureAttributes(geometry, program.attributeData);
            this._generateBufferKey(geometry);
          }
          topology = topology || geometry.topology;
          const key = getGraphicsStateKey(
            geometry._layoutKey,
            program._layoutKey,
            state.data,
            state._blendModeId,
            topologyStringToId[topology]
          );
          if (this._pipeCache[key])
            return this._pipeCache[key];
          this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
          return this._pipeCache[key];
        }
        _createPipeline(geometry, program, state, topology) {
          const device = this._gpu.device;
          const buffers = this._createVertexBufferLayouts(geometry, program);
          const blendModes = this._renderer.state.getColorTargets(state);
          blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
          const layout = this._renderer.shader.getProgramData(program).pipeline;
          const descriptor = {
            // TODO later check if its helpful to create..
            // layout,
            vertex: {
              module: this._getModule(program.vertex.source),
              entryPoint: program.vertex.entryPoint,
              // geometry..
              buffers
            },
            fragment: {
              module: this._getModule(program.fragment.source),
              entryPoint: program.fragment.entryPoint,
              targets: blendModes
            },
            primitive: {
              topology,
              cullMode: state.cullMode
            },
            layout,
            multisample: {
              count: this._multisampleCount
            },
            // depthStencil,
            label: `PIXI Pipeline`
          };
          if (this._depthStencilAttachment) {
            descriptor.depthStencil = {
              ...this._stencilState,
              format: "depth24plus-stencil8",
              depthWriteEnabled: state.depthTest,
              depthCompare: state.depthTest ? "less" : "always"
            };
          }
          const pipeline = device.createRenderPipeline(descriptor);
          return pipeline;
        }
        _getModule(code) {
          return this._moduleCache[code] || this._createModule(code);
        }
        _createModule(code) {
          const device = this._gpu.device;
          this._moduleCache[code] = device.createShaderModule({
            code
          });
          return this._moduleCache[code];
        }
        _generateBufferKey(geometry) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(geometry.attributes).sort();
          for (let i3 = 0; i3 < attributeKeys.length; i3++) {
            const attribute = geometry.attributes[attributeKeys[i3]];
            keyGen[index++] = attribute.offset;
            keyGen[index++] = attribute.format;
            keyGen[index++] = attribute.stride;
            keyGen[index++] = attribute.instance;
          }
          const stringKey = keyGen.join("|");
          geometry._layoutKey = createIdFromString(stringKey, "geometry");
          return geometry._layoutKey;
        }
        _generateAttributeLocationsKey(program) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(program.attributeData).sort();
          for (let i3 = 0; i3 < attributeKeys.length; i3++) {
            const attribute = program.attributeData[attributeKeys[i3]];
            keyGen[index++] = attribute.location;
          }
          const stringKey = keyGen.join("|");
          program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
          return program._attributeLocationsKey;
        }
        /**
         * Returns a hash of buffer names mapped to bind locations.
         * This is used to bind the correct buffer to the correct location in the shader.
         * @param geometry - The geometry where to get the buffer names
         * @param program - The program where to get the buffer names
         * @returns An object of buffer names mapped to the bind location.
         */
        getBufferNamesToBind(geometry, program) {
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bindingNamesCache[key])
            return this._bindingNamesCache[key];
          const data = this._createVertexBufferLayouts(geometry, program);
          const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
          const attributeData = program.attributeData;
          for (let i3 = 0; i3 < data.length; i3++) {
            for (const j2 in attributeData) {
              if (attributeData[j2].location === i3) {
                bufferNamesToBind[i3] = j2;
                break;
              }
            }
          }
          this._bindingNamesCache[key] = bufferNamesToBind;
          return bufferNamesToBind;
        }
        _createVertexBufferLayouts(geometry, program) {
          if (!program._attributeLocationsKey)
            this._generateAttributeLocationsKey(program);
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bufferLayoutsCache[key]) {
            return this._bufferLayoutsCache[key];
          }
          const vertexBuffersLayout = [];
          geometry.buffers.forEach((buffer) => {
            const bufferEntry = {
              arrayStride: 0,
              stepMode: "vertex",
              attributes: []
            };
            const bufferEntryAttributes = bufferEntry.attributes;
            for (const i3 in program.attributeData) {
              const attribute = geometry.attributes[i3];
              if ((attribute.divisor ?? 1) !== 1) {
                warn(`Attribute ${i3} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
              }
              if (attribute.buffer === buffer) {
                bufferEntry.arrayStride = attribute.stride;
                bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
                bufferEntryAttributes.push({
                  shaderLocation: program.attributeData[i3].location,
                  offset: attribute.offset,
                  format: attribute.format
                });
              }
            }
            if (bufferEntryAttributes.length) {
              vertexBuffersLayout.push(bufferEntry);
            }
          });
          this._bufferLayoutsCache[key] = vertexBuffersLayout;
          return vertexBuffersLayout;
        }
        _updatePipeHash() {
          const key = getGlobalStateKey(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment
          );
          if (!this._pipeStateCaches[key]) {
            this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
          }
          this._pipeCache = this._pipeStateCaches[key];
        }
        destroy() {
          this._renderer = null;
          this._bufferLayoutsCache = null;
        }
      };
      PipelineSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "pipeline"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  function calculateProjection(pm, x2, y2, width, height, flipY) {
    const sign = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign * (1 / height * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign - y2 * pm.d;
    return pm;
  }
  var init_calculateProjection = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }
  var init_isRenderingToScreen = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
  var RenderTargetSystem;
  var init_RenderTargetSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
      init_Matrix();
      init_Rectangle();
      init_const7();
      init_calculateProjection();
      init_SystemRunner();
      init_CanvasSource();
      init_TextureSource();
      init_Texture();
      init_getCanvasTexture();
      init_isRenderingToScreen();
      init_RenderTarget();
      RenderTargetSystem = class {
        constructor(renderer) {
          this.rootViewPort = new Rectangle();
          this.viewport = new Rectangle();
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this.projectionMatrix = new Matrix();
          this.defaultClearColor = [0, 0, 0, 0];
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._renderer = renderer;
          renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
        }
        /** called when dev wants to finish a render pass */
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget);
        }
        /**
         * called when the renderer starts to render a scene.
         * @param options
         * @param options.target - the render target to render to
         * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param options.clearColor - the color to clear to
         * @param options.frame - the frame to render to
         */
        renderStart({
          target,
          clear,
          clearColor,
          frame
        }) {
          this._renderTargetStack.length = 0;
          this.push(
            target,
            clear,
            clearColor,
            frame
          );
          this.rootViewPort.copyFrom(this.viewport);
          this.rootRenderTarget = this.renderTarget;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        }
        postrender() {
          this.adaptor.postrender?.(this.rootRenderTarget);
        }
        /**
         * Binding a render surface! This is the main function of the render target system.
         * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
         * Once bound all draw calls will be rendered to the render surface.
         *
         * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
         * @param renderSurface - the render surface to bind
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to render to
         * @returns the render target that was bound
         */
        bind(renderSurface, clear = true, clearColor, frame) {
          const renderTarget = this.getRenderTarget(renderSurface);
          const didChange = this.renderTarget !== renderTarget;
          this.renderTarget = renderTarget;
          this.renderSurface = renderSurface;
          const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
            this.adaptor.resizeGpuRenderTarget(renderTarget);
            gpuRenderTarget.width = renderTarget.pixelWidth;
            gpuRenderTarget.height = renderTarget.pixelHeight;
          }
          const source7 = renderTarget.colorTexture;
          const viewport = this.viewport;
          const pixelWidth = source7.pixelWidth;
          const pixelHeight = source7.pixelHeight;
          if (!frame && renderSurface instanceof Texture) {
            frame = renderSurface.frame;
          }
          if (frame) {
            const resolution = source7._resolution;
            viewport.x = frame.x * resolution + 0.5 | 0;
            viewport.y = frame.y * resolution + 0.5 | 0;
            viewport.width = frame.width * resolution + 0.5 | 0;
            viewport.height = frame.height * resolution + 0.5 | 0;
          } else {
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = pixelWidth;
            viewport.height = pixelHeight;
          }
          calculateProjection(
            this.projectionMatrix,
            0,
            0,
            viewport.width / source7.resolution,
            viewport.height / source7.resolution,
            !renderTarget.isRoot
          );
          this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
          if (didChange) {
            this.onRenderTargetChange.emit(renderTarget);
          }
          return renderTarget;
        }
        clear(target, clear = CLEAR.ALL, clearColor) {
          if (!clear)
            return;
          if (target) {
            target = this.getRenderTarget(target);
          }
          this.adaptor.clear(
            target || this.renderTarget,
            clear,
            clearColor,
            this.viewport
          );
        }
        contextChange() {
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Push a render surface to the renderer. This will bind the render surface to the renderer,
         * @param renderSurface - the render surface to push
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to use when rendering to the render surface
         */
        push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
          const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
          this._renderTargetStack.push({
            renderTarget,
            frame
          });
          return renderTarget;
        }
        /** Pops the current render target from the renderer and restores the previous render target. */
        pop() {
          this._renderTargetStack.pop();
          const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
          this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
        }
        /**
         * Gets the render target from the provide render surface. Eg if its a texture,
         * it will return the render target for the texture.
         * If its a render target, it will return the same render target.
         * @param renderSurface - the render surface to get the render target for
         * @returns the render target for the render surface
         */
        getRenderTarget(renderSurface) {
          if (renderSurface.isTexture) {
            renderSurface = renderSurface.source;
          }
          return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
        }
        /**
         * Copies a render surface to another texture
         * @param sourceRenderSurfaceTexture - the render surface to copy from
         * @param destinationTexture - the texture to copy to
         * @param originSrc - the origin of the copy
         * @param originSrc.x - the x origin of the copy
         * @param originSrc.y - the y origin of the copy
         * @param size - the size of the copy
         * @param size.width - the width of the copy
         * @param size.height - the height of the copy
         * @param originDest - the destination origin (top left to paste from!)
         * @param originDest.x - the x origin of the paste
         * @param originDest.y - the y origin of the paste
         */
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          if (originSrc.x < 0) {
            size.width += originSrc.x;
            originDest.x -= originSrc.x;
            originSrc.x = 0;
          }
          if (originSrc.y < 0) {
            size.height += originSrc.y;
            originDest.y -= originSrc.y;
            originSrc.y = 0;
          }
          const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
          size.width = Math.min(size.width, pixelWidth - originSrc.x);
          size.height = Math.min(size.height, pixelHeight - originSrc.y);
          return this.adaptor.copyToTexture(
            sourceRenderSurfaceTexture,
            destinationTexture,
            originSrc,
            size,
            originDest
          );
        }
        /**
         * ensures that we have a depth stencil buffer available to render to
         * This is used by the mask system to make sure we have a stencil buffer.
         */
        ensureDepthStencil() {
          if (!this.renderTarget.stencil) {
            this.renderTarget.stencil = true;
            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
          }
        }
        /** nukes the render target system */
        destroy() {
          this._renderer = null;
          this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
            if (renderTarget !== key) {
              renderTarget.destroy();
            }
          });
          this._renderSurfaceToRenderTargetHash.clear();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (CanvasSource.test(renderSurface)) {
            renderSurface = getCanvasTexture(renderSurface).source;
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof TextureSource) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface]
            });
            if (CanvasSource.test(renderSurface.source.resource)) {
              renderTarget.isRoot = true;
            }
            renderSurface.once("destroy", () => {
              renderTarget.destroy();
              this._renderSurfaceToRenderTargetHash.delete(renderSurface);
              const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
              if (gpuRenderTarget) {
                this._gpuRenderTargetHash[renderTarget.uid] = null;
                this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
              }
            });
          }
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  var GpuRenderTarget;
  var init_GpuRenderTarget = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
      "use strict";
      GpuRenderTarget = class {
        constructor() {
          this.contexts = [];
          this.msaaTextures = [];
          this.msaaSamples = 1;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
  var GpuRenderTargetAdaptor;
  var init_GpuRenderTargetAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
      init_const7();
      init_CanvasSource();
      init_TextureSource();
      init_GpuRenderTarget();
      GpuRenderTargetAdaptor = class {
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderer = this._renderer;
          const baseGpuTexture = this._getGpuColorTexture(
            sourceRenderSurfaceTexture
          );
          const backGpuTexture = renderer.texture.getGpuSource(
            destinationTexture.source
          );
          renderer.encoder.commandEncoder.copyTextureToTexture(
            {
              texture: baseGpuTexture,
              origin: originSrc
            },
            {
              texture: backGpuTexture,
              origin: originDest
            },
            size
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
          gpuRenderTarget.descriptor = descriptor;
          this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
          this._renderer.encoder.beginRenderPass(gpuRenderTarget);
          this._renderer.encoder.setViewport(viewport);
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass();
        }
        /**
         * returns the gpu texture for the first color texture in the render target
         * mainly used by the filter manager to get copy the texture for blending
         * @param renderTarget
         * @returns a gpu texture
         */
        _getGpuColorTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (gpuRenderTarget.contexts[0]) {
            return gpuRenderTarget.contexts[0].getCurrentTexture();
          }
          return this._renderer.texture.getGpuSource(
            renderTarget.colorTextures[0].source
          );
        }
        getDescriptor(renderTarget, clear, clearValue) {
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const colorAttachments = renderTarget.colorTextures.map(
            (texture, i3) => {
              const context4 = gpuRenderTarget.contexts[i3];
              let view;
              let resolveTarget;
              if (context4) {
                const currentTexture = context4.getCurrentTexture();
                const canvasTextureView = currentTexture.createView();
                view = canvasTextureView;
              } else {
                view = this._renderer.texture.getGpuSource(texture).createView({
                  mipLevelCount: 1
                });
              }
              if (gpuRenderTarget.msaaTextures[i3]) {
                resolveTarget = view;
                view = this._renderer.texture.getTextureView(
                  gpuRenderTarget.msaaTextures[i3]
                );
              }
              const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
              clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
              return {
                view,
                resolveTarget,
                clearValue,
                storeOp: "store",
                loadOp
              };
            }
          );
          let depthStencilAttachment;
          if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
            renderTarget.ensureDepthStencilTexture();
            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
          }
          if (renderTarget.depthStencilTexture) {
            const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
            const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
            depthStencilAttachment = {
              view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp,
              depthClearValue: 1,
              depthLoadOp,
              depthStoreOp: "store"
            };
          }
          const descriptor = {
            colorAttachments,
            depthStencilAttachment
          };
          return descriptor;
        }
        clear(renderTarget, clear = true, clearColor, viewport) {
          if (!clear)
            return;
          const { gpu, encoder } = this._renderer;
          const device = gpu.device;
          const standAlone = encoder.commandEncoder === null;
          if (standAlone) {
            const commandEncoder = device.createCommandEncoder();
            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
            passEncoder.end();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
          } else {
            this.startRenderPass(renderTarget, clear, clearColor, viewport);
          }
        }
        initGpuRenderTarget(renderTarget) {
          renderTarget.isRoot = true;
          const gpuRenderTarget = new GpuRenderTarget();
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            if (CanvasSource.test(colorTexture.resource)) {
              const context4 = colorTexture.resource.getContext(
                "webgpu"
              );
              const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
              try {
                context4.configure({
                  device: this._renderer.gpu.device,
                  // eslint-disable-next-line max-len
                  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                  format: "bgra8unorm",
                  alphaMode
                });
              } catch (e2) {
                console.error(e2);
              }
              gpuRenderTarget.contexts[i3] = context4;
            }
            gpuRenderTarget.msaa = colorTexture.source.antialias;
            if (colorTexture.source.antialias) {
              const msaaTexture = new TextureSource({
                width: 0,
                height: 0,
                sampleCount: 4
              });
              gpuRenderTarget.msaaTextures[i3] = msaaTexture;
            }
          });
          if (gpuRenderTarget.msaa) {
            gpuRenderTarget.msaaSamples = 4;
            if (renderTarget.depthStencilTexture) {
              renderTarget.depthStencilTexture.source.sampleCount = 4;
            }
          }
          return gpuRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          gpuRenderTarget.contexts.forEach((context4) => {
            context4.unconfigure();
          });
          gpuRenderTarget.msaaTextures.forEach((texture) => {
            texture.destroy();
          });
          gpuRenderTarget.msaaTextures.length = 0;
          gpuRenderTarget.contexts.length = 0;
        }
        ensureDepthStencilTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        resizeGpuRenderTarget(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.width;
          gpuRenderTarget.height = renderTarget.height;
          if (gpuRenderTarget.msaa) {
            renderTarget.colorTextures.forEach((colorTexture, i3) => {
              const msaaTexture = gpuRenderTarget.msaaTextures[i3];
              msaaTexture?.resize(
                colorTexture.source.width,
                colorTexture.source.height,
                colorTexture.source._resolution
              );
            });
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem;
  var init_GpuRenderTargetSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GpuRenderTargetAdaptor();
      GpuRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GpuRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GpuRenderTargetSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem;
  var init_GpuShaderSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
      init_Extensions();
      GpuShaderSystem = class {
        constructor() {
          this._gpuProgramData = /* @__PURE__ */ Object.create(null);
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;
        }
        getProgramData(program) {
          return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
        }
        _createGPUProgramData(program) {
          const device = this._gpu.device;
          const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
          const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
          this._gpuProgramData[program._layoutKey] = {
            bindGroups,
            pipeline: device.createPipelineLayout(pipelineLayoutDesc)
          };
          return this._gpuProgramData[program._layoutKey];
        }
        destroy() {
          this._gpu = null;
          this._gpuProgramData = null;
        }
      };
      GpuShaderSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  var GpuBlendModesToPixi;
  var init_GpuBlendModesToPixi = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
      "use strict";
      GpuBlendModesToPixi = {};
      GpuBlendModesToPixi.normal = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.add = {
        alpha: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.multiply = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "dst",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.screen = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.overlay = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.none = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "zero",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["normal-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["add-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["screen-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.erase = {
        alpha: {
          srcFactor: "zero",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.min = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        }
      };
      GpuBlendModesToPixi.max = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem;
  var init_GpuStateSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_GpuBlendModesToPixi();
      GpuStateSystem = class {
        constructor() {
          this.defaultState = new State();
          this.defaultState.blend = true;
        }
        contextChange(gpu) {
          this.gpu = gpu;
        }
        /**
         * Gets the blend mode data for the current state
         * @param state - The state to get the blend mode from
         */
        getColorTargets(state) {
          const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
          return [
            {
              format: "bgra8unorm",
              writeMask: 0,
              blend
            }
          ];
        }
        destroy() {
          this.gpu = null;
        }
      };
      GpuStateSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "state"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  var gpuUploadBufferImageResource;
  var init_gpuUploadBufferImageResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
      "use strict";
      gpuUploadBufferImageResource = {
        type: "image",
        upload(source7, gpuTexture, gpu) {
          const resource = source7.resource;
          const total = (source7.pixelWidth | 0) * (source7.pixelHeight | 0);
          const bytesPerPixel = resource.byteLength / total;
          gpu.device.queue.writeTexture(
            { texture: gpuTexture },
            resource,
            {
              offset: 0,
              rowsPerImage: source7.pixelHeight,
              bytesPerRow: source7.pixelHeight * bytesPerPixel
            },
            {
              width: source7.pixelWidth,
              height: source7.pixelHeight,
              depthOrArrayLayers: 1
            }
          );
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
  var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
  var init_gpuUploadCompressedTextureResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
      "use strict";
      blockDataMap = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
      };
      defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
      gpuUploadCompressedTextureResource = {
        type: "compressed",
        upload(source7, gpuTexture, gpu) {
          let mipWidth = source7.pixelWidth;
          let mipHeight = source7.pixelHeight;
          const blockData = blockDataMap[source7.format] || defaultBlockData;
          for (let i3 = 0; i3 < source7.resource.length; i3++) {
            const levelBuffer = source7.resource[i3];
            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
            gpu.device.queue.writeTexture(
              {
                texture: gpuTexture,
                mipLevel: i3
              },
              levelBuffer,
              {
                offset: 0,
                bytesPerRow
              },
              {
                width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
                height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
                depthOrArrayLayers: 1
              }
            );
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource;
  var init_gpuUploadImageSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
      "use strict";
      gpuUploadImageResource = {
        type: "image",
        upload(source7, gpuTexture, gpu) {
          const resource = source7.resource;
          if (!resource)
            return;
          const width = Math.min(gpuTexture.width, source7.resourceWidth || source7.pixelWidth);
          const height = Math.min(gpuTexture.height, source7.resourceHeight || source7.pixelHeight);
          const premultipliedAlpha = source7.alphaMode === "premultiply-alpha-on-upload";
          gpu.device.queue.copyExternalImageToTexture(
            { source: resource },
            { texture: gpuTexture, premultipliedAlpha },
            {
              width,
              height
            }
          );
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource;
  var init_gpuUploadVideoSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
      init_gpuUploadImageSource();
      gpuUploadVideoResource = {
        type: "video",
        upload(source7, gpuTexture, gpu) {
          gpuUploadImageResource.upload(source7, gpuTexture, gpu);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  var GpuMipmapGenerator;
  var init_GpuMipmapGenerator = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
      "use strict";
      GpuMipmapGenerator = class {
        constructor(device) {
          this.device = device;
          this.sampler = device.createSampler({ minFilter: "linear" });
          this.pipelines = {};
        }
        _getMipmapPipeline(format) {
          let pipeline = this.pipelines[format];
          if (!pipeline) {
            if (!this.mipmapShaderModule) {
              this.mipmapShaderModule = this.device.createShaderModule({
                code: (
                  /* wgsl */
                  `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
                )
              });
            }
            pipeline = this.device.createRenderPipeline({
              layout: "auto",
              vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
              },
              fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{ format }]
              }
            });
            this.pipelines[format] = pipeline;
          }
          return pipeline;
        }
        /**
         * Generates mipmaps for the given GPUTexture from the data in level 0.
         * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
         * @returns {module:External.GPUTexture} - The originally passed texture
         */
        generateMipmap(texture) {
          const pipeline = this._getMipmapPipeline(texture.format);
          if (texture.dimension === "3d" || texture.dimension === "1d") {
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
          }
          let mipTexture = texture;
          const arrayLayerCount = texture.depthOrArrayLayers || 1;
          const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
          if (!renderToSource) {
            const mipTextureDescriptor = {
              size: {
                width: Math.ceil(texture.width / 2),
                height: Math.ceil(texture.height / 2),
                depthOrArrayLayers: arrayLayerCount
              },
              format: texture.format,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: texture.mipLevelCount - 1
            };
            mipTexture = this.device.createTexture(mipTextureDescriptor);
          }
          const commandEncoder = this.device.createCommandEncoder({});
          const bindGroupLayout = pipeline.getBindGroupLayout(0);
          for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
            let srcView = texture.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            let dstMipLevel = renderToSource ? 1 : 0;
            for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
              const dstView = mipTexture.createView({
                baseMipLevel: dstMipLevel++,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: arrayLayer,
                arrayLayerCount: 1
              });
              const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [{
                  view: dstView,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 }
                }]
              });
              const bindGroup = this.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{
                  binding: 0,
                  resource: this.sampler
                }, {
                  binding: 1,
                  resource: srcView
                }]
              });
              passEncoder.setPipeline(pipeline);
              passEncoder.setBindGroup(0, bindGroup);
              passEncoder.draw(3, 1, 0, 0);
              passEncoder.end();
              srcView = dstView;
            }
          }
          if (!renderToSource) {
            const mipLevelSize = {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            };
            for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
              commandEncoder.copyTextureToTexture({
                texture: mipTexture,
                mipLevel: i3 - 1
              }, {
                texture,
                mipLevel: i3
              }, mipLevelSize);
              mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
              mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
            }
          }
          this.device.queue.submit([commandEncoder.finish()]);
          if (!renderToSource) {
            mipTexture.destroy();
          }
          return texture;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GpuTextureSystem;
  var init_GpuTextureSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_UniformGroup();
      init_CanvasPool();
      init_BindGroup();
      init_gpuUploadBufferImageResource();
      init_gpuUploadCompressedTextureResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_GpuMipmapGenerator();
      GpuTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._gpuSources = /* @__PURE__ */ Object.create(null);
          this._gpuSamplers = /* @__PURE__ */ Object.create(null);
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._textureViewHash = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: gpuUploadImageResource,
            buffer: gpuUploadBufferImageResource,
            video: gpuUploadVideoResource,
            compressed: gpuUploadCompressedTextureResource
          };
          this._renderer = renderer;
          renderer.renderableGC.addManagedHash(this, "_gpuSources");
          renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
          renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
          renderer.renderableGC.addManagedHash(this, "_textureViewHash");
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        initSource(source7) {
          if (source7.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source7.pixelWidth, source7.pixelHeight);
            source7.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
          if (source7.uploadMethodId !== "compressed") {
            usage |= GPUTextureUsage.RENDER_ATTACHMENT;
            usage |= GPUTextureUsage.COPY_SRC;
          }
          const blockData = blockDataMap[source7.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
          const width = Math.ceil(source7.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
          const height = Math.ceil(source7.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
          const textureDescriptor = {
            label: source7.label,
            size: { width, height },
            format: source7.format,
            sampleCount: source7.sampleCount,
            mipLevelCount: source7.mipLevelCount,
            dimension: source7.dimension,
            usage
          };
          const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
          this._gpuSources[source7.uid] = gpuTexture;
          if (!this.managedTextures.includes(source7)) {
            source7.on("update", this.onSourceUpdate, this);
            source7.on("resize", this.onSourceResize, this);
            source7.on("destroy", this.onSourceDestroy, this);
            source7.on("unload", this.onSourceUnload, this);
            source7.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source7);
          }
          this.onSourceUpdate(source7);
          return gpuTexture;
        }
        onSourceUpdate(source7) {
          const gpuTexture = this.getGpuSource(source7);
          if (!gpuTexture)
            return;
          if (this._uploads[source7.uploadMethodId]) {
            this._uploads[source7.uploadMethodId].upload(source7, gpuTexture, this._gpu);
          }
          if (source7.autoGenerateMipmaps && source7.mipLevelCount > 1) {
            this.onUpdateMipmaps(source7);
          }
        }
        onSourceUnload(source7) {
          const gpuTexture = this._gpuSources[source7.uid];
          if (gpuTexture) {
            this._gpuSources[source7.uid] = null;
            gpuTexture.destroy();
          }
        }
        onUpdateMipmaps(source7) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          const gpuTexture = this.getGpuSource(source7);
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
        onSourceDestroy(source7) {
          source7.off("update", this.onSourceUpdate, this);
          source7.off("unload", this.onSourceUnload, this);
          source7.off("destroy", this.onSourceDestroy, this);
          source7.off("resize", this.onSourceResize, this);
          source7.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source7), 1);
          this.onSourceUnload(source7);
        }
        onSourceResize(source7) {
          const gpuTexture = this._gpuSources[source7.uid];
          if (!gpuTexture) {
            this.initSource(source7);
          } else if (gpuTexture.width !== source7.pixelWidth || gpuTexture.height !== source7.pixelHeight) {
            this._textureViewHash[source7.uid] = null;
            this._bindGroupHash[source7.uid] = null;
            this.onSourceUnload(source7);
            this.initSource(source7);
          }
        }
        _initSampler(sampler) {
          this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
          return this._gpuSamplers[sampler._resourceId];
        }
        getGpuSampler(sampler) {
          return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGpuSource(source7) {
          return this._gpuSources[source7.uid] || this.initSource(source7);
        }
        /**
         * this returns s bind group for a specific texture, the bind group contains
         * - the texture source
         * - the texture style
         * - the texture matrix
         * This is cached so the bind group should only be created once per texture
         * @param texture - the texture you want the bindgroup for
         * @returns the bind group for the texture
         */
        getTextureBindGroup(texture) {
          return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
        }
        _createTextureBindGroup(texture) {
          const source7 = texture.source;
          this._bindGroupHash[texture.uid] = new BindGroup({
            0: source7,
            1: source7.style,
            2: new UniformGroup({
              uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
            })
          });
          return this._bindGroupHash[texture.uid];
        }
        getTextureView(texture) {
          const source7 = texture.source;
          return this._textureViewHash[source7.uid] ?? this._createTextureView(source7);
        }
        _createTextureView(texture) {
          this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
          return this._textureViewHash[texture.uid];
        }
        generateCanvas(texture) {
          const renderer = this._renderer;
          const commandEncoder = renderer.gpu.device.createCommandEncoder();
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = texture.source.pixelWidth;
          canvas.height = texture.source.pixelHeight;
          const context4 = canvas.getContext("webgpu");
          context4.configure({
            device: renderer.gpu.device,
            // eslint-disable-next-line max-len
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
          });
          commandEncoder.copyTextureToTexture({
            texture: renderer.texture.getGpuSource(texture.source),
            origin: {
              x: 0,
              y: 0
            }
          }, {
            texture: context4.getCurrentTexture()
          }, {
            width: canvas.width,
            height: canvas.height
          });
          renderer.gpu.device.queue.submit([commandEncoder.finish()]);
          return canvas;
        }
        getPixels(texture) {
          const webGPUCanvas = this.generateCanvas(texture);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
          const context4 = canvasAndContext.context;
          context4.drawImage(webGPUCanvas, 0, 0);
          const { width, height } = webGPUCanvas;
          const imageData = context4.getImageData(0, 0, width, height);
          const pixels = new Uint8ClampedArray(imageData.data.buffer);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return { pixels, width, height };
        }
        destroy() {
          this.managedTextures.slice().forEach((source7) => this.onSourceDestroy(source7));
          this.managedTextures = null;
          for (const k2 of Object.keys(this._bindGroupHash)) {
            const key = Number(k2);
            const bindGroup = this._bindGroupHash[key];
            bindGroup?.destroy();
            this._bindGroupHash[key] = null;
          }
          this._gpu = null;
          this._mipmapGenerator = null;
          this._gpuSources = null;
          this._bindGroupHash = null;
          this._textureViewHash = null;
          this._gpuSamplers = null;
        }
      };
      GpuTextureSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var WebGPURenderer_exports = {};
  __export(WebGPURenderer_exports, {
    WebGPURenderer: () => WebGPURenderer
  });
  var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
  var init_WebGPURenderer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
      init_Extensions();
      init_GpuGraphicsAdaptor();
      init_GpuMeshAdapter();
      init_GpuBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuStencilSystem();
      init_GpuUboSystem();
      init_GpuUniformBatchPipe();
      init_PipelineSystem();
      init_GpuRenderTargetSystem();
      init_GpuShaderSystem();
      init_GpuStateSystem();
      init_GpuTextureSystem();
      DefaultWebGPUSystems = [
        ...SharedSystems,
        GpuUboSystem,
        GpuEncoderSystem,
        GpuDeviceSystem,
        GpuBufferSystem,
        GpuTextureSystem,
        GpuRenderTargetSystem,
        GpuShaderSystem,
        GpuStateSystem,
        PipelineSystem,
        GpuColorMaskSystem,
        GpuStencilSystem,
        BindGroupSystem
      ];
      DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
      DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
      systems = [];
      renderPipes = [];
      renderPipeAdaptors = [];
      extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
      extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
      extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
      extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
      WebGPURenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgpu",
            type: RendererType.WEBGPU,
            systems,
            renderPipes,
            renderPipeAdaptors
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor;
  var init_GlGraphicsAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_maxRecommendedTextures();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      GlGraphicsAdaptor = class {
        init() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures2 = getMaxTexturesPerBatch();
          const glProgram3 = compileHighShaderGlProgram({
            name: "graphics",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              localUniformBitGl,
              roundPixelsBitGl
            ]
          });
          this.shader = new Shader({
            glProgram: glProgram3,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context4 = renderable.context;
          const shader = context4.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context4);
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          renderer.state.set(graphicsPipe.state);
          renderer.shader.bind(shader);
          renderer.geometry.bind(batcher.geometry, shader.glProgram);
          const batches = instructions.instructions;
          for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
            const batch = batches[i3];
            if (batch.size) {
              for (let j2 = 0; j2 < batch.textures.count; j2++) {
                renderer.texture.bind(batch.textures.textures[j2], j2);
              }
              renderer.geometry.draw("triangle-list", batch.size, batch.start);
            }
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GlGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor;
  var init_GlMeshAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GlMeshAdaptor = class {
        init() {
          const glProgram3 = compileHighShaderGlProgram({
            name: "mesh",
            bits: [
              localUniformBitGl,
              textureBitGl,
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram: glProgram3,
            resources: {
              uTexture: Texture.EMPTY.source,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            const texture = mesh.texture;
            const source7 = texture.source;
            shader.resources.uTexture = source7;
            shader.resources.uSampler = source7.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
          } else if (!shader.glProgram) {
            warn("Mesh shader has no glProgram", mesh.shader);
            return;
          }
          shader.groups[100] = renderer.globalUniforms.bindGroup;
          shader.groups[101] = meshPipe.localUniformsBindGroup;
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlMeshAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor;
  var init_GlBatchAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
      init_Extensions();
      init_State();
      GlBatchAdaptor = class {
        constructor() {
          this._didUpload = false;
          this._tempState = State.for2d();
        }
        init(batcherPipe) {
          batcherPipe.renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._didUpload = false;
        }
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          renderer.shader.bind(shader, this._didUpload);
          renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
          renderer.geometry.bind(geometry, shader.glProgram);
        }
        execute(batchPipe, batch) {
          const renderer = batchPipe.renderer;
          this._didUpload = true;
          this._tempState.blendMode = batch.blendMode;
          renderer.state.set(this._tempState);
          const textures = batch.textures.textures;
          for (let i3 = 0; i3 < batch.textures.count; i3++) {
            renderer.texture.bind(textures[i3], i3);
          }
          renderer.geometry.draw("triangle-list", batch.size, batch.start);
        }
      };
      GlBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
  var BUFFER_TYPE;
  var init_const9 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
      "use strict";
      BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
        BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        return BUFFER_TYPE2;
      })(BUFFER_TYPE || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  var GlBuffer;
  var init_GlBuffer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
      "use strict";
      GlBuffer = class {
        constructor(buffer, type) {
          this.buffer = buffer || null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = type;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem;
  var init_GlBufferSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
      init_Extensions();
      init_const4();
      init_const9();
      init_GlBuffer();
      GlBufferSystem = class {
        /**
         * @param {Renderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        /**
         * @ignore
         */
        destroy() {
          this._renderer = null;
          this._gl = null;
          this._gpuBuffers = null;
          this._boundBufferBases = null;
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._gl = this._renderer.gl;
        }
        getGlBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
        }
        /**
         * This binds specified buffer. On first run, it will create the webGL buffers for the context too
         * @param buffer - the buffer to bind to the renderer
         */
        bind(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        }
        /**
         * Binds an uniform buffer to at the given index.
         *
         * A cache is used so a buffer will not be bound again if already bound.
         * @param buffer - the buffer to bind
         * @param index - the base index to bind it to.
         */
        bindBufferBase(buffer, index) {
          const { _gl: gl } = this;
          if (this._boundBufferBases[index] !== buffer) {
            const glBuffer = this.getGlBuffer(buffer);
            this._boundBufferBases[index] = buffer;
            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
          }
        }
        /**
         * Binds a buffer whilst also binding its range.
         * This will make the buffer start from the offset supplied rather than 0 when it is read.
         * @param buffer - the buffer to bind
         * @param index - the base index to bind at, defaults to 0
         * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
         */
        bindBufferRange(buffer, index, offset) {
          const { _gl: gl } = this;
          offset = offset || 0;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
        }
        /**
         * Will ensure the data in the buffer is uploaded to the GPU.
         * @param {Buffer} buffer - the buffer to update
         */
        updateBuffer(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          if (buffer._updateID === glBuffer.updateID) {
            return glBuffer;
          }
          glBuffer.updateID = buffer._updateID;
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
          const data = buffer.data;
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
          } else {
            const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = data.byteLength;
            gl.bufferData(glBuffer.type, data, drawType);
          }
          return glBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          const gl = this._gl;
          for (const id in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id].buffer);
          }
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Disposes buffer
         * @param {Buffer} buffer - buffer with data
         * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
         */
        onBufferDestroy(buffer, contextLost) {
          const glBuffer = this._gpuBuffers[buffer.uid];
          const gl = this._gl;
          if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
          }
          this._gpuBuffers[buffer.uid] = null;
        }
        /**
         * creates and attaches a GLBuffer object tied to the current context.
         * @param buffer
         * @protected
         */
        createGLBuffer(buffer) {
          const { _gl: gl } = this;
          let type = BUFFER_TYPE.ARRAY_BUFFER;
          if (buffer.descriptor.usage & BufferUsage.INDEX) {
            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
            type = BUFFER_TYPE.UNIFORM_BUFFER;
          }
          const glBuffer = new GlBuffer(gl.createBuffer(), type);
          this._gpuBuffers[buffer.uid] = glBuffer;
          buffer.on("destroy", this.onBufferDestroy, this);
          return glBuffer;
        }
      };
      GlBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var _GlContextSystem, GlContextSystem;
  var init_GlContextSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      _GlContextSystem = class _GlContextSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this.supports = {
            /** Support for 32-bit indices buffer. */
            uint32Indices: true,
            /** Support for UniformBufferObjects */
            uniformBufferObject: true,
            /** Support for VertexArrayObjects */
            vertexArrayObject: true,
            /** Support for SRGB texture format */
            srgbTextures: true,
            /** Support for wrapping modes if a texture is non-power of two */
            nonPowOf2wrapping: true,
            /** Support for MSAA (antialiasing of dynamic textures) */
            msaa: true,
            /** Support for mipmaps if a texture is non-power of two */
            nonPowOf2mipmaps: true
          };
          this._renderer = renderer;
          this.extensions = /* @__PURE__ */ Object.create(null);
          this.handleContextLost = this.handleContextLost.bind(this);
          this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        /**
         * `true` if the context is lost
         * @readonly
         */
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        /**
         * Handles the context change event.
         * @param {WebGLRenderingContext} gl - New WebGL context.
         */
        contextChange(gl) {
          this.gl = gl;
          this._renderer.gl = gl;
        }
        init(options) {
          options = { ..._GlContextSystem2.defaultOptions, ...options };
          let multiView = this.multiView = options.multiView;
          if (options.context && multiView) {
            warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
            multiView = false;
          }
          if (multiView) {
            this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
          } else {
            this.canvas = this._renderer.view.canvas;
          }
          if (options.context) {
            this.initFromContext(options.context);
          } else {
            const alpha = this._renderer.background.alpha < 1;
            const premultipliedAlpha = options.premultipliedAlpha ?? true;
            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(options.preferWebGLVersion, {
              alpha,
              premultipliedAlpha,
              antialias,
              stencil: true,
              preserveDrawingBuffer: options.preserveDrawingBuffer,
              powerPreference: options.powerPreference ?? "default"
            });
          }
        }
        ensureCanvasSize(targetCanvas) {
          if (!this.multiView) {
            if (targetCanvas !== this.canvas) {
              warn("multiView is disabled, but targetCanvas is not the main canvas");
            }
            return;
          }
          const { canvas } = this;
          if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
          }
        }
        /**
         * Initializes the context.
         * @protected
         * @param {WebGLRenderingContext} gl - WebGL context
         */
        initFromContext(gl) {
          this.gl = gl;
          this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
          this.getExtensions();
          this.validateContext(gl);
          this._renderer.runners.contextChange.emit(gl);
          const element = this._renderer.view.canvas;
          element.addEventListener("webglcontextlost", this.handleContextLost, false);
          element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        /**
         * Initialize from context options
         * @protected
         * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
         * @param preferWebGLVersion
         * @param {object} options - context attributes
         */
        createContext(preferWebGLVersion, options) {
          let gl;
          const canvas = this.canvas;
          if (preferWebGLVersion === 2) {
            gl = canvas.getContext("webgl2", options);
          }
          if (!gl) {
            gl = canvas.getContext("webgl", options);
            if (!gl) {
              throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            }
          }
          this.gl = gl;
          this.initFromContext(this.gl);
        }
        /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
        getExtensions() {
          const { gl } = this;
          const common = {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            // eslint-disable-line camelcase
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc"),
            bptc: gl.getExtension("EXT_texture_compression_bptc"),
            rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
            loseContext: gl.getExtension("WEBGL_lose_context")
          };
          if (this.webGLVersion === 1) {
            this.extensions = {
              ...common,
              drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
              depthTexture: gl.getExtension("WEBGL_depth_texture"),
              vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
              // Floats and half-floats
              floatTexture: gl.getExtension("OES_texture_float"),
              floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
              textureHalfFloat: gl.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
              srgb: gl.getExtension("EXT_sRGB")
            };
          } else {
            this.extensions = {
              ...common,
              colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
            };
            const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
            if (provokeExt) {
              provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
            }
          }
        }
        /**
         * Handles a lost webgl context
         * @param {WebGLContextEvent} event - The context lost event.
         */
        handleContextLost(event) {
          event.preventDefault();
          if (this._contextLossForced) {
            this._contextLossForced = false;
            setTimeout(() => {
              if (this.gl.isContextLost()) {
                this.extensions.loseContext?.restoreContext();
              }
            }, 0);
          }
        }
        /** Handles a restored webgl context. */
        handleContextRestored() {
          this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          const element = this._renderer.view.canvas;
          this._renderer = null;
          element.removeEventListener("webglcontextlost", this.handleContextLost);
          element.removeEventListener("webglcontextrestored", this.handleContextRestored);
          this.gl.useProgram(null);
          this.extensions.loseContext?.loseContext();
        }
        /**
         * this function can be called to force a webGL context loss
         * this will release all resources on the GPU.
         * Useful if you need to put Pixi to sleep, and save some GPU memory
         *
         * As soon as render is called - all resources will be created again.
         */
        forceContextLoss() {
          this.extensions.loseContext?.loseContext();
          this._contextLossForced = true;
        }
        /**
         * Validate context.
         * @param {WebGLRenderingContext} gl - Render context.
         */
        validateContext(gl) {
          const attributes = gl.getContextAttributes();
          if (attributes && !attributes.stencil) {
            warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          }
          const supports = this.supports;
          const isWebGl2 = this.webGLVersion === 2;
          const extensions2 = this.extensions;
          supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
          supports.uniformBufferObject = isWebGl2;
          supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
          supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
          supports.nonPowOf2wrapping = isWebGl2;
          supports.nonPowOf2mipmaps = isWebGl2;
          supports.msaa = isWebGl2;
          if (!supports.uint32Indices) {
            warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
          }
        }
      };
      _GlContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "context"
      };
      _GlContextSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.context}
         * @default null
         */
        context: null,
        /**
         * {@link WebGLOptions.premultipliedAlpha}
         * @default true
         */
        premultipliedAlpha: true,
        /**
         * {@link WebGLOptions.preserveDrawingBuffer}
         * @default false
         */
        preserveDrawingBuffer: false,
        /**
         * {@link WebGLOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * {@link WebGLOptions.webGLVersion}
         * @default 2
         */
        preferWebGLVersion: 2,
        /**
         * {@link WebGLOptions.multiView}
         * @default false
         */
        multiView: false
      };
      GlContextSystem = _GlContextSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
  var GL_FORMATS, GL_TARGETS, GL_WRAP_MODES, GL_TYPES;
  var init_const10 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
      "use strict";
      GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
        GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
        GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
        GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
        GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
        GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        return GL_FORMATS2;
      })(GL_FORMATS || {});
      GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        return GL_TARGETS2;
      })(GL_TARGETS || {});
      GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {
        GL_WRAP_MODES2[GL_WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
        GL_WRAP_MODES2[GL_WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
        GL_WRAP_MODES2[GL_WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
        return GL_WRAP_MODES2;
      })(GL_WRAP_MODES || {});
      GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
        GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
        GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
        GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
        GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
        GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
        return GL_TYPES2;
      })(GL_TYPES || {});
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
  function getGlTypeFromFormat(format) {
    return infoMap[format] ?? infoMap.float32;
  }
  var infoMap;
  var init_getGlTypeFromFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
      init_const10();
      infoMap = {
        uint8x2: GL_TYPES.UNSIGNED_BYTE,
        uint8x4: GL_TYPES.UNSIGNED_BYTE,
        sint8x2: GL_TYPES.BYTE,
        sint8x4: GL_TYPES.BYTE,
        unorm8x2: GL_TYPES.UNSIGNED_BYTE,
        unorm8x4: GL_TYPES.UNSIGNED_BYTE,
        snorm8x2: GL_TYPES.BYTE,
        snorm8x4: GL_TYPES.BYTE,
        uint16x2: GL_TYPES.UNSIGNED_SHORT,
        uint16x4: GL_TYPES.UNSIGNED_SHORT,
        sint16x2: GL_TYPES.SHORT,
        sint16x4: GL_TYPES.SHORT,
        unorm16x2: GL_TYPES.UNSIGNED_SHORT,
        unorm16x4: GL_TYPES.UNSIGNED_SHORT,
        snorm16x2: GL_TYPES.SHORT,
        snorm16x4: GL_TYPES.SHORT,
        float16x2: GL_TYPES.HALF_FLOAT,
        float16x4: GL_TYPES.HALF_FLOAT,
        float32: GL_TYPES.FLOAT,
        float32x2: GL_TYPES.FLOAT,
        float32x3: GL_TYPES.FLOAT,
        float32x4: GL_TYPES.FLOAT,
        uint32: GL_TYPES.UNSIGNED_INT,
        uint32x2: GL_TYPES.UNSIGNED_INT,
        uint32x3: GL_TYPES.UNSIGNED_INT,
        uint32x4: GL_TYPES.UNSIGNED_INT,
        sint32: GL_TYPES.INT,
        sint32x2: GL_TYPES.INT,
        sint32x3: GL_TYPES.INT,
        sint32x4: GL_TYPES.INT
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var topologyToGlMap, GlGeometrySystem;
  var init_GlGeometrySystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
      init_Extensions();
      init_getAttributeInfoFromFormat();
      init_ensureAttributes();
      init_getGlTypeFromFormat();
      topologyToGlMap = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
      };
      GlGeometrySystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._activeGeometry = null;
          this._activeVao = null;
          this.hasVao = true;
          this.hasInstance = true;
          this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          const gl = this.gl = this._renderer.gl;
          if (!this._renderer.context.supports.vertexArrayObject) {
            throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
          }
          const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
          if (nativeVaoExtension) {
            gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
            gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
            gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
          }
          const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
          if (nativeInstancedExtension) {
            gl.drawArraysInstanced = (a2, b2, c2, d2) => {
              nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
            };
            gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
              nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
            };
            gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
          }
          this._activeGeometry = null;
          this._activeVao = null;
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Binds geometry so that is can be drawn. Creating a Vao if required
         * @param geometry - Instance of geometry to bind.
         * @param program - Instance of program to use vao for.
         */
        bind(geometry, program) {
          const gl = this.gl;
          this._activeGeometry = geometry;
          const vao = this.getVao(geometry, program);
          if (this._activeVao !== vao) {
            this._activeVao = vao;
            gl.bindVertexArray(vao);
          }
          this.updateBuffers();
        }
        /** Reset and unbind any active VAO and geometry. */
        reset() {
          this.unbind();
        }
        /** Update buffers of the currently bound geometry. */
        updateBuffers() {
          const geometry = this._activeGeometry;
          const bufferSystem = this._renderer.buffer;
          for (let i3 = 0; i3 < geometry.buffers.length; i3++) {
            const buffer = geometry.buffers[i3];
            bufferSystem.updateBuffer(buffer);
          }
        }
        /**
         * Check compatibility between a geometry and a program
         * @param geometry - Geometry instance.
         * @param program - Program instance.
         */
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes;
          const shaderAttributes = program._attributeData;
          for (const j2 in shaderAttributes) {
            if (!geometryAttributes[j2]) {
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
            }
          }
        }
        /**
         * Takes a geometry and program and generates a unique signature for them.
         * @param geometry - To get signature from.
         * @param program - To test geometry against.
         * @returns - Unique signature of the geometry and program
         */
        getSignature(geometry, program) {
          const attribs = geometry.attributes;
          const shaderAttributes = program._attributeData;
          const strings = ["g", geometry.uid];
          for (const i3 in attribs) {
            if (shaderAttributes[i3]) {
              strings.push(i3, shaderAttributes[i3].location);
            }
          }
          return strings.join("-");
        }
        getVao(geometry, program) {
          return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
        }
        /**
         * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
         * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
         * attribute locations.
         * @param geometry - Instance of geometry to to generate Vao for.
         * @param program
         * @param _incRefCount - Increment refCount of all geometry buffers.
         */
        initGeometryVao(geometry, program, _incRefCount = true) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          this._renderer.shader._getProgramData(program);
          this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program);
          if (!this._geometryVaoHash[geometry.uid]) {
            this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
            geometry.on("destroy", this.onGeometryDestroy, this);
          }
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          let vao = vaoObjectHash[signature];
          if (vao) {
            vaoObjectHash[program._key] = vao;
            return vao;
          }
          ensureAttributes(geometry, program._attributeData);
          const buffers = geometry.buffers;
          vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          for (let i3 = 0; i3 < buffers.length; i3++) {
            const buffer = buffers[i3];
            bufferSystem.bind(buffer);
          }
          this.activateVao(geometry, program);
          vaoObjectHash[program._key] = vao;
          vaoObjectHash[signature] = vao;
          gl.bindVertexArray(null);
          return vao;
        }
        /**
         * Disposes geometry.
         * @param geometry - Geometry with buffers. Only VAO will be disposed
         * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
         */
        onGeometryDestroy(geometry, contextLost) {
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          const gl = this.gl;
          if (vaoObjectHash) {
            if (contextLost) {
              for (const i3 in vaoObjectHash) {
                if (this._activeVao !== vaoObjectHash[i3]) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[i3]);
              }
            }
            this._geometryVaoHash[geometry.uid] = null;
          }
        }
        /**
         * Dispose all WebGL resources of all managed geometries.
         * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
         */
        destroyAll(contextLost = false) {
          const gl = this.gl;
          for (const i3 in this._geometryVaoHash) {
            if (contextLost) {
              for (const j2 in this._geometryVaoHash[i3]) {
                const vaoObjectHash = this._geometryVaoHash[i3];
                if (this._activeVao !== vaoObjectHash) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[j2]);
              }
            }
            this._geometryVaoHash[i3] = null;
          }
        }
        /**
         * Activate vertex array object.
         * @param geometry - Geometry instance.
         * @param program - Shader program instance.
         */
        activateVao(geometry, program) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          const attributes = geometry.attributes;
          if (geometry.indexBuffer) {
            bufferSystem.bind(geometry.indexBuffer);
          }
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const buffer = attribute.buffer;
            const glBuffer = bufferSystem.getGlBuffer(buffer);
            const programAttrib = program._attributeData[j2];
            if (programAttrib) {
              if (lastBuffer !== glBuffer) {
                bufferSystem.bind(buffer);
                lastBuffer = glBuffer;
              }
              const location = programAttrib.location;
              gl.enableVertexAttribArray(location);
              const attributeInfo = getAttributeInfoFromFormat(attribute.format);
              const type = getGlTypeFromFormat(attribute.format);
              if (programAttrib.format?.substring(1, 4) === "int") {
                gl.vertexAttribIPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attribute.stride,
                  attribute.offset
                );
              } else {
                gl.vertexAttribPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attributeInfo.normalised,
                  attribute.stride,
                  attribute.offset
                );
              }
              if (attribute.instance) {
                if (this.hasInstance) {
                  const divisor = attribute.divisor ?? 1;
                  gl.vertexAttribDivisor(location, divisor);
                } else {
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
              }
            }
          }
        }
        /**
         * Draws the currently bound geometry.
         * @param topology - The type primitive to render.
         * @param size - The number of elements to be rendered. If not specified, all vertices after the
         *  starting vertex will be drawn.
         * @param start - The starting vertex in the geometry to start drawing from. If not specified,
         *  drawing will start from the first vertex.
         * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
         *  all instances will be drawn.
         */
        draw(topology, size, start, instanceCount) {
          const { gl } = this._renderer;
          const geometry = this._activeGeometry;
          const glTopology = topologyToGlMap[geometry.topology || topology];
          instanceCount || (instanceCount = geometry.instanceCount);
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            if (instanceCount > 1) {
              gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
            } else {
              gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else if (instanceCount > 1) {
            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
          } else {
            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
          }
          return this;
        }
        /** Unbind/reset everything. */
        unbind() {
          this.gl.bindVertexArray(null);
          this._activeVao = null;
          this._activeGeometry = null;
        }
        destroy() {
          this._renderer = null;
          this.gl = null;
          this._activeVao = null;
          this._activeGeometry = null;
        }
      };
      GlGeometrySystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "geometry"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
  var init_GlBackBufferSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_Geometry();
      init_Shader();
      init_State();
      init_TextureSource();
      init_Texture();
      init_GlProgram();
      bigTriangleGeometry = new Geometry({
        attributes: {
          aPosition: [
            -1,
            -1,
            // Bottom left corner
            3,
            -1,
            // Bottom right corner, extending beyond right edge
            -1,
            3
            // Top left corner, extending beyond top edge
          ]
        }
      });
      _GlBackBufferSystem = class _GlBackBufferSystem2 {
        constructor(renderer) {
          this.useBackBuffer = false;
          this._useBackBufferThisRender = false;
          this._renderer = renderer;
        }
        init(options = {}) {
          const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
          this.useBackBuffer = useBackBuffer;
          this._antialias = antialias;
          if (!this._renderer.context.supports.msaa) {
            warn("antialiasing, is not supported on when using the back buffer");
            this._antialias = false;
          }
          this._state = State.for2d();
          const bigTriangleProgram = new GlProgram({
            vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
            fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
            name: "big-triangle"
          });
          this._bigTriangleShader = new Shader({
            glProgram: bigTriangleProgram,
            resources: {
              uTexture: Texture.WHITE.source
            }
          });
        }
        /**
         * This is called before the RenderTargetSystem is started. This is where
         * we replace the target with the back buffer if required.
         * @param options - The options for this render.
         */
        renderStart(options) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
          this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
          if (this._useBackBufferThisRender) {
            const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
            this._targetTexture = renderTarget2.colorTexture;
            options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
          }
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const renderer = this._renderer;
          renderer.renderTarget.finishRenderPass();
          if (!this._useBackBufferThisRender)
            return;
          renderer.renderTarget.bind(this._targetTexture, false);
          this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
          renderer.encoder.draw({
            geometry: bigTriangleGeometry,
            shader: this._bigTriangleShader,
            state: this._state
          });
        }
        _getBackBufferTexture(targetSourceTexture) {
          this._backBufferTexture = this._backBufferTexture || new Texture({
            source: new TextureSource({
              width: targetSourceTexture.width,
              height: targetSourceTexture.height,
              resolution: targetSourceTexture._resolution,
              antialias: this._antialias
            })
          });
          this._backBufferTexture.source.resize(
            targetSourceTexture.width,
            targetSourceTexture.height,
            targetSourceTexture._resolution
          );
          return this._backBufferTexture;
        }
        /** destroys the back buffer */
        destroy() {
          if (this._backBufferTexture) {
            this._backBufferTexture.destroy();
            this._backBufferTexture = null;
          }
        }
      };
      _GlBackBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
      };
      _GlBackBufferSystem.defaultOptions = {
        /** if true will use the back buffer where required */
        useBackBuffer: false
      };
      GlBackBufferSystem = _GlBackBufferSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem;
  var init_GlColorMaskSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
      init_Extensions();
      GlColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.gl.colorMask(
            !!(colorMask & 8),
            !!(colorMask & 4),
            !!(colorMask & 2),
            !!(colorMask & 1)
          );
        }
      };
      GlColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem;
  var init_GlEncoderSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
      init_Extensions();
      GlEncoderSystem = class {
        constructor(renderer) {
          this.commandFinished = Promise.resolve();
          this._renderer = renderer;
        }
        setGeometry(geometry, shader) {
          this._renderer.geometry.bind(geometry, shader.glProgram);
        }
        finishRenderPass() {
        }
        draw(options) {
          const renderer = this._renderer;
          const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
          renderer.shader.bind(shader, skipSync);
          renderer.geometry.bind(geometry, renderer.shader._activeProgram);
          if (state) {
            renderer.state.set(state);
          }
          renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlEncoderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "encoder"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem;
  var init_GlStencilSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
      init_Extensions();
      init_GpuStencilModesToPixi();
      init_const3();
      GlStencilSystem = class {
        constructor(renderer) {
          this._stencilCache = {
            enabled: false,
            stencilReference: 0,
            stencilMode: STENCIL_MODES.NONE
          };
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(gl) {
          this._gl = gl;
          this._comparisonFuncMapping = {
            always: gl.ALWAYS,
            never: gl.NEVER,
            equal: gl.EQUAL,
            "not-equal": gl.NOTEQUAL,
            less: gl.LESS,
            "less-equal": gl.LEQUAL,
            greater: gl.GREATER,
            "greater-equal": gl.GEQUAL
          };
          this._stencilOpsMapping = {
            keep: gl.KEEP,
            zero: gl.ZERO,
            replace: gl.REPLACE,
            invert: gl.INVERT,
            "increment-clamp": gl.INCR,
            "decrement-clamp": gl.DECR,
            "increment-wrap": gl.INCR_WRAP,
            "decrement-wrap": gl.DECR_WRAP
          };
          this._stencilCache.enabled = false;
          this._stencilCache.stencilMode = STENCIL_MODES.NONE;
          this._stencilCache.stencilReference = 0;
        }
        onRenderTargetChange(renderTarget) {
          if (this._activeRenderTarget === renderTarget)
            return;
          this._activeRenderTarget = renderTarget;
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          const gl = this._gl;
          const mode = GpuStencilModesToPixi[stencilMode];
          const _stencilCache = this._stencilCache;
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          if (stencilMode === STENCIL_MODES.DISABLED) {
            if (this._stencilCache.enabled) {
              this._stencilCache.enabled = false;
              gl.disable(gl.STENCIL_TEST);
            }
            return;
          }
          if (!this._stencilCache.enabled) {
            this._stencilCache.enabled = true;
            gl.enable(gl.STENCIL_TEST);
          }
          if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
            _stencilCache.stencilMode = stencilMode;
            _stencilCache.stencilReference = stencilReference;
            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
          }
        }
      };
      GlStencilSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
  function createUboElementsSTD40(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let size = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i3 = 0; i3 < uboElements.length; i3++) {
      const uboElement = uboElements[i3];
      size = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.size = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_TO_STD40_SIZE;
  var init_createUboElementsSTD40 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
      "use strict";
      WGSL_TO_STD40_SIZE = {
        f32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
        // TODO - not essential for now but support these in the future
        // int:      4,
        // ivec2:    8,
        // ivec3:    12,
        // ivec4:    16,
        // uint:     4,
        // uvec2:    8,
        // uvec3:    12,
        // uvec4:    16,
        // bool:     4,
        // bvec2:    8,
        // bvec3:    12,
        // bvec4:    16,
        // mat2:     16 * 2,
        // mat3:     16 * 3,
        // mat4:     16 * 4,
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
    const elementSize = uboElement.data.value.length / uboElement.data.size;
    const remainder = (4 - elementSize % 4) % 4;
    return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
  }
  var init_generateArraySyncSTD40 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
      init_createUboElementsSTD40();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboStd40",
      generateArraySyncSTD40,
      uboSyncFunctionsSTD40
    );
  }
  var init_createUboSyncSTD40 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncSTD40();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
  var GlUboSystem;
  var init_GlUboSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsSTD40();
      init_createUboSyncSTD40();
      GlUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsSTD40,
            generateUboSync: createUboSyncFunctionSTD40
          });
        }
      };
      GlUboSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
  var GlRenderTarget;
  var init_GlRenderTarget = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
      "use strict";
      GlRenderTarget = class {
        constructor() {
          this.width = -1;
          this.height = -1;
          this.msaa = false;
          this.msaaRenderBuffer = [];
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
  var GlRenderTargetAdaptor;
  var init_GlRenderTargetAdaptor = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
      init_Rectangle();
      init_warn();
      init_CanvasSource();
      init_const7();
      init_GlRenderTarget();
      GlRenderTargetAdaptor = class {
        constructor() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
          renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderTargetSystem = this._renderTargetSystem;
          const renderer = this._renderer;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
          const gl = renderer.gl;
          this.finishRenderPass(sourceRenderSurfaceTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          renderer.texture.bind(destinationTexture, 0);
          gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            originDest.x,
            originDest.y,
            originSrc.x,
            originSrc.y,
            size.width,
            size.height
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const source7 = renderTarget.colorTexture;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          let viewPortY = viewport.y;
          if (renderTarget.isRoot) {
            viewPortY = source7.pixelHeight - viewport.height;
          }
          renderTarget.colorTextures.forEach((texture) => {
            this._renderer.texture.unbind(texture);
          });
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
          const viewPortCache = this._viewPortCache;
          if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
            viewPortCache.x = viewport.x;
            viewPortCache.y = viewPortY;
            viewPortCache.width = viewport.width;
            viewPortCache.height = viewport.height;
            gl.viewport(
              viewport.x,
              viewPortY,
              viewport.width,
              viewport.height
            );
          }
          if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
            this._initStencil(gpuRenderTarget);
          }
          this.clear(renderTarget, clear, clearColor);
        }
        finishRenderPass(renderTarget) {
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (!glRenderTarget.msaa)
            return;
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
          gl.blitFramebuffer(
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            gl.COLOR_BUFFER_BIT,
            gl.NEAREST
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        }
        initGpuRenderTarget(renderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const glRenderTarget = new GlRenderTarget();
          const colorTexture = renderTarget.colorTexture;
          if (colorTexture.resource === renderer.canvas) {
            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
            glRenderTarget.framebuffer = null;
            return glRenderTarget;
          }
          this._initColor(renderTarget, glRenderTarget);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return glRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          const gl = this._renderer.gl;
          if (gpuRenderTarget.framebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
            gpuRenderTarget.framebuffer = null;
          }
          if (gpuRenderTarget.resolveTargetFramebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
            gpuRenderTarget.resolveTargetFramebuffer = null;
          }
          if (gpuRenderTarget.depthStencilRenderBuffer) {
            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
            gpuRenderTarget.depthStencilRenderBuffer = null;
          }
          gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
            gl.deleteRenderbuffer(renderBuffer);
          });
          gpuRenderTarget.msaaRenderBuffer = null;
        }
        clear(_renderTarget, clear, clearColor) {
          if (!clear)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const gl = this._renderer.gl;
          if (clear & CLEAR.COLOR) {
            clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
            const clearColorCache = this._clearColorCache;
            const clearColorArray = clearColor;
            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
              clearColorCache[0] = clearColorArray[0];
              clearColorCache[1] = clearColorArray[1];
              clearColorCache[2] = clearColorArray[2];
              clearColorCache[3] = clearColorArray[3];
              gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
            }
          }
          gl.clear(clear);
        }
        resizeGpuRenderTarget(renderTarget) {
          if (renderTarget.isRoot)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          this._resizeColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil || renderTarget.depth) {
            this._resizeStencil(glRenderTarget);
          }
        }
        _initColor(renderTarget, glRenderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const resolveTargetFramebuffer = gl.createFramebuffer();
          glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
          glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
          glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            const source7 = colorTexture.source;
            if (source7.antialias) {
              if (renderer.context.supports.msaa) {
                glRenderTarget.msaa = true;
              } else {
                warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
              }
            }
            renderer.texture.bindSource(source7, 0);
            const glSource = renderer.texture.getGlSource(source7);
            const glTexture = glSource.texture;
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i3,
              3553,
              // texture.target,
              glTexture,
              0
            );
          });
          if (glRenderTarget.msaa) {
            const viewFramebuffer = gl.createFramebuffer();
            glRenderTarget.framebuffer = viewFramebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((_, i3) => {
              const msaaRenderBuffer = gl.createRenderbuffer();
              glRenderTarget.msaaRenderBuffer[i3] = msaaRenderBuffer;
            });
          } else {
            glRenderTarget.framebuffer = resolveTargetFramebuffer;
          }
          this._resizeColor(renderTarget, glRenderTarget);
        }
        _resizeColor(renderTarget, glRenderTarget) {
          const source7 = renderTarget.colorTexture.source;
          glRenderTarget.width = source7.pixelWidth;
          glRenderTarget.height = source7.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            if (i3 === 0)
              return;
            colorTexture.source.resize(source7.width, source7.height, source7._resolution);
          });
          if (glRenderTarget.msaa) {
            const renderer = this._renderer;
            const gl = renderer.gl;
            const viewFramebuffer = glRenderTarget.framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((colorTexture, i3) => {
              const source22 = colorTexture.source;
              renderer.texture.bindSource(source22, 0);
              const glSource = renderer.texture.getGlSource(source22);
              const glInternalFormat = glSource.internalFormat;
              const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i3];
              gl.bindRenderbuffer(
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
              gl.renderbufferStorageMultisample(
                gl.RENDERBUFFER,
                4,
                glInternalFormat,
                source22.pixelWidth,
                source22.pixelHeight
              );
              gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.COLOR_ATTACHMENT0 + i3,
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
            });
          }
        }
        _initStencil(glRenderTarget) {
          if (glRenderTarget.framebuffer === null)
            return;
          const gl = this._renderer.gl;
          const depthStencilRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            gl.DEPTH_STENCIL_ATTACHMENT,
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          this._resizeStencil(glRenderTarget);
        }
        _resizeStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            glRenderTarget.depthStencilRenderBuffer
          );
          if (glRenderTarget.msaa) {
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          } else {
            gl.renderbufferStorage(
              gl.RENDERBUFFER,
              this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              glRenderTarget.width,
              glRenderTarget.height
            );
          }
        }
        postrender(renderTarget) {
          if (!this._renderer.context.multiView)
            return;
          if (CanvasSource.test(renderTarget.colorTexture.resource)) {
            const contextCanvas = this._renderer.context.canvas;
            const canvasSource = renderTarget.colorTexture;
            canvasSource.context2D.drawImage(
              contextCanvas,
              0,
              canvasSource.pixelHeight - contextCanvas.height
            );
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem;
  var init_GlRenderTargetSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GlRenderTargetAdaptor();
      GlRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GlRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GlRenderTargetSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
  function generateShaderSyncCode(shader, shaderSystem) {
    const funcFragments = [];
    const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let addedTextreSystem = false;
    let blockIndex = 0;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    for (const i3 in shader.groups) {
      const group = shader.groups[i3];
      funcFragments.push(`
            resources = g[${i3}].resources;
        `);
      for (const j2 in group.resources) {
        const resource = group.resources[j2];
        if (resource instanceof UniformGroup) {
          if (resource.ubo) {
            funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            sS._uniformBindMap[${i3}[${j2}],
                            ${blockIndex++}
                        );
                    `);
          } else {
            funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
          }
        } else if (resource instanceof BufferResource) {
          funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        sS._uniformBindMap[${i3}[${j2}],
                        ${blockIndex++}
                    );
                `);
        } else if (resource instanceof TextureSource) {
          const uniformName = shader._uniformBindMap[i3][j2];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments.push(`
                        var tS = r.texture;
                        `);
            }
            shaderSystem._gl.uniform1i(uniformData.location, textureCount);
            funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
            textureCount++;
          }
        }
      }
    }
    const functionSource = [...headerFragments, ...funcFragments].join("\n");
    return new Function("r", "s", "sD", functionSource);
  }
  var init_GenerateShaderSyncCode = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_TextureSource();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  var IGLUniformData, GlProgramData;
  var init_GlProgramData = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
      "use strict";
      IGLUniformData = class {
      };
      GlProgramData = class {
        /**
         * Makes a new Pixi program.
         * @param program - webgl program
         * @param uniformData - uniforms
         */
        constructor(program, uniformData) {
          this.program = program;
          this.uniformData = uniformData;
          this.uniformGroups = {};
          this.uniformDirtyGroups = {};
          this.uniformBlockBindings = {};
        }
        /** Destroys this program. */
        destroy() {
          this.uniformData = null;
          this.uniformGroups = null;
          this.uniformDirtyGroups = null;
          this.uniformBlockBindings = null;
          this.program = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  var init_compileShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  function booleanArray(size) {
    const array = new Array(size);
    for (let i3 = 0; i3 < array.length; i3++) {
      array[i3] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i3 = 0; i3 < typeNames.length; ++i3) {
        const tn = typeNames[i3];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }
  var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
  var init_mapType = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
      "use strict";
      GL_TABLE = null;
      GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
      GLSL_TO_VERTEX_TYPES = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i3 = 0; i3 < totalAttributes; i3++) {
      const attribData = gl.getActiveAttrib(program, i3);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        // set further down..
        format,
        stride: getAttributeInfoFromFormat(format).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys = Object.keys(attributes);
    if (sortAttributes) {
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i3 = 0; i3 < keys.length; i3++) {
        attributes[keys[i3]].location = i3;
        gl.bindAttribLocation(program, i3, keys[i3]);
      }
      gl.linkProgram(program);
    } else {
      for (let i3 = 0; i3 < keys.length; i3++) {
        attributes[keys[i3]].location = gl.getAttribLocation(program, keys[i3]);
      }
    }
    return attributes;
  }
  var init_extractAttributesFromGlProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      init_mapType();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i3 = 0; i3 < totalUniformsBlocks; i3++) {
      const name = gl.getActiveUniformBlockName(program, i3);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size = gl.getActiveUniformBlockParameter(program, i3, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size
      };
    }
    return uniformBlocks;
  }
  var init_getUboData = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i3 = 0; i3 < totalUniforms; i3++) {
      const uniformData = gl.getActiveUniform(program, i3);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i3,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
      init_defaultValue();
      init_mapType();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  var init_logProgramError = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(
      webGLProgram,
      gl,
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
    );
    program._uniformData = getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i3 in program._uniformData) {
      const data = program._uniformData[i3];
      uniformData[i3] = {
        location: gl.getUniformLocation(webGLProgram, i3),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram3 = new GlProgramData(webGLProgram, uniformData);
    return glProgram3;
  }
  var init_generateProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
      init_warn();
      init_GlProgramData();
      init_compileShader();
      init_defaultValue();
      init_extractAttributesFromGlProgram();
      init_getUboData();
      init_getUniformData();
      init_logProgramError();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData, GlShaderSystem;
  var init_GlShaderSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
      init_Extensions();
      init_maxRecommendedTextures();
      init_GenerateShaderSyncCode();
      init_generateProgram();
      defaultSyncData = {
        textureCount: 0,
        blockIndex: 0
      };
      GlShaderSystem = class {
        constructor(renderer) {
          this._activeProgram = null;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._nextIndex = 0;
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
        }
        contextChange(gl) {
          this._gl = gl;
          this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._activeProgram = null;
          this.maxTextures = getMaxTexturesPerBatch();
        }
        /**
         * Changes the current shader to the one given in parameter.
         * @param shader - the new shader
         * @param skipSync - false if the shader should automatically sync its uniforms.
         * @returns the glProgram that belongs to the shader.
         */
        bind(shader, skipSync) {
          this._setProgram(shader.glProgram);
          if (skipSync)
            return;
          defaultSyncData.textureCount = 0;
          defaultSyncData.blockIndex = 0;
          let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
          if (!syncFunction) {
            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
          }
          syncFunction(this._renderer, shader, defaultSyncData);
        }
        /**
         * Updates the uniform group.
         * @param uniformGroup - the uniform group to update
         */
        updateUniformGroup(uniformGroup) {
          this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
        }
        /**
         * Binds a uniform block to the shader.
         * @param uniformGroup - the uniform group to bind
         * @param name - the name of the uniform block
         * @param index - the index of the uniform block
         */
        bindUniformBlock(uniformGroup, name, index = 0) {
          const bufferSystem = this._renderer.buffer;
          const programData = this._getProgramData(this._activeProgram);
          const isBufferResource = uniformGroup._bufferResource;
          if (isBufferResource) {
            this._renderer.ubo.updateUniformGroup(uniformGroup);
          }
          bufferSystem.updateBuffer(uniformGroup.buffer);
          let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
          if (boundIndex === void 0) {
            const nextIndex = this._nextIndex++ % this._maxBindings;
            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
            if (currentBoundUniformGroup) {
              this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
            }
            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
            if (isBufferResource) {
              bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
            } else {
              bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
            }
          }
          const gl = this._gl;
          const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
          if (programData.uniformBlockBindings[index] === boundIndex)
            return;
          programData.uniformBlockBindings[index] = boundIndex;
          gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
        }
        _setProgram(program) {
          if (this._activeProgram === program)
            return;
          this._activeProgram = program;
          const programData = this._getProgramData(program);
          this._gl.useProgram(programData.program);
        }
        /**
         * @param program - the program to get the data for
         * @internal
         * @private
         */
        _getProgramData(program) {
          return this._programDataHash[program._key] || this._createProgramData(program);
        }
        _createProgramData(program) {
          const key = program._key;
          this._programDataHash[key] = generateProgram(this._gl, program);
          return this._programDataHash[key];
        }
        destroy() {
          for (const key of Object.keys(this._programDataHash)) {
            const programData = this._programDataHash[key];
            programData.destroy();
            this._programDataHash[key] = null;
          }
          this._programDataHash = null;
          this._boundUniformsIdsToIndexHash = null;
        }
        /**
         * Creates a function that can be executed that will sync the shader as efficiently as possible.
         * Overridden by the unsafe eval package if you don't want eval used in your project.
         * @param shader - the shader to generate the sync function for
         * @param shaderSystem - the shader system to use
         * @returns - the generated sync function
         * @ignore
         */
        _generateShaderSync(shader, shaderSystem) {
          return generateShaderSyncCode(shader, shaderSystem);
        }
      };
      GlShaderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
  var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
  var init_generateUniformsSyncTypes = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
      "use strict";
      UNIFORM_TO_SINGLE_SETTERS = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
      };
      UNIFORM_TO_ARRAY_SETTERS = {
        f32: `gl.uniform1fv(location, v);`,
        "vec2<f32>": `gl.uniform2fv(location, v);`,
        "vec3<f32>": `gl.uniform3fv(location, v);`,
        "vec4<f32>": `gl.uniform4fv(location, v);`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
        i32: `gl.uniform1iv(location, v);`,
        "vec2<i32>": `gl.uniform2iv(location, v);`,
        "vec3<i32>": `gl.uniform3iv(location, v);`,
        "vec4<i32>": `gl.uniform4iv(location, v);`,
        u32: `gl.uniform1iv(location, v);`,
        "vec2<u32>": `gl.uniform2iv(location, v);`,
        "vec3<u32>": `gl.uniform3iv(location, v);`,
        "vec4<u32>": `gl.uniform4iv(location, v);`,
        bool: `gl.uniform1iv(location, v);`,
        "vec2<bool>": `gl.uniform2iv(location, v);`,
        "vec3<bool>": `gl.uniform3iv(location, v);`,
        "vec4<bool>": `gl.uniform4iv(location, v);`
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const i3 in group.uniforms) {
      if (!uniformData[i3]) {
        if (group.uniforms[i3] instanceof UniformGroup) {
          if (group.uniforms[i3].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i3}, "${i3}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i3});
                    `);
          }
        } else if (group.uniforms[i3] instanceof BufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i3}, "${i3}");
                    `);
        }
        continue;
      }
      const uniform = group.uniformStructures[i3];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const parser = uniformParsers[j2];
        if (uniform.type === parser.type && parser.test(uniform)) {
          funcFragments.push(`name = "${i3}";`, uniformParsers[j2].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform.type].replace("location", `ud["${i3}"].location`);
        funcFragments.push(`
            cu = ud["${i3}"];
            cv = cu.value;
            v = uv["${i3}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var init_generateUniformsSync = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_uniformParsers();
      init_generateUniformsSyncTypes();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem;
  var init_GlUniformGroupSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
      init_Extensions();
      init_generateUniformsSync();
      GlUniformGroupSystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._cache = {};
          this._uniformGroupSyncHash = {};
          this._renderer = renderer;
          this.gl = null;
          this._cache = {};
        }
        contextChange(gl) {
          this.gl = gl;
        }
        /**
         * Uploads the uniforms values to the currently bound shader.
         * @param group - the uniforms values that be applied to the current shader
         * @param program
         * @param syncData
         * @param syncData.textureCount
         */
        updateUniformGroup(group, program, syncData) {
          const programData = this._renderer.shader._getProgramData(program);
          if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
            programData.uniformDirtyGroups[group.uid] = group._dirtyId;
            const syncFunc = this._getUniformSyncFunction(group, program);
            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
          }
        }
        /**
         * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
         * @param group
         * @param program
         */
        _getUniformSyncFunction(group, program) {
          return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
        }
        _createUniformSyncFunction(group, program) {
          const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
          const id = this._getSignature(group, program._uniformData, "u");
          if (!this._cache[id]) {
            this._cache[id] = this._generateUniformsSync(group, program._uniformData);
          }
          uniformGroupSyncHash[program._key] = this._cache[id];
          return uniformGroupSyncHash[program._key];
        }
        _generateUniformsSync(group, uniformData) {
          return generateUniformsSync(group, uniformData);
        }
        /**
         * Takes a uniform group and data and generates a unique signature for them.
         * @param group - The uniform group to get signature of
         * @param group.uniforms
         * @param uniformData - Uniform information generated by the shader
         * @param preFix
         * @returns Unique signature of the uniform group
         */
        _getSignature(group, uniformData, preFix) {
          const uniforms = group.uniforms;
          const strings = [`${preFix}-`];
          for (const i3 in uniforms) {
            strings.push(i3);
            if (uniformData[i3]) {
              strings.push(uniformData[i3].type);
            }
          }
          return strings.join("-");
        }
        /** Destroys this System and removes all its textures. */
        destroy() {
          this._renderer = null;
          this._cache = null;
        }
      };
      GlUniformGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "uniformGroup"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
    if (isWebGl2) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
    } else {
      const ext = gl.getExtension("EXT_blend_minmax");
      if (ext) {
        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
      }
    }
    return blendMap;
  }
  var init_mapWebGLBlendModesToPixi = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
  var init_GlStateSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_mapWebGLBlendModesToPixi();
      BLEND2 = 0;
      OFFSET2 = 1;
      CULLING2 = 2;
      DEPTH_TEST2 = 3;
      WINDING2 = 4;
      DEPTH_MASK2 = 5;
      _GlStateSystem = class _GlStateSystem2 {
        constructor() {
          this.gl = null;
          this.stateId = 0;
          this.polygonOffset = 0;
          this.blendMode = "none";
          this._blendEq = false;
          this.map = [];
          this.map[BLEND2] = this.setBlend;
          this.map[OFFSET2] = this.setOffset;
          this.map[CULLING2] = this.setCullFace;
          this.map[DEPTH_TEST2] = this.setDepthTest;
          this.map[WINDING2] = this.setFrontFace;
          this.map[DEPTH_MASK2] = this.setDepthMask;
          this.checks = [];
          this.defaultState = State.for2d();
        }
        contextChange(gl) {
          this.gl = gl;
          this.blendModesMap = mapWebGLBlendModesToPixi(gl);
          this.reset();
        }
        /**
         * Sets the current state
         * @param {*} state - The state to set.
         */
        set(state) {
          state = state || this.defaultState;
          if (this.stateId !== state.data) {
            let diff = this.stateId ^ state.data;
            let i3 = 0;
            while (diff) {
              if (diff & 1) {
                this.map[i3].call(this, !!(state.data & 1 << i3));
              }
              diff = diff >> 1;
              i3++;
            }
            this.stateId = state.data;
          }
          for (let i3 = 0; i3 < this.checks.length; i3++) {
            this.checks[i3](this, state);
          }
        }
        /**
         * Sets the state, when previous state is unknown.
         * @param {*} state - The state to set
         */
        forceState(state) {
          state = state || this.defaultState;
          for (let i3 = 0; i3 < this.map.length; i3++) {
            this.map[i3].call(this, !!(state.data & 1 << i3));
          }
          for (let i3 = 0; i3 < this.checks.length; i3++) {
            this.checks[i3](this, state);
          }
          this.stateId = state.data;
        }
        /**
         * Sets whether to enable or disable blending.
         * @param value - Turn on or off WebGl blending.
         */
        setBlend(value) {
          this._updateCheck(_GlStateSystem2._checkBlendMode, value);
          this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        }
        /**
         * Sets whether to enable or disable polygon offset fill.
         * @param value - Turn on or off webgl polygon offset testing.
         */
        setOffset(value) {
          this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
          this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        /**
         * Sets whether to enable or disable depth test.
         * @param value - Turn on or off webgl depth testing.
         */
        setDepthTest(value) {
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        /**
         * Sets whether to enable or disable depth mask.
         * @param value - Turn on or off webgl depth mask.
         */
        setDepthMask(value) {
          this.gl.depthMask(value);
        }
        /**
         * Sets whether to enable or disable cull face.
         * @param {boolean} value - Turn on or off webgl cull face.
         */
        setCullFace(value) {
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        }
        /**
         * Sets the gl front face.
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */
        setFrontFace(value) {
          this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
        }
        /**
         * Sets the blend mode.
         * @param {number} value - The blend mode to set to.
         */
        setBlendMode(value) {
          if (!this.blendModesMap[value]) {
            value = "normal";
          }
          if (value === this.blendMode) {
            return;
          }
          this.blendMode = value;
          const mode = this.blendModesMap[value];
          const gl = this.gl;
          if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
          } else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
          if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
          } else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          }
        }
        /**
         * Sets the polygon offset.
         * @param {number} value - the polygon offset
         * @param {number} scale - the polygon offset scale
         */
        setPolygonOffset(value, scale) {
          this.gl.polygonOffset(value, scale);
        }
        // used
        /** Resets all the logic and disables the VAOs. */
        reset() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
          this.forceState(this.defaultState);
          this._blendEq = true;
          this.blendMode = "";
          this.setBlendMode("normal");
        }
        /**
         * Checks to see which updates should be checked based on which settings have been activated.
         *
         * For example, if blend is enabled then we should check the blend modes each time the state is changed
         * or if polygon fill is activated then we need to check if the polygon offset changes.
         * The idea is that we only check what we have too.
         * @param func - the checking function to add or remove
         * @param value - should the check function be added or removed.
         */
        _updateCheck(func, value) {
          const index = this.checks.indexOf(func);
          if (value && index === -1) {
            this.checks.push(func);
          } else if (!value && index !== -1) {
            this.checks.splice(index, 1);
          }
        }
        /**
         * A private little wrapper function that we call to check the blend mode.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkBlendMode(system, state) {
          system.setBlendMode(state.blendMode);
        }
        /**
         * A private little wrapper function that we call to check the polygon offset.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkPolygonOffset(system, state) {
          system.setPolygonOffset(1, state.polygonOffset);
        }
        /**
         * @ignore
         */
        destroy() {
          this.gl = null;
          this.checks.length = 0;
        }
      };
      _GlStateSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "state"
      };
      GlStateSystem = _GlStateSystem;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture;
  var init_GlTexture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
      init_const10();
      GlTexture = class {
        constructor(texture) {
          this.target = GL_TARGETS.TEXTURE_2D;
          this.texture = texture;
          this.width = -1;
          this.height = -1;
          this.type = GL_TYPES.UNSIGNED_BYTE;
          this.internalFormat = GL_FORMATS.RGBA;
          this.format = GL_FORMATS.RGBA;
          this.samplerType = 0;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  var glUploadBufferImageResource;
  var init_glUploadBufferImageResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
      "use strict";
      glUploadBufferImageResource = {
        id: "buffer",
        upload(source7, glTexture, gl) {
          if (glTexture.width === source7.width || glTexture.height === source7.height) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              source7.width,
              source7.height,
              glTexture.format,
              glTexture.type,
              source7.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              source7.width,
              source7.height,
              0,
              glTexture.format,
              glTexture.type,
              source7.resource
            );
          }
          glTexture.width = source7.width;
          glTexture.height = source7.height;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
  var compressedFormatMap, glUploadCompressedTextureResource;
  var init_glUploadCompressedTextureResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
      "use strict";
      compressedFormatMap = {
        "bc1-rgba-unorm": true,
        "bc1-rgba-unorm-srgb": true,
        "bc2-rgba-unorm": true,
        "bc2-rgba-unorm-srgb": true,
        "bc3-rgba-unorm": true,
        "bc3-rgba-unorm-srgb": true,
        "bc4-r-unorm": true,
        "bc4-r-snorm": true,
        "bc5-rg-unorm": true,
        "bc5-rg-snorm": true,
        "bc6h-rgb-ufloat": true,
        "bc6h-rgb-float": true,
        "bc7-rgba-unorm": true,
        "bc7-rgba-unorm-srgb": true,
        // ETC2 compressed formats usable if "texture-compression-etc2" is both
        // supported by the device/user agent and enabled in requestDevice.
        "etc2-rgb8unorm": true,
        "etc2-rgb8unorm-srgb": true,
        "etc2-rgb8a1unorm": true,
        "etc2-rgb8a1unorm-srgb": true,
        "etc2-rgba8unorm": true,
        "etc2-rgba8unorm-srgb": true,
        "eac-r11unorm": true,
        "eac-r11snorm": true,
        "eac-rg11unorm": true,
        "eac-rg11snorm": true,
        // ASTC compressed formats usable if "texture-compression-astc" is both
        // supported by the device/user agent and enabled in requestDevice.
        "astc-4x4-unorm": true,
        "astc-4x4-unorm-srgb": true,
        "astc-5x4-unorm": true,
        "astc-5x4-unorm-srgb": true,
        "astc-5x5-unorm": true,
        "astc-5x5-unorm-srgb": true,
        "astc-6x5-unorm": true,
        "astc-6x5-unorm-srgb": true,
        "astc-6x6-unorm": true,
        "astc-6x6-unorm-srgb": true,
        "astc-8x5-unorm": true,
        "astc-8x5-unorm-srgb": true,
        "astc-8x6-unorm": true,
        "astc-8x6-unorm-srgb": true,
        "astc-8x8-unorm": true,
        "astc-8x8-unorm-srgb": true,
        "astc-10x5-unorm": true,
        "astc-10x5-unorm-srgb": true,
        "astc-10x6-unorm": true,
        "astc-10x6-unorm-srgb": true,
        "astc-10x8-unorm": true,
        "astc-10x8-unorm-srgb": true,
        "astc-10x10-unorm": true,
        "astc-10x10-unorm-srgb": true,
        "astc-12x10-unorm": true,
        "astc-12x10-unorm-srgb": true,
        "astc-12x12-unorm": true,
        "astc-12x12-unorm-srgb": true
      };
      glUploadCompressedTextureResource = {
        id: "compressed",
        upload(source7, glTexture, gl) {
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
          let mipWidth = source7.pixelWidth;
          let mipHeight = source7.pixelHeight;
          const compressed = !!compressedFormatMap[source7.format];
          for (let i3 = 0; i3 < source7.resource.length; i3++) {
            const levelBuffer = source7.resource[i3];
            if (compressed) {
              gl.compressedTexImage2D(
                gl.TEXTURE_2D,
                i3,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                levelBuffer
              );
            } else {
              gl.texImage2D(
                gl.TEXTURE_2D,
                i3,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                glTexture.format,
                glTexture.type,
                levelBuffer
              );
            }
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  var glUploadImageResource;
  var init_glUploadImageResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
      "use strict";
      glUploadImageResource = {
        id: "image",
        upload(source7, glTexture, gl, webGLVersion) {
          const premultipliedAlpha = source7.alphaMode === "premultiply-alpha-on-upload";
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
          const glWidth = glTexture.width;
          const glHeight = glTexture.height;
          const textureWidth = source7.pixelWidth;
          const textureHeight = source7.pixelHeight;
          const resourceWidth = source7.resourceWidth;
          const resourceHeight = source7.resourceHeight;
          if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
            if (glWidth !== textureWidth || glHeight !== textureHeight) {
              gl.texImage2D(
                glTexture.target,
                0,
                glTexture.internalFormat,
                textureWidth,
                textureHeight,
                0,
                glTexture.format,
                glTexture.type,
                null
              );
            }
            if (webGLVersion === 2) {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                resourceWidth,
                resourceHeight,
                glTexture.format,
                glTexture.type,
                source7.resource
              );
            } else {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                glTexture.format,
                glTexture.type,
                source7.resource
              );
            }
          } else if (glWidth === textureWidth || glHeight === textureHeight) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source7.resource
            );
          } else if (webGLVersion === 2) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              source7.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              glTexture.format,
              glTexture.type,
              source7.resource
            );
          }
          glTexture.width = textureWidth;
          glTexture.height = textureHeight;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource;
  var init_glUploadVideoResource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
      init_glUploadImageResource();
      glUploadVideoResource = {
        id: "video",
        upload(source7, glTexture, gl, webGLVersion) {
          if (!source7.isValid) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              1,
              1,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
            return;
          }
          glUploadImageResource.upload(source7, glTexture, gl, webGLVersion);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
  var init_pixiToGlMaps = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
      "use strict";
      scaleModeToGlFilter = {
        linear: 9729,
        nearest: 9728
      };
      mipmapScaleModeToGlFilter = {
        linear: {
          linear: 9987,
          nearest: 9985
        },
        nearest: {
          linear: 9986,
          nearest: 9984
        }
      };
      wrapModeToGlAddress = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
      };
      compareModeToGlCompare = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }
  var init_applyStyleParams = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
      init_pixiToGlMaps();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  function mapFormatToGlFormat(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      // 16-bit formats
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      // 32-bit formats
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      // 64-bit formats
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      // 128-bit formats
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }
  var init_mapFormatToGlFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl, extensions2) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions2.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return {
      // 8-bit formats
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      // 16-bit formats
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      // 32-bit formats
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA,
      ...srgb,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      // 64-bit formats
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      // 128-bit formats
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
      // Compressed formats
      ...extensions2.s3tc ? {
        "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.rgtc ? {
        "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...extensions2.bptc ? {
        "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...extensions2.etc ? {
        "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
        // 'eac-r11snorm'
        "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
        // 'eac-rg11snorm'
      } : {},
      ...extensions2.astc ? {
        "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }
  var init_mapFormatToGlInternalFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  function mapFormatToGlType(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      // 16-bit formats
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      // 32-bit formats
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      // Packed 32-bit formats
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      // 64-bit formats
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      // 128-bit formats
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      // Depth/stencil formats
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  var init_mapFormatToGlType = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs
  function unpremultiplyAlpha2(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n2 = pixels.length;
    for (let i3 = 0; i3 < n2; i3 += 4) {
      const alpha = pixels[i3 + 3];
      if (alpha !== 0) {
        const a2 = 255.001 / alpha;
        pixels[i3] = pixels[i3] * a2 + 0.5;
        pixels[i3 + 1] = pixels[i3 + 1] * a2 + 0.5;
        pixels[i3 + 2] = pixels[i3 + 2] * a2 + 0.5;
      }
    }
  }
  var init_unpremultiplyAlpha = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var BYTES_PER_PIXEL, GlTextureSystem;
  var init_GlTextureSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Texture();
      init_GlTexture();
      init_glUploadBufferImageResource();
      init_glUploadCompressedTextureResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      BYTES_PER_PIXEL = 4;
      GlTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundTextures = [];
          this._activeTextureLocation = -1;
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: glUploadImageResource,
            buffer: glUploadBufferImageResource,
            video: glUploadVideoResource,
            compressed: glUploadCompressedTextureResource
          };
          this._useSeparateSamplers = false;
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_glTextures");
          this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
        }
        contextChange(gl) {
          this._gl = gl;
          if (!this._mapFormatToInternalFormat) {
            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
            this._mapFormatToType = mapFormatToGlType(gl);
            this._mapFormatToFormat = mapFormatToGlFormat(gl);
          }
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          for (let i3 = 0; i3 < 16; i3++) {
            this.bind(Texture.EMPTY, i3);
          }
        }
        initSource(source7) {
          this.bind(source7);
        }
        bind(texture, location = 0) {
          const source7 = texture.source;
          if (texture) {
            this.bindSource(source7, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(source7.style, location);
            }
          } else {
            this.bindSource(null, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(null, location);
            }
          }
        }
        bindSource(source7, location = 0) {
          const gl = this._gl;
          source7._touched = this._renderer.textureGC.count;
          if (this._boundTextures[location] !== source7) {
            this._boundTextures[location] = source7;
            this._activateLocation(location);
            source7 = source7 || Texture.EMPTY.source;
            const glTexture = this.getGlSource(source7);
            gl.bindTexture(glTexture.target, glTexture.texture);
          }
        }
        _bindSampler(style, location = 0) {
          const gl = this._gl;
          if (!style) {
            this._boundSamplers[location] = null;
            gl.bindSampler(location, null);
            return;
          }
          const sampler = this._getGlSampler(style);
          if (this._boundSamplers[location] !== sampler) {
            this._boundSamplers[location] = sampler;
            gl.bindSampler(location, sampler);
          }
        }
        unbind(texture) {
          const source7 = texture.source;
          const boundTextures = this._boundTextures;
          const gl = this._gl;
          for (let i3 = 0; i3 < boundTextures.length; i3++) {
            if (boundTextures[i3] === source7) {
              this._activateLocation(i3);
              const glTexture = this.getGlSource(source7);
              gl.bindTexture(glTexture.target, null);
              boundTextures[i3] = null;
            }
          }
        }
        _activateLocation(location) {
          if (this._activeTextureLocation !== location) {
            this._activeTextureLocation = location;
            this._gl.activeTexture(this._gl.TEXTURE0 + location);
          }
        }
        _initSource(source7) {
          const gl = this._gl;
          const glTexture = new GlTexture(gl.createTexture());
          glTexture.type = this._mapFormatToType[source7.format];
          glTexture.internalFormat = this._mapFormatToInternalFormat[source7.format];
          glTexture.format = this._mapFormatToFormat[source7.format];
          if (source7.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source7.isPowerOfTwo)) {
            const biggestDimension = Math.max(source7.width, source7.height);
            source7.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          this._glTextures[source7.uid] = glTexture;
          if (!this.managedTextures.includes(source7)) {
            source7.on("update", this.onSourceUpdate, this);
            source7.on("resize", this.onSourceUpdate, this);
            source7.on("styleChange", this.onStyleChange, this);
            source7.on("destroy", this.onSourceDestroy, this);
            source7.on("unload", this.onSourceUnload, this);
            source7.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source7);
          }
          this.onSourceUpdate(source7);
          this.updateStyle(source7, false);
          return glTexture;
        }
        onStyleChange(source7) {
          this.updateStyle(source7, false);
        }
        updateStyle(source7, firstCreation) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source7);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source7;
          applyStyleParams(
            source7.style,
            gl,
            source7.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "texParameteri",
            gl.TEXTURE_2D,
            // will force a clamp to edge if the texture is not a power of two
            !this._renderer.context.supports.nonPowOf2wrapping && !source7.isPowerOfTwo,
            firstCreation
          );
        }
        onSourceUnload(source7) {
          const glTexture = this._glTextures[source7.uid];
          if (!glTexture)
            return;
          this.unbind(source7);
          this._glTextures[source7.uid] = null;
          this._gl.deleteTexture(glTexture.texture);
        }
        onSourceUpdate(source7) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source7);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source7;
          if (this._uploads[source7.uploadMethodId]) {
            this._uploads[source7.uploadMethodId].upload(source7, glTexture, gl, this._renderer.context.webGLVersion);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source7.pixelWidth, source7.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          if (source7.autoGenerateMipmaps && source7.mipLevelCount > 1) {
            this.onUpdateMipmaps(source7, false);
          }
        }
        onUpdateMipmaps(source7, bind = true) {
          if (bind)
            this.bindSource(source7, 0);
          const glTexture = this.getGlSource(source7);
          this._gl.generateMipmap(glTexture.target);
        }
        onSourceDestroy(source7) {
          source7.off("destroy", this.onSourceDestroy, this);
          source7.off("update", this.onSourceUpdate, this);
          source7.off("resize", this.onSourceUpdate, this);
          source7.off("unload", this.onSourceUnload, this);
          source7.off("styleChange", this.onStyleChange, this);
          source7.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source7), 1);
          this.onSourceUnload(source7);
        }
        _initSampler(style) {
          const gl = this._gl;
          const glSampler = this._gl.createSampler();
          this._glSamplers[style._resourceId] = glSampler;
          applyStyleParams(
            style,
            gl,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "samplerParameteri",
            glSampler,
            false,
            true
          );
          return this._glSamplers[style._resourceId];
        }
        _getGlSampler(sampler) {
          return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGlSource(source7) {
          return this._glTextures[source7.uid] || this._initSource(source7);
        }
        generateCanvas(texture) {
          const { pixels, width, height } = this.getPixels(texture);
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (ctx) {
            const imageData = ctx.createImageData(width, height);
            imageData.data.set(pixels);
            ctx.putImageData(imageData, 0, 0);
          }
          return canvas;
        }
        getPixels(texture) {
          const resolution = texture.source.resolution;
          const frame = texture.frame;
          const width = Math.max(Math.round(frame.width * resolution), 1);
          const height = Math.max(Math.round(frame.height * resolution), 1);
          const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
          const renderer = this._renderer;
          const renderTarget = renderer.renderTarget.getRenderTarget(texture);
          const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
          const gl = renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
          gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width,
            height,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          );
          if (false) {
            unpremultiplyAlpha(pixels);
          }
          return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
        }
        destroy() {
          this.managedTextures.slice().forEach((source7) => this.onSourceDestroy(source7));
          this.managedTextures = null;
          this._renderer = null;
        }
      };
      GlTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var WebGLRenderer_exports = {};
  __export(WebGLRenderer_exports, {
    WebGLRenderer: () => WebGLRenderer
  });
  var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
  var init_WebGLRenderer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
      init_Extensions();
      init_GlGraphicsAdaptor();
      init_GlMeshAdaptor();
      init_GlBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_GlBufferSystem();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlStencilSystem();
      init_GlUboSystem();
      init_GlRenderTargetSystem();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_GlStateSystem();
      init_GlTextureSystem();
      DefaultWebGLSystems = [
        ...SharedSystems,
        GlUboSystem,
        GlBackBufferSystem,
        GlContextSystem,
        GlBufferSystem,
        GlTextureSystem,
        GlRenderTargetSystem,
        GlGeometrySystem,
        GlUniformGroupSystem,
        GlShaderSystem,
        GlEncoderSystem,
        GlStateSystem,
        GlStencilSystem,
        GlColorMaskSystem
      ];
      DefaultWebGLPipes = [...SharedRenderPipes];
      DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
      systems2 = [];
      renderPipes2 = [];
      renderPipeAdaptors2 = [];
      extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
      extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
      extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
      extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
      WebGLRenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgl",
            type: RendererType.WEBGL,
            systems: systems2,
            renderPipes: renderPipes2,
            renderPipeAdaptors: renderPipeAdaptors2
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
  async function autoDetectRenderer(options) {
    let preferredOrder = [];
    if (options.preference) {
      preferredOrder.push(options.preference);
      renderPriority.forEach((item) => {
        if (item !== options.preference) {
          preferredOrder.push(item);
        }
      });
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    let finalOptions = {};
    for (let i3 = 0; i3 < preferredOrder.length; i3++) {
      const rendererType = preferredOrder[i3];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
        RendererClass = WebGPURenderer2;
        finalOptions = { ...options, ...options.webgpu };
        break;
      } else if (rendererType === "webgl" && isWebGLSupported(
        options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      )) {
        const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
        RendererClass = WebGLRenderer2;
        finalOptions = { ...options, ...options.webgl };
        break;
      } else if (rendererType === "canvas") {
        finalOptions = { ...options };
        throw new Error("CanvasRenderer is not yet implemented");
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    if (!RendererClass) {
      throw new Error("No available renderer for the current environment");
    }
    const renderer = new RendererClass();
    await renderer.init(finalOptions);
    return renderer;
  }
  var renderPriority;
  var init_autoDetectRenderer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs"() {
      init_isWebGLSupported();
      init_isWebGPUSupported();
      init_AbstractRenderer();
      renderPriority = ["webgl", "webgpu", "canvas"];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/Application.mjs
  var _Application, Application;
  var init_Application = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/app/Application.mjs"() {
      init_Extensions();
      init_autoDetectRenderer();
      init_Container();
      init_globalHooks();
      init_deprecation();
      _Application = class _Application2 {
        /** @ignore */
        constructor(...args) {
          this.stage = new Container();
          if (args[0] !== void 0) {
            deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
          }
        }
        /**
         * @param options - The optional application and renderer parameters.
         */
        async init(options) {
          options = { ...options };
          this.renderer = await autoDetectRenderer(options);
          _Application2._plugins.forEach((plugin) => {
            plugin.init.call(this, options);
          });
        }
        /** Render the current stage. */
        render() {
          this.renderer.render({ container: this.stage });
        }
        /**
         * Reference to the renderer's canvas element.
         * @readonly
         * @member {HTMLCanvasElement}
         */
        get canvas() {
          return this.renderer.canvas;
        }
        /**
         * Reference to the renderer's canvas element.
         * @member {HTMLCanvasElement}
         * @deprecated since 8.0.0
         */
        get view() {
          deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
          return this.renderer.canvas;
        }
        /**
         * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
         * @readonly
         */
        get screen() {
          return this.renderer.screen;
        }
        /**
         * Destroys the application and all of its resources.
         * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
         * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
         * @param {object|boolean} [options=false] - The options for destroying the stage.
         * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
         * called as well. `options` will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
         * If options.children is set to true,
         * it should destroy the texture of the child sprite.
         * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
         *  If options.children is set to true,
         * it should destroy the texture source of the child sprite.
         * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
         * If options.children is set to true,
         * it should destroy the context of the child graphics.
         */
        destroy(rendererDestroyOptions = false, options = false) {
          const plugins = _Application2._plugins.slice(0);
          plugins.reverse();
          plugins.forEach((plugin) => {
            plugin.destroy.call(this);
          });
          this.stage.destroy(options);
          this.stage = null;
          this.renderer.destroy(rendererDestroyOptions);
          this.renderer = null;
        }
      };
      _Application._plugins = [];
      Application = _Application;
      extensions.handleByList(ExtensionType.Application, Application._plugins);
      extensions.add(ApplicationInitHook);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs
  var BitmapFont;
  var init_BitmapFont = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs"() {
      init_Rectangle();
      init_Texture();
      init_AbstractBitmapFont();
      init_BitmapFontManager();
      BitmapFont = class extends AbstractBitmapFont {
        constructor(options, url) {
          super();
          const { textures, data } = options;
          Object.keys(data.pages).forEach((key) => {
            const pageData = data.pages[parseInt(key, 10)];
            const texture = textures[pageData.id];
            this.pages.push({ texture });
          });
          Object.keys(data.chars).forEach((key) => {
            const charData = data.chars[key];
            const {
              frame: textureFrame,
              source: textureSource
            } = textures[charData.page];
            const frameReal = new Rectangle(
              charData.x + textureFrame.x,
              charData.y + textureFrame.y,
              charData.width,
              charData.height
            );
            const texture = new Texture({
              source: textureSource,
              frame: frameReal
            });
            this.chars[key] = {
              id: key.codePointAt(0),
              xOffset: charData.xOffset,
              yOffset: charData.yOffset,
              xAdvance: charData.xAdvance,
              kerning: charData.kerning ?? {},
              texture
            };
          });
          this.baseRenderedFontSize = data.fontSize;
          this.baseMeasurementFontSize = data.fontSize;
          this.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: data.fontSize
          };
          this.baseLineOffset = data.baseLineOffset;
          this.lineHeight = data.lineHeight;
          this.fontFamily = data.fontFamily;
          this.distanceField = data.distanceField ?? {
            type: "none",
            range: 0
          };
          this.url = url;
        }
        /** Destroys the BitmapFont object. */
        destroy() {
          super.destroy();
          for (let i3 = 0; i3 < this.pages.length; i3++) {
            const { texture } = this.pages[i3];
            texture.destroy(true);
          }
          this.pages = null;
        }
        /**
         * Generates a bitmap-font for the given style and character set
         * @param options - Setup options for font generation.
         * @returns Font generated by style options.
         * @example
         * import { BitmapFont, BitmapText } from 'pixi.js';
         *
         * BitmapFont.install('TitleFont', {
         *     fontFamily: 'Arial',
         *     fontSize: 12,
         *     strokeThickness: 2,
         *     fill: 'purple',
         * });
         *
         * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
         */
        static install(options) {
          BitmapFontManager.install(options);
        }
        /**
         * Uninstalls a bitmap font from the cache.
         * @param {string} name - The name of the bitmap font to uninstall.
         */
        static uninstall(name) {
          BitmapFontManager.uninstall(name);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
  var bitmapFontTextParser;
  var init_bitmapFontTextParser = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs"() {
      "use strict";
      bitmapFontTextParser = {
        test(data) {
          return typeof data === "string" && data.startsWith("info face=");
        },
        parse(txt) {
          const items = txt.match(/^[a-z]+\s+.+$/gm);
          const rawData = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
          };
          for (const i3 in items) {
            const name = items[i3].match(/^[a-z]+/gm)[0];
            const attributeList = items[i3].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
            const itemData = {};
            for (const i22 in attributeList) {
              const split = attributeList[i22].split("=");
              const key = split[0];
              const strValue = split[1].replace(/"/gm, "");
              const floatValue = parseFloat(strValue);
              const value = isNaN(floatValue) ? strValue : floatValue;
              itemData[key] = value;
            }
            rawData[name].push(itemData);
          }
          const font = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const [info] = rawData.info;
          const [common] = rawData.common;
          const [distanceField] = rawData.distanceField ?? [];
          if (distanceField) {
            font.distanceField = {
              range: parseInt(distanceField.distanceRange, 10),
              type: distanceField.fieldType
            };
          }
          font.fontSize = parseInt(info.size, 10);
          font.fontFamily = info.face;
          font.lineHeight = parseInt(common.lineHeight, 10);
          const page = rawData.page;
          for (let i3 = 0; i3 < page.length; i3++) {
            font.pages.push({
              id: parseInt(page[i3].id, 10) || 0,
              file: page[i3].file
            });
          }
          const map = {};
          font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
          const char = rawData.char;
          for (let i3 = 0; i3 < char.length; i3++) {
            const charNode = char[i3];
            const id = parseInt(charNode.id, 10);
            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
            if (letter === "space")
              letter = " ";
            map[id] = letter;
            font.chars[letter] = {
              id,
              // texture deets..
              page: parseInt(charNode.page, 10) || 0,
              x: parseInt(charNode.x, 10),
              y: parseInt(charNode.y, 10),
              width: parseInt(charNode.width, 10),
              height: parseInt(charNode.height, 10),
              xOffset: parseInt(charNode.xoffset, 10),
              yOffset: parseInt(charNode.yoffset, 10),
              xAdvance: parseInt(charNode.xadvance, 10),
              kerning: {}
            };
          }
          const kerning = rawData.kerning || [];
          for (let i3 = 0; i3 < kerning.length; i3++) {
            const first = parseInt(kerning[i3].first, 10);
            const second = parseInt(kerning[i3].second, 10);
            const amount = parseInt(kerning[i3].amount, 10);
            font.chars[map[second]].kerning[map[first]] = amount;
          }
          return font;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
  var bitmapFontXMLParser;
  var init_bitmapFontXMLParser = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs"() {
      "use strict";
      bitmapFontXMLParser = {
        test(data) {
          const xml = data;
          return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
        },
        parse(xml) {
          const data = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const info = xml.getElementsByTagName("info")[0];
          const common = xml.getElementsByTagName("common")[0];
          const distanceField = xml.getElementsByTagName("distanceField")[0];
          if (distanceField) {
            data.distanceField = {
              type: distanceField.getAttribute("fieldType"),
              range: parseInt(distanceField.getAttribute("distanceRange"), 10)
            };
          }
          const page = xml.getElementsByTagName("page");
          const char = xml.getElementsByTagName("char");
          const kerning = xml.getElementsByTagName("kerning");
          data.fontSize = parseInt(info.getAttribute("size"), 10);
          data.fontFamily = info.getAttribute("face");
          data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
          for (let i3 = 0; i3 < page.length; i3++) {
            data.pages.push({
              id: parseInt(page[i3].getAttribute("id"), 10) || 0,
              file: page[i3].getAttribute("file")
            });
          }
          const map = {};
          data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
          for (let i3 = 0; i3 < char.length; i3++) {
            const charNode = char[i3];
            const id = parseInt(charNode.getAttribute("id"), 10);
            let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
            if (letter === "space")
              letter = " ";
            map[id] = letter;
            data.chars[letter] = {
              id,
              // texture deets..
              page: parseInt(charNode.getAttribute("page"), 10) || 0,
              x: parseInt(charNode.getAttribute("x"), 10),
              y: parseInt(charNode.getAttribute("y"), 10),
              width: parseInt(charNode.getAttribute("width"), 10),
              height: parseInt(charNode.getAttribute("height"), 10),
              // render deets..
              xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
              yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
              // + baseLineOffset,
              xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
              kerning: {}
            };
          }
          for (let i3 = 0; i3 < kerning.length; i3++) {
            const first = parseInt(kerning[i3].getAttribute("first"), 10);
            const second = parseInt(kerning[i3].getAttribute("second"), 10);
            const amount = parseInt(kerning[i3].getAttribute("amount"), 10);
            data.chars[map[second]].kerning[map[first]] = amount;
          }
          return data;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  var bitmapFontXMLStringParser;
  var init_bitmapFontXMLStringParser = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs"() {
      init_adapter();
      init_bitmapFontXMLParser();
      bitmapFontXMLStringParser = {
        test(data) {
          if (typeof data === "string" && data.includes("<font>")) {
            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
          }
          return false;
        },
        parse(data) {
          return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  var validExtensions, bitmapFontCachePlugin, loadBitmapFont;
  var init_loadBitmapFont = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs"() {
      init_LoaderParser();
      init_copySearchParams();
      init_adapter();
      init_Extensions();
      init_path();
      init_BitmapFont();
      init_bitmapFontTextParser();
      init_bitmapFontXMLStringParser();
      validExtensions = [".xml", ".fnt"];
      bitmapFontCachePlugin = {
        extension: {
          type: ExtensionType.CacheParser,
          name: "cacheBitmapFont"
        },
        test: (asset) => asset instanceof BitmapFont,
        getCacheableAssets(keys, asset) {
          const out2 = {};
          keys.forEach((key) => {
            out2[key] = asset;
            out2[`${key}-bitmap`] = asset;
          });
          out2[`${asset.fontFamily}-bitmap`] = asset;
          return out2;
        }
      };
      loadBitmapFont = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        name: "loadBitmapFont",
        test(url) {
          return validExtensions.includes(path.extname(url).toLowerCase());
        },
        async testParse(data) {
          return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
        },
        async parse(asset, data, loader) {
          const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
          const { src } = data;
          const { pages } = bitmapFontData;
          const textureUrls = [];
          const textureOptions = bitmapFontData.distanceField ? {
            scaleMode: "linear",
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: false,
            resolution: 1
          } : {};
          for (let i3 = 0; i3 < pages.length; ++i3) {
            const pageFile = pages[i3].file;
            let imagePath = path.join(path.dirname(src), pageFile);
            imagePath = copySearchParams(imagePath, src);
            textureUrls.push({
              src: imagePath,
              data: textureOptions
            });
          }
          const loadedTextures = await loader.load(textureUrls);
          const textures = textureUrls.map((url) => loadedTextures[url.src]);
          const bitmapFont = new BitmapFont({
            data: bitmapFontData,
            textures
          }, src);
          return bitmapFont;
        },
        async load(url, _options) {
          const response = await DOMAdapter.get().fetch(url);
          return await response.text();
        },
        async unload(bitmapFont, _resolvedAsset, loader) {
          await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
          bitmapFont.destroy();
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
  var BackgroundLoader;
  var init_BackgroundLoader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/BackgroundLoader.mjs"() {
      "use strict";
      BackgroundLoader = class {
        /**
         * @param loader
         * @param verbose - should the loader log to the console
         */
        constructor(loader, verbose = false) {
          this._loader = loader;
          this._assetList = [];
          this._isLoading = false;
          this._maxConcurrent = 1;
          this.verbose = verbose;
        }
        /**
         * Adds an array of assets to load.
         * @param assetUrls - assets to load
         */
        add(assetUrls) {
          assetUrls.forEach((a2) => {
            this._assetList.push(a2);
          });
          if (this.verbose) {
            console.log("[BackgroundLoader] assets: ", this._assetList);
          }
          if (this._isActive && !this._isLoading) {
            void this._next();
          }
        }
        /**
         * Loads the next set of assets. Will try to load as many assets as it can at the same time.
         *
         * The max assets it will try to load at one time will be 4.
         */
        async _next() {
          if (this._assetList.length && this._isActive) {
            this._isLoading = true;
            const toLoad = [];
            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i3 = 0; i3 < toLoadAmount; i3++) {
              toLoad.push(this._assetList.pop());
            }
            await this._loader.load(toLoad);
            this._isLoading = false;
            void this._next();
          }
        }
        /**
         * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
         * @returns whether the class is active
         */
        get active() {
          return this._isActive;
        }
        set active(value) {
          if (this._isActive === value)
            return;
          this._isActive = value;
          if (value && !this._isLoading) {
            void this._next();
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
  var cacheTextureArray;
  var init_cacheTextureArray = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
      init_Extensions();
      init_Texture();
      cacheTextureArray = {
        extension: {
          type: ExtensionType.CacheParser,
          name: "cacheTextureArray"
        },
        test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
        getCacheableAssets: (keys, asset) => {
          const out2 = {};
          keys.forEach((key) => {
            asset.forEach((item, i3) => {
              out2[key + (i3 === 0 ? "" : i3 + 1)] = item;
            });
          });
          return out2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
  async function testImageFormat(imageData) {
    if ("Image" in globalThis) {
      return new Promise((resolve) => {
        const image = new Image();
        image.onload = () => {
          resolve(true);
        };
        image.onerror = () => {
          resolve(false);
        };
        image.src = imageData;
      });
    }
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const blob = await (await fetch(imageData)).blob();
        await createImageBitmap(blob);
      } catch (e2) {
        return false;
      }
      return true;
    }
    return false;
  }
  var init_testImageFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
  var detectAvif;
  var init_detectAvif = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs"() {
      init_Extensions();
      init_testImageFormat();
      detectAvif = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 1
        },
        test: async () => testImageFormat(
          // eslint-disable-next-line max-len
          "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
        ),
        add: async (formats) => [...formats, "avif"],
        remove: async (formats) => formats.filter((f2) => f2 !== "avif")
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
  var imageFormats, detectDefaults;
  var init_detectDefaults = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs"() {
      init_Extensions();
      imageFormats = ["png", "jpg", "jpeg"];
      detectDefaults = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: -1
        },
        test: () => Promise.resolve(true),
        add: async (formats) => [...formats, ...imageFormats],
        remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
  function testVideoFormat(mimeType) {
    if (inWorker) {
      return false;
    }
    const video = document.createElement("video");
    return video.canPlayType(mimeType) !== "";
  }
  var inWorker;
  var init_testVideoFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs"() {
      "use strict";
      inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
  var detectMp4;
  var init_detectMp4 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs"() {
      init_Extensions();
      init_testVideoFormat();
      detectMp4 = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/mp4"),
        add: async (formats) => [...formats, "mp4", "m4v"],
        remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
  var detectOgv;
  var init_detectOgv = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs"() {
      init_Extensions();
      init_testVideoFormat();
      detectOgv = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/ogg"),
        add: async (formats) => [...formats, "ogv"],
        remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
  var detectWebm;
  var init_detectWebm = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs"() {
      init_Extensions();
      init_testVideoFormat();
      detectWebm = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/webm"),
        add: async (formats) => [...formats, "webm"],
        remove: async (formats) => formats.filter((f2) => f2 !== "webm")
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
  var detectWebp;
  var init_detectWebp = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs"() {
      init_Extensions();
      init_testImageFormat();
      detectWebp = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testImageFormat(
          "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
        ),
        add: async (formats) => [...formats, "webp"],
        remove: async (formats) => formats.filter((f2) => f2 !== "webp")
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/Loader.mjs
  var Loader;
  var init_Loader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/Loader.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_isSingleItem();
      Loader = class {
        constructor() {
          this._parsers = [];
          this._parsersValidated = false;
          this.parsers = new Proxy(this._parsers, {
            set: (target, key, value) => {
              this._parsersValidated = false;
              target[key] = value;
              return true;
            }
          });
          this.promiseCache = {};
        }
        /** function used for testing */
        reset() {
          this._parsersValidated = false;
          this.promiseCache = {};
        }
        /**
         * Used internally to generate a promise for the asset to be loaded.
         * @param url - The URL to be loaded
         * @param data - any custom additional information relevant to the asset being loaded
         * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
         */
        _getLoadPromiseAndParser(url, data) {
          const result = {
            promise: null,
            parser: null
          };
          result.promise = (async () => {
            let asset = null;
            let parser = null;
            if (data.loadParser) {
              parser = this._parserHash[data.loadParser];
              if (!parser) {
                warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
              }
            }
            if (!parser) {
              for (let i3 = 0; i3 < this.parsers.length; i3++) {
                const parserX = this.parsers[i3];
                if (parserX.load && parserX.test?.(url, data, this)) {
                  parser = parserX;
                  break;
                }
              }
              if (!parser) {
                warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
                return null;
              }
            }
            asset = await parser.load(url, data, this);
            result.parser = parser;
            for (let i3 = 0; i3 < this.parsers.length; i3++) {
              const parser2 = this.parsers[i3];
              if (parser2.parse) {
                if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
                  asset = await parser2.parse(asset, data, this) || asset;
                  result.parser = parser2;
                }
              }
            }
            return asset;
          })();
          return result;
        }
        async load(assetsToLoadIn, onProgress) {
          if (!this._parsersValidated) {
            this._validateParsers();
          }
          let count2 = 0;
          const assets = {};
          const singleAsset = isSingleItem(assetsToLoadIn);
          const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
            alias: [item],
            src: item,
            data: {}
          }));
          const total = assetsToLoad.length;
          const promises = assetsToLoad.map(async (asset) => {
            const url = path.toAbsolute(asset.src);
            if (!assets[asset.src]) {
              try {
                if (!this.promiseCache[url]) {
                  this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
                }
                assets[asset.src] = await this.promiseCache[url].promise;
                if (onProgress)
                  onProgress(++count2 / total);
              } catch (e2) {
                delete this.promiseCache[url];
                delete assets[asset.src];
                throw new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
              }
            }
          });
          await Promise.all(promises);
          return singleAsset ? assets[assetsToLoad[0].src] : assets;
        }
        /**
         * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
         * The parser that created the asset, will be the one that unloads it.
         * @example
         * // Single asset:
         * const asset = await Loader.load('cool.png');
         *
         * await Loader.unload('cool.png');
         *
         * console.log(asset.destroyed); // true
         * @param assetsToUnloadIn - urls that you want to unload, or a single one!
         */
        async unload(assetsToUnloadIn) {
          const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
            alias: [item],
            src: item
          }));
          const promises = assetsToUnload.map(async (asset) => {
            const url = path.toAbsolute(asset.src);
            const loadPromise = this.promiseCache[url];
            if (loadPromise) {
              const loadedAsset = await loadPromise.promise;
              delete this.promiseCache[url];
              await loadPromise.parser?.unload?.(loadedAsset, asset, this);
            }
          });
          await Promise.all(promises);
        }
        /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
        _validateParsers() {
          this._parsersValidated = true;
          this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
            if (!parser.name) {
              warn(`[Assets] loadParser should have a name`);
            } else if (hash[parser.name]) {
              warn(`[Assets] loadParser name conflict "${parser.name}"`);
            }
            return { ...hash, [parser.name]: parser };
          }, {});
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
  function checkDataUrl(url, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url.startsWith(`data:${mimes}`);
  }
  var init_checkDataUrl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
  function checkExtension(url, extension) {
    const tempURL = url.split("?")[0];
    const ext = path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }
  var init_checkExtension = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs"() {
      init_path();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
  var validJSONExtension, validJSONMIME, loadJson;
  var init_loadJson = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs"() {
      init_adapter();
      init_Extensions();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validJSONExtension = ".json";
      validJSONMIME = "application/json";
      loadJson = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadJson",
        test(url) {
          return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
        },
        async load(url) {
          const response = await DOMAdapter.get().fetch(url);
          const json = await response.json();
          return json;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
  var validTXTExtension, validTXTMIME, loadTxt;
  var init_loadTxt = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs"() {
      init_adapter();
      init_Extensions();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validTXTExtension = ".txt";
      validTXTMIME = "text/plain";
      loadTxt = {
        name: "loadTxt",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low,
          name: "loadTxt"
        },
        test(url) {
          return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
        },
        async load(url) {
          const response = await DOMAdapter.get().fetch(url);
          const txt = await response.text();
          return txt;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
  function getFontFamilyName(url) {
    const ext = path.extname(url);
    const name = path.basename(url, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        valid = false;
        break;
      }
    }
    let fontFamilyName = nameTokens.join(" ");
    if (!valid) {
      fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
    }
    return fontFamilyName;
  }
  function encodeURIWhenNeeded(uri) {
    if (validURICharactersRegex.test(uri)) {
      return uri;
    }
    return encodeURI(uri);
  }
  var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, validURICharactersRegex, loadWebFont;
  var init_loadWebFont = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      init_path();
      init_Cache();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validWeights = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
      validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
      validFontMIMEs = [
        "font/ttf",
        "font/otf",
        "font/woff",
        "font/woff2"
      ];
      CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
      validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
      loadWebFont = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadWebFont",
        test(url) {
          return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
        },
        async load(url, options) {
          const fonts = DOMAdapter.get().getFontFaceSet();
          if (fonts) {
            const fontFaces = [];
            const name = options.data?.family ?? getFontFamilyName(url);
            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
            const data = options.data ?? {};
            for (let i3 = 0; i3 < weights.length; i3++) {
              const weight = weights[i3];
              const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
                ...data,
                weight
              });
              await font.load();
              fonts.add(font);
              fontFaces.push(font);
            }
            Cache.set(`${name}-and-url`, {
              url,
              fontFaces
            });
            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
          }
          warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
          return null;
        },
        unload(font) {
          (Array.isArray(font) ? font : [font]).forEach((t2) => {
            Cache.remove(t2.family);
            DOMAdapter.get().getFontFaceSet().delete(t2);
          });
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
  function getResolutionOfUrl(url, defaultValue2 = 1) {
    const resolution = Resolver.RETINA_PREFIX?.exec(url);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue2;
  }
  var init_getResolutionOfUrl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs"() {
      init_Resolver();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
  function createTexture(source7, loader, url) {
    source7.label = url;
    source7._sourceOrigin = url;
    const texture = new Texture({
      source: source7,
      label: url
    });
    const unload = () => {
      delete loader.promiseCache[url];
      if (Cache.has(url)) {
        Cache.remove(url);
      }
    };
    texture.source.once("destroy", () => {
      if (loader.promiseCache[url]) {
        warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
        unload();
      }
    });
    texture.once("destroy", () => {
      if (!source7.destroyed) {
        warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
        unload();
      }
    });
    return texture;
  }
  var init_createTexture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
      init_Texture();
      init_warn();
      init_Cache();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  async function loadAsTexture(url, asset, loader, crossOrigin2) {
    const response = await DOMAdapter.get().fetch(url);
    const blob = await response.blob();
    const blobUrl = URL.createObjectURL(blob);
    const image = new Image();
    image.src = blobUrl;
    image.crossOrigin = crossOrigin2;
    await image.decode();
    URL.revokeObjectURL(blobUrl);
    const canvas = document.createElement("canvas");
    const context4 = canvas.getContext("2d");
    const resolution = asset.data?.resolution || getResolutionOfUrl(url);
    const width = asset.data?.width ?? image.width;
    const height = asset.data?.height ?? image.height;
    canvas.width = width * resolution;
    canvas.height = height * resolution;
    context4.drawImage(image, 0, 0, width * resolution, height * resolution);
    const { parseAsGraphicsContext: _p, ...rest } = asset.data;
    const base = new ImageSource({
      resource: canvas,
      alphaMode: "premultiply-alpha-on-upload",
      resolution,
      ...rest
    });
    return createTexture(base, loader, url);
  }
  async function loadAsGraphics(url) {
    const response = await DOMAdapter.get().fetch(url);
    const svgSource = await response.text();
    const context4 = new GraphicsContext();
    context4.svg(svgSource);
    return context4;
  }
  var validSVGExtension, validSVGMIME, loadSvg;
  var init_loadSVG = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
      init_adapter();
      init_Extensions();
      init_ImageSource();
      init_GraphicsContext();
      init_getResolutionOfUrl();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      init_createTexture();
      validSVGExtension = ".svg";
      validSVGMIME = "image/svg+xml";
      loadSvg = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low,
          name: "loadSVG"
        },
        name: "loadSVG",
        config: {
          crossOrigin: "anonymous",
          parseAsGraphicsContext: false
        },
        test(url) {
          return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
        },
        async load(url, asset, loader) {
          if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {
            return loadAsGraphics(url);
          }
          return loadAsTexture(url, asset, loader, this.config.crossOrigin);
        },
        unload(asset) {
          asset.destroy(true);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs
  var WORKER_CODE, WORKER_URL, WorkerInstance;
  var init_checkImageBitmap_worker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs"() {
      WORKER_CODE = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
      WORKER_URL = null;
      WorkerInstance = class {
        constructor() {
          if (!WORKER_URL) {
            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }));
          }
          this.worker = new Worker(WORKER_URL);
        }
      };
      WorkerInstance.revokeObjectURL = function revokeObjectURL() {
        if (WORKER_URL) {
          URL.revokeObjectURL(WORKER_URL);
          WORKER_URL = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs
  var WORKER_CODE2, WORKER_URL2, WorkerInstance2;
  var init_loadImageBitmap_worker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs"() {
      WORKER_CODE2 = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
      WORKER_URL2 = null;
      WorkerInstance2 = class {
        constructor() {
          if (!WORKER_URL2) {
            WORKER_URL2 = URL.createObjectURL(new Blob([WORKER_CODE2], { type: "application/javascript" }));
          }
          this.worker = new Worker(WORKER_URL2);
        }
      };
      WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
        if (WORKER_URL2) {
          URL.revokeObjectURL(WORKER_URL2);
          WORKER_URL2 = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs
  var UUID, MAX_WORKERS, WorkerManagerClass, WorkerManager;
  var init_WorkerManager = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs"() {
      init_checkImageBitmap_worker();
      init_loadImageBitmap_worker();
      UUID = 0;
      WorkerManagerClass = class {
        constructor() {
          this._initialized = false;
          this._createdWorkers = 0;
          this._workerPool = [];
          this._queue = [];
          this._resolveHash = {};
        }
        isImageBitmapSupported() {
          if (this._isImageBitmapSupported !== void 0)
            return this._isImageBitmapSupported;
          this._isImageBitmapSupported = new Promise((resolve) => {
            const { worker } = new WorkerInstance();
            worker.addEventListener("message", (event) => {
              worker.terminate();
              WorkerInstance.revokeObjectURL();
              resolve(event.data);
            });
          });
          return this._isImageBitmapSupported;
        }
        loadImageBitmap(src, asset) {
          return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);
        }
        async _initWorkers() {
          if (this._initialized)
            return;
          this._initialized = true;
        }
        _getWorker() {
          if (MAX_WORKERS === void 0) {
            MAX_WORKERS = navigator.hardwareConcurrency || 4;
          }
          let worker = this._workerPool.pop();
          if (!worker && this._createdWorkers < MAX_WORKERS) {
            this._createdWorkers++;
            worker = new WorkerInstance2().worker;
            worker.addEventListener("message", (event) => {
              this._complete(event.data);
              this._returnWorker(event.target);
              this._next();
            });
          }
          return worker;
        }
        _returnWorker(worker) {
          this._workerPool.push(worker);
        }
        _complete(data) {
          if (data.error !== void 0) {
            this._resolveHash[data.uuid].reject(data.error);
          } else {
            this._resolveHash[data.uuid].resolve(data.data);
          }
          this._resolveHash[data.uuid] = null;
        }
        async _run(id, args) {
          await this._initWorkers();
          const promise2 = new Promise((resolve, reject) => {
            this._queue.push({ id, arguments: args, resolve, reject });
          });
          this._next();
          return promise2;
        }
        _next() {
          if (!this._queue.length)
            return;
          const worker = this._getWorker();
          if (!worker) {
            return;
          }
          const toDo = this._queue.pop();
          const id = toDo.id;
          this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
          worker.postMessage({
            data: toDo.arguments,
            uuid: UUID++,
            id
          });
        }
      };
      WorkerManager = new WorkerManagerClass();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
  async function loadImageBitmap(url, asset) {
    const response = await DOMAdapter.get().fetch(url);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
  }
  var validImageExtensions, validImageMIMEs, loadTextures;
  var init_loadTextures = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
      init_adapter();
      init_Extensions();
      init_ImageSource();
      init_getResolutionOfUrl();
      init_checkDataUrl();
      init_checkExtension();
      init_WorkerManager();
      init_LoaderParser();
      init_createTexture();
      validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
      validImageMIMEs = [
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif"
      ];
      loadTextures = {
        name: "loadTextures",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High,
          name: "loadTextures"
        },
        config: {
          preferWorkers: true,
          preferCreateImageBitmap: true,
          crossOrigin: "anonymous"
        },
        test(url) {
          return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
        },
        async load(url, asset, loader) {
          let src = null;
          if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
              src = await WorkerManager.loadImageBitmap(url, asset);
            } else {
              src = await loadImageBitmap(url, asset);
            }
          } else {
            src = await new Promise((resolve) => {
              src = new Image();
              src.crossOrigin = this.config.crossOrigin;
              src.src = url;
              if (src.complete) {
                resolve(src);
              } else {
                src.onload = () => {
                  resolve(src);
                };
              }
            });
          }
          const base = new ImageSource({
            resource: src,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: asset.data?.resolution || getResolutionOfUrl(url),
            ...asset.data
          });
          return createTexture(base, loader, url);
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
  function crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function preloadVideo(element) {
    return new Promise((resolve, reject) => {
      element.addEventListener("canplaythrough", loaded);
      element.addEventListener("error", error);
      element.load();
      function loaded() {
        cleanup();
        resolve();
      }
      function error(err) {
        cleanup();
        reject(err);
      }
      function cleanup() {
        element.removeEventListener("canplaythrough", loaded);
        element.removeEventListener("error", error);
      }
    });
  }
  function determineCrossOrigin(url, loc = globalThis.location) {
    if (url.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    const parsedUrl = new URL(url, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  var validVideoExtensions, validVideoMIMEs, loadVideoTextures;
  var init_loadVideoTextures = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
      init_Extensions();
      init_VideoSource();
      init_detectVideoAlphaMode();
      init_getResolutionOfUrl();
      init_checkDataUrl();
      init_checkExtension();
      init_createTexture();
      validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
      validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
      loadVideoTextures = {
        name: "loadVideo",
        extension: {
          type: ExtensionType.LoadParser,
          name: "loadVideo"
        },
        test(url) {
          const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
          const isValidExtension = checkExtension(url, validVideoExtensions);
          return isValidDataUrl || isValidExtension;
        },
        async load(url, asset, loader) {
          const options = {
            ...VideoSource.defaultOptions,
            resolution: asset.data?.resolution || getResolutionOfUrl(url),
            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
            ...asset.data
          };
          const videoElement = document.createElement("video");
          const attributeMap = {
            preload: options.autoLoad !== false ? "auto" : void 0,
            "webkit-playsinline": options.playsinline !== false ? "" : void 0,
            playsinline: options.playsinline !== false ? "" : void 0,
            muted: options.muted === true ? "" : void 0,
            loop: options.loop === true ? "" : void 0,
            autoplay: options.autoPlay !== false ? "" : void 0
          };
          Object.keys(attributeMap).forEach((key) => {
            const value = attributeMap[key];
            if (value !== void 0)
              videoElement.setAttribute(key, value);
          });
          if (options.muted === true) {
            videoElement.muted = true;
          }
          crossOrigin(videoElement, url, options.crossorigin);
          const sourceElement = document.createElement("source");
          let mime;
          if (url.startsWith("data:")) {
            mime = url.slice(5, url.indexOf(";"));
          } else if (!url.startsWith("blob:")) {
            const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
          }
          sourceElement.src = url;
          if (mime) {
            sourceElement.type = mime;
          }
          return new Promise((resolve) => {
            const onCanPlay = async () => {
              const base = new VideoSource({ ...options, resource: videoElement });
              videoElement.removeEventListener("canplay", onCanPlay);
              if (asset.data.preload) {
                await preloadVideo(videoElement);
              }
              resolve(createTexture(base, loader, url));
            };
            videoElement.addEventListener("canplay", onCanPlay);
            videoElement.appendChild(sourceElement);
          });
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
  var resolveTextureUrl;
  var init_resolveTextureUrl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
      init_Extensions();
      init_loadTextures();
      init_Resolver();
      resolveTextureUrl = {
        extension: {
          type: ExtensionType.ResolveParser,
          name: "resolveTexture"
        },
        test: loadTextures.test,
        parse: (value) => ({
          resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: value.split(".").pop(),
          src: value
        })
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  var resolveJsonUrl;
  var init_resolveJsonUrl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs"() {
      init_Extensions();
      init_Resolver();
      init_resolveTextureUrl();
      resolveJsonUrl = {
        extension: {
          type: ExtensionType.ResolveParser,
          priority: -2,
          name: "resolveJson"
        },
        test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(".json"),
        parse: resolveTextureUrl.parse
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/Assets.mjs
  var AssetsClass, Assets, assetKeyMap;
  var init_Assets = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/assets/Assets.mjs"() {
      init_Extensions();
      init_loadBitmapFont();
      init_warn();
      init_BackgroundLoader();
      init_Cache();
      init_cacheTextureArray();
      init_detectAvif();
      init_detectDefaults();
      init_detectMp4();
      init_detectOgv();
      init_detectWebm();
      init_detectWebp();
      init_Loader();
      init_loadJson();
      init_loadTxt();
      init_loadWebFont();
      init_loadSVG();
      init_loadTextures();
      init_loadVideoTextures();
      init_resolveJsonUrl();
      init_resolveTextureUrl();
      init_Resolver();
      init_convertToList();
      init_isSingleItem();
      AssetsClass = class {
        constructor() {
          this._detections = [];
          this._initialized = false;
          this.resolver = new Resolver();
          this.loader = new Loader();
          this.cache = Cache;
          this._backgroundLoader = new BackgroundLoader(this.loader);
          this._backgroundLoader.active = true;
          this.reset();
        }
        /**
         * Best practice is to call this function before any loading commences
         * Initiating is the best time to add any customization to the way things are loaded.
         *
         * you do not need to call this for the Assets class to work, only if you want to set any initial properties
         * @param options - options to initialize the Assets manager with
         */
        async init(options = {}) {
          if (this._initialized) {
            warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
            return;
          }
          this._initialized = true;
          if (options.defaultSearchParams) {
            this.resolver.setDefaultSearchParams(options.defaultSearchParams);
          }
          if (options.basePath) {
            this.resolver.basePath = options.basePath;
          }
          if (options.bundleIdentifier) {
            this.resolver.setBundleIdentifier(options.bundleIdentifier);
          }
          if (options.manifest) {
            let manifest = options.manifest;
            if (typeof manifest === "string") {
              manifest = await this.load(manifest);
            }
            this.resolver.addManifest(manifest);
          }
          const resolutionPref = options.texturePreference?.resolution ?? 1;
          const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
          const formats = await this._detectFormats({
            preferredFormats: options.texturePreference?.format,
            skipDetections: options.skipDetections,
            detections: this._detections
          });
          this.resolver.prefer({
            params: {
              format: formats,
              resolution
            }
          });
          if (options.preferences) {
            this.setPreferences(options.preferences);
          }
        }
        /**
         * Allows you to specify how to resolve any assets load requests.
         * There are a few ways to add things here as shown below:
         * @example
         * import { Assets } from 'pixi.js';
         *
         * // Simple
         * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
         * const bunny = await Assets.load('bunnyBooBoo');
         *
         * // Multiple keys:
         * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
         *
         * const bunny = await Assets.load('burger');
         * const bunny2 = await Assets.load('chicken');
         *
         * // passing options to to the object
         * Assets.add({
         *     alias: 'bunnyBooBooSmooth',
         *     src: 'bunny{png,webp}',
         *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
         * });
         *
         * // Multiple assets
         *
         * // The following all do the same thing:
         *
         * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
         *
         * Assets.add({
         *     alias: 'bunnyBooBoo',
         *     src: [
         *         'bunny.png',
         *         'bunny.webp',
         *    ],
         * });
         *
         * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
         * @param assets - the unresolved assets to add to the resolver
         */
        add(assets) {
          this.resolver.add(assets);
        }
        async load(urls, onProgress) {
          if (!this._initialized) {
            await this.init();
          }
          const singleAsset = isSingleItem(urls);
          const urlArray = convertToList(urls).map((url) => {
            if (typeof url !== "string") {
              const aliases = this.resolver.getAlias(url);
              if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
                this.add(url);
              }
              return Array.isArray(aliases) ? aliases[0] : aliases;
            }
            if (!this.resolver.hasKey(url))
              this.add({ alias: url, src: url });
            return url;
          });
          const resolveResults = this.resolver.resolve(urlArray);
          const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
          return singleAsset ? out2[urlArray[0]] : out2;
        }
        /**
         * This adds a bundle of assets in one go so that you can load them as a group.
         * For example you could add a bundle for each screen in you pixi app
         * @example
         * import { Assets } from 'pixi.js';
         *
         * Assets.addBundle('animals', [
         *  { alias: 'bunny', src: 'bunny.png' },
         *  { alias: 'chicken', src: 'chicken.png' },
         *  { alias: 'thumper', src: 'thumper.png' },
         * ]);
         * // or
         * Assets.addBundle('animals', {
         *     bunny: 'bunny.png',
         *     chicken: 'chicken.png',
         *     thumper: 'thumper.png',
         * });
         *
         * const assets = await Assets.loadBundle('animals');
         * @param bundleId - the id of the bundle to add
         * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
         */
        addBundle(bundleId, assets) {
          this.resolver.addBundle(bundleId, assets);
        }
        /**
         * Bundles are a way to load multiple assets at once.
         * If a manifest has been provided to the init function then you can load a bundle, or bundles.
         * you can also add bundles via `addBundle`
         * @example
         * import { Assets } from 'pixi.js';
         *
         * // Manifest Example
         * const manifest = {
         *     bundles: [
         *         {
         *             name: 'load-screen',
         *             assets: [
         *                 {
         *                     alias: 'background',
         *                     src: 'sunset.png',
         *                 },
         *                 {
         *                     alias: 'bar',
         *                     src: 'load-bar.{png,webp}',
         *                 },
         *             ],
         *         },
         *         {
         *             name: 'game-screen',
         *             assets: [
         *                 {
         *                     alias: 'character',
         *                     src: 'robot.png',
         *                 },
         *                 {
         *                     alias: 'enemy',
         *                     src: 'bad-guy.png',
         *                 },
         *             ],
         *         },
         *     ]
         * };
         *
         * await Assets.init({ manifest });
         *
         * // Load a bundle...
         * loadScreenAssets = await Assets.loadBundle('load-screen');
         * // Load another bundle...
         * gameScreenAssets = await Assets.loadBundle('game-screen');
         * @param bundleIds - the bundle id or ids to load
         * @param onProgress - Optional function that is called when progress on asset loading is made.
         * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
         * of the assets loaded. Do not use this function to detect when assets are complete and available,
         * instead use the Promise returned by this function.
         * @returns all the bundles assets or a hash of assets for each bundle specified
         */
        async loadBundle(bundleIds, onProgress) {
          if (!this._initialized) {
            await this.init();
          }
          let singleAsset = false;
          if (typeof bundleIds === "string") {
            singleAsset = true;
            bundleIds = [bundleIds];
          }
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          const out2 = {};
          const keys = Object.keys(resolveResults);
          let count2 = 0;
          let total = 0;
          const _onProgress = () => {
            onProgress?.(++count2 / total);
          };
          const promises = keys.map((bundleId) => {
            const resolveResult = resolveResults[bundleId];
            total += Object.keys(resolveResult).length;
            return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
              out2[bundleId] = resolveResult2;
            });
          });
          await Promise.all(promises);
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        /**
         * Initiate a background load of some assets. It will passively begin to load these assets in the background.
         * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
         *
         * An example of this might be that you would background load game assets after your initial load.
         * then when you got to actually load your game screen assets when a player goes to the game - the loading
         * would already have stared or may even be complete, saving you having to show an interim load bar.
         * @example
         * import { Assets } from 'pixi.js';
         *
         * Assets.backgroundLoad('bunny.png');
         *
         * // later on in your app...
         * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
         * @param urls - the url / urls you want to background load
         */
        async backgroundLoad(urls) {
          if (!this._initialized) {
            await this.init();
          }
          if (typeof urls === "string") {
            urls = [urls];
          }
          const resolveResults = this.resolver.resolve(urls);
          this._backgroundLoader.add(Object.values(resolveResults));
        }
        /**
         * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
         * this can only be used if the loader has been initiated with a manifest
         * @example
         * import { Assets } from 'pixi.js';
         *
         * await Assets.init({
         *     manifest: {
         *         bundles: [
         *             {
         *                 name: 'load-screen',
         *                 assets: [...],
         *             },
         *             ...
         *         ],
         *     },
         * });
         *
         * Assets.backgroundLoadBundle('load-screen');
         *
         * // Later on in your app...
         * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
         * @param bundleIds - the bundleId / bundleIds you want to background load
         */
        async backgroundLoadBundle(bundleIds) {
          if (!this._initialized) {
            await this.init();
          }
          if (typeof bundleIds === "string") {
            bundleIds = [bundleIds];
          }
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          Object.values(resolveResults).forEach((resolveResult) => {
            this._backgroundLoader.add(Object.values(resolveResult));
          });
        }
        /**
         * Only intended for development purposes.
         * This will wipe the resolver and caches.
         * You will need to reinitialize the Asset
         */
        reset() {
          this.resolver.reset();
          this.loader.reset();
          this.cache.reset();
          this._initialized = false;
        }
        get(keys) {
          if (typeof keys === "string") {
            return Cache.get(keys);
          }
          const assets = {};
          for (let i3 = 0; i3 < keys.length; i3++) {
            assets[i3] = Cache.get(keys[i3]);
          }
          return assets;
        }
        /**
         * helper function to map resolved assets back to loaded assets
         * @param resolveResults - the resolve results from the resolver
         * @param onProgress - the progress callback
         */
        async _mapLoadToResolve(resolveResults, onProgress) {
          const resolveArray = [...new Set(Object.values(resolveResults))];
          this._backgroundLoader.active = false;
          const loadedAssets = await this.loader.load(resolveArray, onProgress);
          this._backgroundLoader.active = true;
          const out2 = {};
          resolveArray.forEach((resolveResult) => {
            const asset = loadedAssets[resolveResult.src];
            const keys = [resolveResult.src];
            if (resolveResult.alias) {
              keys.push(...resolveResult.alias);
            }
            keys.forEach((key) => {
              out2[key] = asset;
            });
            Cache.set(keys, asset);
          });
          return out2;
        }
        /**
         * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
         * this will make sure to destroy any assets and release them from memory.
         * Once unloaded, you will need to load the asset again.
         *
         * Use this to help manage assets if you find that you have a large app and you want to free up memory.
         *
         * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
         * Pixi won't break but you will end up with missing assets. Not a good look for the user!
         * @example
         * import { Assets } from 'pixi.js';
         *
         * // Load a URL:
         * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
         *
         * await Assets.unload('http://some.url.com/image.png')
         *
         * // myImageTexture will be destroyed now.
         *
         * // Unload multiple assets:
         * const textures = await Assets.unload(['thumper', 'chicko']);
         * @param urls - the urls to unload
         */
        async unload(urls) {
          if (!this._initialized) {
            await this.init();
          }
          const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
          const resolveResults = this.resolver.resolve(urlArray);
          await this._unloadFromResolved(resolveResults);
        }
        /**
         * Bundles are a way to manage multiple assets at once.
         * this will unload all files in a bundle.
         *
         * once a bundle has been unloaded, you need to load it again to have access to the assets.
         * @example
         * import { Assets } from 'pixi.js';
         *
         * Assets.addBundle({
         *     'thumper': 'http://some.url.com/thumper.png',
         * })
         *
         * const assets = await Assets.loadBundle('thumper');
         *
         * // Now to unload...
         *
         * await Assets.unloadBundle('thumper');
         *
         * // All assets in the assets object will now have been destroyed and purged from the cache
         * @param bundleIds - the bundle id or ids to unload
         */
        async unloadBundle(bundleIds) {
          if (!this._initialized) {
            await this.init();
          }
          bundleIds = convertToList(bundleIds);
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
          await Promise.all(promises);
        }
        async _unloadFromResolved(resolveResult) {
          const resolveArray = Object.values(resolveResult);
          resolveArray.forEach((resolveResult2) => {
            Cache.remove(resolveResult2.src);
          });
          await this.loader.unload(resolveArray);
        }
        /**
         * Detects the supported formats for the browser, and returns an array of supported formats, respecting
         * the users preferred formats order.
         * @param options - the options to use when detecting formats
         * @param options.preferredFormats - the preferred formats to use
         * @param options.skipDetections - if we should skip the detections altogether
         * @param options.detections - the detections to use
         * @returns - the detected formats
         */
        async _detectFormats(options) {
          let formats = [];
          if (options.preferredFormats) {
            formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
          }
          for (const detection of options.detections) {
            if (options.skipDetections || await detection.test()) {
              formats = await detection.add(formats);
            } else if (!options.skipDetections) {
              formats = await detection.remove(formats);
            }
          }
          formats = formats.filter((format, index) => formats.indexOf(format) === index);
          return formats;
        }
        /** All the detection parsers currently added to the Assets class. */
        get detections() {
          return this._detections;
        }
        /**
         * General setter for preferences. This is a helper function to set preferences on all parsers.
         * @param preferences - the preferences to set
         */
        setPreferences(preferences) {
          this.loader.parsers.forEach((parser) => {
            if (!parser.config)
              return;
            Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
              parser.config[key] = preferences[key];
            });
          });
        }
      };
      Assets = new AssetsClass();
      extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
      extensions.add(
        cacheTextureArray,
        detectDefaults,
        detectAvif,
        detectWebp,
        detectMp4,
        detectOgv,
        detectWebm,
        loadJson,
        loadTxt,
        loadWebFont,
        loadSvg,
        loadTextures,
        loadVideoTextures,
        loadBitmapFont,
        bitmapFontCachePlugin,
        resolveTextureUrl,
        resolveJsonUrl
      );
      assetKeyMap = {
        loader: ExtensionType.LoadParser,
        resolver: ExtensionType.ResolveParser,
        cache: ExtensionType.CacheParser,
        detection: ExtensionType.DetectionParser
      };
      extensions.handle(ExtensionType.Asset, (extension) => {
        const ref = extension.ref;
        Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
          ref[key],
          // Allow the function to optionally define it's own
          // ExtensionMetadata, the use cases here is priority for LoaderParsers
          { extension: ref[key].extension ?? type }
        )));
      }, (extension) => {
        const ref = extension.ref;
        Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
      });
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs
  var detectBasis;
  var init_detectBasis = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs"() {
      init_Extensions();
      init_isWebGLSupported();
      init_isWebGPUSupported();
      detectBasis = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 3
        },
        test: async () => {
          if (await isWebGPUSupported())
            return true;
          if (isWebGLSupported())
            return true;
          return false;
        },
        add: async (formats) => [...formats, "basis"],
        remove: async (formats) => formats.filter((f2) => f2 !== "basis")
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs
  var CompressedSource;
  var init_CompressedSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs"() {
      init_TextureSource();
      CompressedSource = class extends TextureSource {
        constructor(options) {
          super(options);
          this.uploadMethodId = "compressed";
          this.resource = options.resource;
          this.mipLevelCount = this.resource.length;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs
  function getSupportedGlCompressedTextureFormats() {
    if (supportedGLCompressedTextureFormats)
      return supportedGLCompressedTextureFormats;
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return [];
    }
    supportedGLCompressedTextureFormats = [
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      // 'bc6h-rgb-ufloat'
      // 'bc6h-rgb-float'
      // 'bc7-rgba-unorm',
      // 'bc7-rgba-unorm-srgb',
      ...gl.getExtension("EXT_texture_compression_bptc") ? [
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      // 'bc1-rgba-unorm',
      // 'bc1-rgba-unorm-srgb',
      // 'bc4-r-unorm'
      // 'bc4-r-snorm'
      // 'bc5-rg-unorm'
      // 'bc5-rg-snorm'
      ...gl.getExtension("WEBGL_compressed_texture_s3tc") ? [
        "bc1-rgba-unorm",
        "bc2-rgba-unorm",
        "bc3-rgba-unorm"
      ] : [],
      ...gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? [
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm-srgb"
      ] : [],
      ...gl.getExtension("EXT_texture_compression_rgtc") ? [
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm"
      ] : [],
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      ...gl.getExtension("WEBGL_compressed_texture_etc") ? [
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "eac-r11unorm",
        "eac-rg11unorm"
      ] : [],
      // 'eac-r11snorm',
      // 'eac-rg11snorm',
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      ...gl.getExtension("WEBGL_compressed_texture_astc") ? [
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ];
    return supportedGLCompressedTextureFormats;
  }
  var supportedGLCompressedTextureFormats;
  var init_getSupportedGlCompressedTextureFormats = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs
  async function getSupportedGPUCompressedTextureFormats() {
    if (supportedGPUCompressedTextureFormats)
      return supportedGPUCompressedTextureFormats;
    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter();
    supportedGPUCompressedTextureFormats = [
      ...adapter.features.has("texture-compression-bc") ? [
        // BC compressed formats usable if "texture-compression-bc" is both
        // supported by the device/user agent and enabled in requestDevice.
        "bc1-rgba-unorm",
        "bc1-rgba-unorm-srgb",
        "bc2-rgba-unorm",
        "bc2-rgba-unorm-srgb",
        "bc3-rgba-unorm",
        "bc3-rgba-unorm-srgb",
        "bc4-r-unorm",
        "bc4-r-snorm",
        "bc5-rg-unorm",
        "bc5-rg-snorm",
        "bc6h-rgb-ufloat",
        "bc6h-rgb-float",
        "bc7-rgba-unorm",
        "bc7-rgba-unorm-srgb"
      ] : [],
      ...adapter.features.has("texture-compression-etc2") ? [
        // ETC2 compressed formats usable if "texture-compression-etc2" is both
        // supported by the device/user agent and enabled in requestDevice.
        "etc2-rgb8unorm",
        "etc2-rgb8unorm-srgb",
        "etc2-rgb8a1unorm",
        "etc2-rgb8a1unorm-srgb",
        "etc2-rgba8unorm",
        "etc2-rgba8unorm-srgb",
        "eac-r11unorm",
        "eac-r11snorm",
        "eac-rg11unorm",
        "eac-rg11snorm"
      ] : [],
      ...adapter.features.has("texture-compression-astc") ? [
        // ASTC compressed formats usable if "texture-compression-astc" is both
        // supported by the device/user agent and enabled in requestDevice.
        "astc-4x4-unorm",
        "astc-4x4-unorm-srgb",
        "astc-5x4-unorm",
        "astc-5x4-unorm-srgb",
        "astc-5x5-unorm",
        "astc-5x5-unorm-srgb",
        "astc-6x5-unorm",
        "astc-6x5-unorm-srgb",
        "astc-6x6-unorm",
        "astc-6x6-unorm-srgb",
        "astc-8x5-unorm",
        "astc-8x5-unorm-srgb",
        "astc-8x6-unorm",
        "astc-8x6-unorm-srgb",
        "astc-8x8-unorm",
        "astc-8x8-unorm-srgb",
        "astc-10x5-unorm",
        "astc-10x5-unorm-srgb",
        "astc-10x6-unorm",
        "astc-10x6-unorm-srgb",
        "astc-10x8-unorm",
        "astc-10x8-unorm-srgb",
        "astc-10x10-unorm",
        "astc-10x10-unorm-srgb",
        "astc-12x10-unorm",
        "astc-12x10-unorm-srgb",
        "astc-12x12-unorm",
        "astc-12x12-unorm-srgb"
      ] : []
    ];
    return supportedGPUCompressedTextureFormats;
  }
  var supportedGPUCompressedTextureFormats;
  var init_getSupportedGPUCompressedTextureFormats = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs"() {
      init_adapter();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs
  async function getSupportedCompressedTextureFormats() {
    if (supportedCompressedTextureFormats !== void 0)
      return supportedCompressedTextureFormats;
    supportedCompressedTextureFormats = await (async () => {
      const _isWebGPUSupported2 = await isWebGPUSupported();
      const _isWebGLSupported2 = isWebGLSupported();
      if (_isWebGPUSupported2 && _isWebGLSupported2) {
        const gpuTextureFormats = await getSupportedGPUCompressedTextureFormats();
        const glTextureFormats = getSupportedGlCompressedTextureFormats();
        return gpuTextureFormats.filter((format) => glTextureFormats.includes(format));
      } else if (_isWebGPUSupported2) {
        return await getSupportedGPUCompressedTextureFormats();
      } else if (_isWebGLSupported2) {
        return getSupportedGlCompressedTextureFormats();
      }
      return [];
    })();
    return supportedCompressedTextureFormats;
  }
  var supportedCompressedTextureFormats;
  var init_getSupportedCompressedTextureFormats = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs"() {
      init_isWebGLSupported();
      init_isWebGPUSupported();
      init_getSupportedGlCompressedTextureFormats();
      init_getSupportedGPUCompressedTextureFormats();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs
  async function getSupportedTextureFormats() {
    if (supportedTextureFormats !== void 0)
      return supportedTextureFormats;
    const compressedTextureFormats = await getSupportedCompressedTextureFormats();
    supportedTextureFormats = [
      ...nonCompressedFormats,
      ...compressedTextureFormats
    ];
    return supportedTextureFormats;
  }
  var nonCompressedFormats, supportedTextureFormats;
  var init_getSupportedTextureFormats = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs"() {
      init_getSupportedCompressedTextureFormats();
      nonCompressedFormats = [
        // 8-bit formats
        "r8unorm",
        "r8snorm",
        "r8uint",
        "r8sint",
        // 16-bit formats
        "r16uint",
        "r16sint",
        "r16float",
        "rg8unorm",
        "rg8snorm",
        "rg8uint",
        "rg8sint",
        // 32-bit formats
        "r32uint",
        "r32sint",
        "r32float",
        "rg16uint",
        "rg16sint",
        "rg16float",
        "rgba8unorm",
        "rgba8unorm-srgb",
        "rgba8snorm",
        "rgba8uint",
        "rgba8sint",
        "bgra8unorm",
        "bgra8unorm-srgb",
        // Packed 32-bit formats
        "rgb9e5ufloat",
        "rgb10a2unorm",
        "rg11b10ufloat",
        // 64-bit formats
        "rg32uint",
        "rg32sint",
        "rg32float",
        "rgba16uint",
        "rgba16sint",
        "rgba16float",
        // 128-bit formats
        "rgba32uint",
        "rgba32sint",
        "rgba32float",
        // Depth/stencil formats
        "stencil8",
        "depth16unorm",
        "depth24plus",
        "depth24plus-stencil8",
        "depth32float",
        // "depth32float-stencil8" feature
        "depth32float-stencil8"
      ];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/basis.worker.mjs
  var WORKER_CODE3, WORKER_URL3, WorkerInstance3;
  var init_basis_worker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/basis.worker.mjs"() {
      WORKER_CODE3 = '(function () {\n    \'use strict\';\n\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\n      const images = basisTexture.getNumImages();\n      const levels = basisTexture.getNumLevels(0);\n      const success = basisTexture.startTranscoding();\n      if (!success) {\n        throw new Error("startTranscoding failed");\n      }\n      const levelBuffers = [];\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n          const levelBuffer = new Uint8Array(transcodeSize);\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n          if (!success2) {\n            throw new Error("transcodeImage failed");\n          }\n          levelBuffers.push(levelBuffer);\n        }\n      }\n      return levelBuffers;\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      "bc3-rgba-unorm": 3,\n      // cTFBC3_RGBA\n      "bc7-rgba-unorm": 6,\n      // cTFBC7_RGBA,\n      "etc2-rgba8unorm": 1,\n      // cTFETC2_RGBA,\n      "astc-4x4-unorm": 10,\n      // cTFASTC_4x4_RGBA,\n      // Uncompressed\n      rgba8unorm: 13,\n      // cTFRGBA32,\n      rgba4unorm: 16\n      // cTFRGBA4444,\n    };\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: "basis/basis_transcoder.js",\n      wasmUrl: "basis/basis_transcoder.wasm"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let basisPromise;\n    async function getBasis() {\n      if (!basisPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        basisPromise = new Promise((resolve) => {\n          BASIS({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((module) => {\n            module.initializeBasis();\n            resolve(module.BasisFile);\n          });\n        });\n      }\n      return basisPromise;\n    }\n    async function fetchBasisTexture(url, BasisTexture) {\n      const basisResponse = await fetch(url);\n      if (basisResponse.ok) {\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\n      }\n      throw new Error(`Failed to load Basis texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const BasisTexture = await getBasis();\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\n      return {\n        width: basisTexture.getImageWidth(0, 0),\n        height: basisTexture.getImageHeight(0, 0),\n        format: basisTranscodedTextureFormat,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getBasis();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type](message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n';
      WORKER_URL3 = null;
      WorkerInstance3 = class {
        constructor() {
          if (!WORKER_URL3) {
            WORKER_URL3 = URL.createObjectURL(new Blob([WORKER_CODE3], { type: "application/javascript" }));
          }
          this.worker = new Worker(WORKER_URL3);
        }
      };
      WorkerInstance3.revokeObjectURL = function revokeObjectURL3() {
        if (WORKER_URL3) {
          URL.revokeObjectURL(WORKER_URL3);
          WORKER_URL3 = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs
  function setBasisTranscoderPath(config3) {
    Object.assign(basisTranscoderUrls, config3);
  }
  var basisTranscoderUrls;
  var init_setBasisTranscoderPath = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs"() {
      "use strict";
      basisTranscoderUrls = {
        jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
        wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs
  function getBasisWorker(supportedTextures) {
    if (!basisWorker) {
      basisWorker = new WorkerInstance3().worker;
      basisWorker.onmessage = (messageEvent) => {
        const { success, url, textureOptions } = messageEvent.data;
        if (!success) {
          console.warn("Failed to load Basis texture", url);
        }
        urlHash[url](textureOptions);
      };
      basisWorker.postMessage({
        type: "init",
        jsUrl: basisTranscoderUrls.jsUrl,
        wasmUrl: basisTranscoderUrls.wasmUrl,
        supportedTextures
      });
    }
    return basisWorker;
  }
  function loadBasisOnWorker(url, supportedTextures) {
    const ktxWorker2 = getBasisWorker(supportedTextures);
    return new Promise((resolve) => {
      urlHash[url] = resolve;
      ktxWorker2.postMessage({ type: "load", url });
    });
  }
  var basisWorker, urlHash;
  var init_loadBasisOnWorker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs"() {
      init_basis_worker();
      init_setBasisTranscoderPath();
      urlHash = {};
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs
  var loadBasis;
  var init_loadBasis = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs"() {
      init_LoaderParser();
      init_createTexture();
      init_checkExtension();
      init_Extensions();
      init_CompressedSource();
      init_getSupportedTextureFormats();
      init_loadBasisOnWorker();
      loadBasis = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High,
          name: "loadBasis"
        },
        name: "loadBasis",
        test(url) {
          return checkExtension(url, [".basis"]);
        },
        async load(url, _asset, loader) {
          const supportedTextures = await getSupportedTextureFormats();
          const textureOptions = await loadBasisOnWorker(url, supportedTextures);
          const compressedTextureSource = new CompressedSource(textureOptions);
          return createTexture(compressedTextureSource, loader, url);
        },
        unload(texture) {
          if (Array.isArray(texture)) {
            texture.forEach((t2) => t2.destroy(true));
          } else {
            texture.destroy(true);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs
  function createLevelBuffers(basisTexture, basisTranscoderFormat) {
    const images = basisTexture.getNumImages();
    const levels = basisTexture.getNumLevels(0);
    const success = basisTexture.startTranscoding();
    if (!success) {
      throw new Error("startTranscoding failed");
    }
    const levelBuffers = [];
    for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
      for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
        const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
        const levelBuffer = new Uint8Array(transcodeSize);
        const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
        if (!success2) {
          throw new Error("transcodeImage failed");
        }
        levelBuffers.push(levelBuffer);
      }
    }
    return levelBuffers;
  }
  var init_createLevelBuffers = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs
  function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
    const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
  }
  var gpuFormatToBasisTranscoderFormatMap;
  var init_gpuFormatToBasisTranscoderFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs"() {
      "use strict";
      gpuFormatToBasisTranscoderFormatMap = {
        "bc3-rgba-unorm": 3,
        // cTFBC3_RGBA
        "bc7-rgba-unorm": 6,
        // cTFBC7_RGBA,
        "etc2-rgba8unorm": 1,
        // cTFETC2_RGBA,
        "astc-4x4-unorm": 10,
        // cTFASTC_4x4_RGBA,
        // Uncompressed
        rgba8unorm: 13,
        // cTFRGBA32,
        rgba4unorm: 16
        // cTFRGBA4444,
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/dds/const.mjs
  function fourCCToInt32(value) {
    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
  }
  var DDS_HEADER_FIELDS, DDS_DX10_FIELDS, DXGI_FORMAT, D3D10_RESOURCE_DIMENSION, D3DFMT, FOURCC_TO_TEXTURE_FORMAT, DXGI_TO_TEXTURE_FORMAT, DDS, TEXTURE_FORMAT_BLOCK_SIZE;
  var init_const11 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/dds/const.mjs"() {
      "use strict";
      DDS_HEADER_FIELDS = {
        MAGIC: 0,
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19,
        PF_FLAGS: 20,
        FOURCC: 21,
        RGB_BITCOUNT: 22,
        R_BIT_MASK: 23,
        G_BIT_MASK: 24,
        B_BIT_MASK: 25,
        A_BIT_MASK: 26
      };
      DDS_DX10_FIELDS = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
      };
      DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
        DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
        return DXGI_FORMAT2;
      })(DXGI_FORMAT || {});
      D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
        D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
        D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
        D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
        return D3D10_RESOURCE_DIMENSION2;
      })(D3D10_RESOURCE_DIMENSION || {});
      D3DFMT = ((D3DFMT2) => {
        D3DFMT2[D3DFMT2["UNKNOWN"] = 0] = "UNKNOWN";
        D3DFMT2[D3DFMT2["R8G8B8"] = 20] = "R8G8B8";
        D3DFMT2[D3DFMT2["A8R8G8B8"] = 21] = "A8R8G8B8";
        D3DFMT2[D3DFMT2["X8R8G8B8"] = 22] = "X8R8G8B8";
        D3DFMT2[D3DFMT2["R5G6B5"] = 23] = "R5G6B5";
        D3DFMT2[D3DFMT2["X1R5G5B5"] = 24] = "X1R5G5B5";
        D3DFMT2[D3DFMT2["A1R5G5B5"] = 25] = "A1R5G5B5";
        D3DFMT2[D3DFMT2["A4R4G4B4"] = 26] = "A4R4G4B4";
        D3DFMT2[D3DFMT2["R3G3B2"] = 27] = "R3G3B2";
        D3DFMT2[D3DFMT2["A8"] = 28] = "A8";
        D3DFMT2[D3DFMT2["A8R3G3B2"] = 29] = "A8R3G3B2";
        D3DFMT2[D3DFMT2["X4R4G4B4"] = 30] = "X4R4G4B4";
        D3DFMT2[D3DFMT2["A2B10G10R10"] = 31] = "A2B10G10R10";
        D3DFMT2[D3DFMT2["A8B8G8R8"] = 32] = "A8B8G8R8";
        D3DFMT2[D3DFMT2["X8B8G8R8"] = 33] = "X8B8G8R8";
        D3DFMT2[D3DFMT2["G16R16"] = 34] = "G16R16";
        D3DFMT2[D3DFMT2["A2R10G10B10"] = 35] = "A2R10G10B10";
        D3DFMT2[D3DFMT2["A16B16G16R16"] = 36] = "A16B16G16R16";
        D3DFMT2[D3DFMT2["A8P8"] = 40] = "A8P8";
        D3DFMT2[D3DFMT2["P8"] = 41] = "P8";
        D3DFMT2[D3DFMT2["L8"] = 50] = "L8";
        D3DFMT2[D3DFMT2["A8L8"] = 51] = "A8L8";
        D3DFMT2[D3DFMT2["A4L4"] = 52] = "A4L4";
        D3DFMT2[D3DFMT2["V8U8"] = 60] = "V8U8";
        D3DFMT2[D3DFMT2["L6V5U5"] = 61] = "L6V5U5";
        D3DFMT2[D3DFMT2["X8L8V8U8"] = 62] = "X8L8V8U8";
        D3DFMT2[D3DFMT2["Q8W8V8U8"] = 63] = "Q8W8V8U8";
        D3DFMT2[D3DFMT2["V16U16"] = 64] = "V16U16";
        D3DFMT2[D3DFMT2["A2W10V10U10"] = 67] = "A2W10V10U10";
        D3DFMT2[D3DFMT2["Q16W16V16U16"] = 110] = "Q16W16V16U16";
        D3DFMT2[D3DFMT2["R16F"] = 111] = "R16F";
        D3DFMT2[D3DFMT2["G16R16F"] = 112] = "G16R16F";
        D3DFMT2[D3DFMT2["A16B16G16R16F"] = 113] = "A16B16G16R16F";
        D3DFMT2[D3DFMT2["R32F"] = 114] = "R32F";
        D3DFMT2[D3DFMT2["G32R32F"] = 115] = "G32R32F";
        D3DFMT2[D3DFMT2["A32B32G32R32F"] = 116] = "A32B32G32R32F";
        D3DFMT2[D3DFMT2["UYVY"] = fourCCToInt32("UYVY")] = "UYVY";
        D3DFMT2[D3DFMT2["R8G8_B8G8"] = fourCCToInt32("RGBG")] = "R8G8_B8G8";
        D3DFMT2[D3DFMT2["YUY2"] = fourCCToInt32("YUY2")] = "YUY2";
        D3DFMT2[D3DFMT2["D3DFMT_G8R8_G8B8"] = fourCCToInt32("GRGB")] = "D3DFMT_G8R8_G8B8";
        D3DFMT2[D3DFMT2["DXT1"] = fourCCToInt32("DXT1")] = "DXT1";
        D3DFMT2[D3DFMT2["DXT2"] = fourCCToInt32("DXT2")] = "DXT2";
        D3DFMT2[D3DFMT2["DXT3"] = fourCCToInt32("DXT3")] = "DXT3";
        D3DFMT2[D3DFMT2["DXT4"] = fourCCToInt32("DXT4")] = "DXT4";
        D3DFMT2[D3DFMT2["DXT5"] = fourCCToInt32("DXT5")] = "DXT5";
        D3DFMT2[D3DFMT2["ATI1"] = fourCCToInt32("ATI1")] = "ATI1";
        D3DFMT2[D3DFMT2["AT1N"] = fourCCToInt32("AT1N")] = "AT1N";
        D3DFMT2[D3DFMT2["ATI2"] = fourCCToInt32("ATI2")] = "ATI2";
        D3DFMT2[D3DFMT2["AT2N"] = fourCCToInt32("AT2N")] = "AT2N";
        D3DFMT2[D3DFMT2["BC4U"] = fourCCToInt32("BC4U")] = "BC4U";
        D3DFMT2[D3DFMT2["BC4S"] = fourCCToInt32("BC4S")] = "BC4S";
        D3DFMT2[D3DFMT2["BC5U"] = fourCCToInt32("BC5U")] = "BC5U";
        D3DFMT2[D3DFMT2["BC5S"] = fourCCToInt32("BC5S")] = "BC5S";
        D3DFMT2[D3DFMT2["DX10"] = fourCCToInt32("DX10")] = "DX10";
        return D3DFMT2;
      })(D3DFMT || {});
      FOURCC_TO_TEXTURE_FORMAT = {
        [D3DFMT.DXT1]: "bc1-rgba-unorm",
        [D3DFMT.DXT2]: "bc2-rgba-unorm",
        [D3DFMT.DXT3]: "bc2-rgba-unorm",
        [D3DFMT.DXT4]: "bc3-rgba-unorm",
        [D3DFMT.DXT5]: "bc3-rgba-unorm",
        [D3DFMT.ATI1]: "bc4-r-unorm",
        [D3DFMT.BC4U]: "bc4-r-unorm",
        [D3DFMT.BC4S]: "bc4-r-snorm",
        [D3DFMT.ATI2]: "bc5-rg-unorm",
        [D3DFMT.BC5U]: "bc5-rg-unorm",
        [D3DFMT.BC5S]: "bc5-rg-snorm",
        [
          36
          /* A16B16G16R16 */
        ]: "rgba16uint",
        [
          110
          /* Q16W16V16U16 */
        ]: "rgba16sint",
        [
          111
          /* R16F */
        ]: "r16float",
        [
          112
          /* G16R16F */
        ]: "rg16float",
        [
          113
          /* A16B16G16R16F */
        ]: "rgba16float",
        [
          114
          /* R32F */
        ]: "r32float",
        [
          115
          /* G32R32F */
        ]: "rg32float",
        [
          116
          /* A32B32G32R32F */
        ]: "rgba32float"
      };
      DXGI_TO_TEXTURE_FORMAT = {
        [
          70
          /* DXGI_FORMAT_BC1_TYPELESS */
        ]: "bc1-rgba-unorm",
        [
          71
          /* DXGI_FORMAT_BC1_UNORM */
        ]: "bc1-rgba-unorm",
        [
          72
          /* DXGI_FORMAT_BC1_UNORM_SRGB */
        ]: "bc1-rgba-unorm-srgb",
        [
          73
          /* DXGI_FORMAT_BC2_TYPELESS */
        ]: "bc2-rgba-unorm",
        [
          74
          /* DXGI_FORMAT_BC2_UNORM */
        ]: "bc2-rgba-unorm",
        [
          75
          /* DXGI_FORMAT_BC2_UNORM_SRGB */
        ]: "bc2-rgba-unorm-srgb",
        [
          76
          /* DXGI_FORMAT_BC3_TYPELESS */
        ]: "bc3-rgba-unorm",
        [
          77
          /* DXGI_FORMAT_BC3_UNORM */
        ]: "bc3-rgba-unorm",
        [
          78
          /* DXGI_FORMAT_BC3_UNORM_SRGB */
        ]: "bc3-rgba-unorm-srgb",
        [
          79
          /* DXGI_FORMAT_BC4_TYPELESS */
        ]: "bc4-r-unorm",
        [
          80
          /* DXGI_FORMAT_BC4_UNORM */
        ]: "bc4-r-unorm",
        [
          81
          /* DXGI_FORMAT_BC4_SNORM */
        ]: "bc4-r-snorm",
        [
          82
          /* DXGI_FORMAT_BC5_TYPELESS */
        ]: "bc5-rg-unorm",
        [
          83
          /* DXGI_FORMAT_BC5_UNORM */
        ]: "bc5-rg-unorm",
        [
          84
          /* DXGI_FORMAT_BC5_SNORM */
        ]: "bc5-rg-snorm",
        [
          94
          /* DXGI_FORMAT_BC6H_TYPELESS */
        ]: "bc6h-rgb-ufloat",
        [
          95
          /* DXGI_FORMAT_BC6H_UF16 */
        ]: "bc6h-rgb-ufloat",
        [
          96
          /* DXGI_FORMAT_BC6H_SF16 */
        ]: "bc6h-rgb-float",
        [
          97
          /* DXGI_FORMAT_BC7_TYPELESS */
        ]: "bc7-rgba-unorm",
        [
          98
          /* DXGI_FORMAT_BC7_UNORM */
        ]: "bc7-rgba-unorm",
        [
          99
          /* DXGI_FORMAT_BC7_UNORM_SRGB */
        ]: "bc7-rgba-unorm-srgb",
        [
          28
          /* DXGI_FORMAT_R8G8B8A8_UNORM */
        ]: "rgba8unorm",
        [
          29
          /* DXGI_FORMAT_R8G8B8A8_UNORM_SRGB */
        ]: "rgba8unorm-srgb",
        [
          87
          /* DXGI_FORMAT_B8G8R8A8_UNORM */
        ]: "bgra8unorm",
        [
          91
          /* DXGI_FORMAT_B8G8R8A8_UNORM_SRGB */
        ]: "bgra8unorm-srgb",
        [
          41
          /* DXGI_FORMAT_R32_FLOAT */
        ]: "r32float",
        [
          49
          /* DXGI_FORMAT_R8G8_UNORM */
        ]: "rg8unorm",
        [
          56
          /* DXGI_FORMAT_R16_UNORM */
        ]: "r16uint",
        [
          61
          /* DXGI_FORMAT_R8_UNORM */
        ]: "r8unorm",
        [
          24
          /* DXGI_FORMAT_R10G10B10A2_UNORM */
        ]: "rgb10a2unorm",
        [
          11
          /* DXGI_FORMAT_R16G16B16A16_UNORM */
        ]: "rgba16uint",
        [
          13
          /* DXGI_FORMAT_R16G16B16A16_SNORM */
        ]: "rgba16sint",
        [
          10
          /* DXGI_FORMAT_R16G16B16A16_FLOAT */
        ]: "rgba16float",
        [
          54
          /* DXGI_FORMAT_R16_FLOAT */
        ]: "r16float",
        [
          34
          /* DXGI_FORMAT_R16G16_FLOAT */
        ]: "rg16float",
        [
          16
          /* DXGI_FORMAT_R32G32_FLOAT */
        ]: "rg32float",
        [
          2
          /* DXGI_FORMAT_R32G32B32A32_FLOAT */
        ]: "rgba32float"
      };
      DDS = {
        MAGIC_VALUE: 542327876,
        MAGIC_SIZE: 4,
        HEADER_SIZE: 124,
        HEADER_DX10_SIZE: 20,
        PIXEL_FORMAT_FLAGS: {
          // PIXEL_FORMAT flags
          // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h
          // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat
          ALPHAPIXELS: 1,
          ALPHA: 2,
          FOURCC: 4,
          RGB: 64,
          RGBA: 65,
          YUV: 512,
          LUMINANCE: 131072,
          LUMINANCEA: 131073
        },
        RESOURCE_MISC_TEXTURECUBE: 4,
        HEADER_FIELDS: DDS_HEADER_FIELDS,
        HEADER_DX10_FIELDS: DDS_DX10_FIELDS,
        DXGI_FORMAT,
        D3D10_RESOURCE_DIMENSION,
        D3DFMT
      };
      TEXTURE_FORMAT_BLOCK_SIZE = {
        "bc1-rgba-unorm": 8,
        "bc1-rgba-unorm-srgb": 8,
        "bc2-rgba-unorm": 16,
        "bc2-rgba-unorm-srgb": 16,
        "bc3-rgba-unorm": 16,
        "bc3-rgba-unorm-srgb": 16,
        "bc4-r-unorm": 8,
        "bc4-r-snorm": 8,
        "bc5-rg-unorm": 16,
        "bc5-rg-snorm": 16,
        "bc6h-rgb-ufloat": 16,
        "bc6h-rgb-float": 16,
        "bc7-rgba-unorm": 16,
        "bc7-rgba-unorm-srgb": 16
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs
  function parseDDS(arrayBuffer, supportedFormats) {
    const {
      format,
      fourCC,
      width,
      height,
      dataOffset,
      mipmapCount
    } = parseDDSHeader(arrayBuffer);
    if (!supportedFormats.includes(format)) {
      throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);
    }
    if (mipmapCount <= 1) {
      return {
        format,
        width,
        height,
        resource: [new Uint8Array(arrayBuffer, dataOffset)],
        alphaMode: "no-premultiply-alpha"
      };
    }
    const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);
    const textureOptions = {
      format,
      width,
      height,
      resource: levelBuffers,
      alphaMode: "no-premultiply-alpha"
    };
    return textureOptions;
  }
  function getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer) {
    const levelBuffers = [];
    const blockBytes = TEXTURE_FORMAT_BLOCK_SIZE[format];
    let mipWidth = width;
    let mipHeight = height;
    let offset = dataOffset;
    for (let level = 0; level < mipmapCount; ++level) {
      const byteLength = blockBytes ? Math.max(4, mipWidth) / 4 * Math.max(4, mipHeight) / 4 * blockBytes : mipWidth * mipHeight * 4;
      const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);
      levelBuffers.push(levelBuffer);
      offset += byteLength;
      mipWidth = Math.max(mipWidth >> 1, 1);
      mipHeight = Math.max(mipHeight >> 1, 1);
    }
    return levelBuffers;
  }
  function parseDDSHeader(buffer) {
    const header = new Uint32Array(buffer, 0, DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    if (header[DDS.HEADER_FIELDS.MAGIC] !== DDS.MAGIC_VALUE) {
      throw new Error("Invalid magic number in DDS header");
    }
    const height = header[DDS.HEADER_FIELDS.HEIGHT];
    const width = header[DDS.HEADER_FIELDS.WIDTH];
    const mipmapCount = Math.max(1, header[DDS.HEADER_FIELDS.MIPMAP_COUNT]);
    const flags = header[DDS.HEADER_FIELDS.PF_FLAGS];
    const fourCC = header[DDS.HEADER_FIELDS.FOURCC];
    const format = getTextureFormat(header, flags, fourCC, buffer);
    const dataOffset = DDS.MAGIC_SIZE + DDS.HEADER_SIZE + (fourCC === DDS.D3DFMT.DX10 ? DDS.HEADER_DX10_SIZE : 0);
    return {
      format,
      fourCC,
      width,
      height,
      dataOffset,
      mipmapCount
    };
  }
  function getTextureFormat(header, flags, fourCC, buffer) {
    if (flags & DDS.PIXEL_FORMAT_FLAGS.FOURCC) {
      if (fourCC === DDS.D3DFMT.DX10) {
        const dx10Header = new Uint32Array(
          buffer,
          DDS.MAGIC_SIZE + DDS.HEADER_SIZE,
          // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER
          DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
        );
        const miscFlag = dx10Header[DDS.HEADER_DX10_FIELDS.MISC_FLAG];
        if (miscFlag === DDS.RESOURCE_MISC_TEXTURECUBE) {
          throw new Error("DDSParser does not support cubemap textures");
        }
        const resourceDimension = dx10Header[DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];
        if (resourceDimension === DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
          throw new Error("DDSParser does not supported 3D texture data");
        }
        const dxgiFormat = dx10Header[DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];
        if (dxgiFormat in DXGI_TO_TEXTURE_FORMAT) {
          return DXGI_TO_TEXTURE_FORMAT[dxgiFormat];
        }
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
      }
      if (fourCC in FOURCC_TO_TEXTURE_FORMAT) {
        return FOURCC_TO_TEXTURE_FORMAT[fourCC];
      }
      throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.RGB || flags & DDS.PIXEL_FORMAT_FLAGS.RGBA) {
      return getUncompressedTextureFormat(header);
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.YUV) {
      throw new Error("DDSParser does not supported YUV uncompressed texture data.");
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA) {
      throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
    }
    if (flags & DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {
      throw new Error("DDSParser does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }
  function getUncompressedTextureFormat(header) {
    const bitCount = header[DDS.HEADER_FIELDS.RGB_BITCOUNT];
    const rBitMask = header[DDS.HEADER_FIELDS.R_BIT_MASK];
    const gBitMask = header[DDS.HEADER_FIELDS.G_BIT_MASK];
    const bBitMask = header[DDS.HEADER_FIELDS.B_BIT_MASK];
    const aBitMask = header[DDS.HEADER_FIELDS.A_BIT_MASK];
    switch (bitCount) {
      case 32:
        if (rBitMask === 255 && gBitMask === 65280 && bBitMask === 16711680 && aBitMask === 4278190080) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
        }
        if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 4278190080) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
        }
        if (rBitMask === 1072693248 && gBitMask === 1047552 && bBitMask === 1023 && aBitMask === 3221225472) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
        }
        if (rBitMask === 65535 && gBitMask === 4294901760 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
        }
        if (rBitMask === 4294967295 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
        }
        break;
      case 24:
        if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 32768) {
        }
        break;
      case 16:
        if (rBitMask === 31744 && gBitMask === 992 && bBitMask === 31 && aBitMask === 32768) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
        }
        if (rBitMask === 63488 && gBitMask === 2016 && bBitMask === 31 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
        }
        if (rBitMask === 3840 && gBitMask === 240 && bBitMask === 15 && aBitMask === 61440) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
        }
        if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 65280) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
        }
        if (rBitMask === 65535 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
        }
        break;
      case 8:
        if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
          return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
        }
        break;
    }
    throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);
  }
  var init_parseDDS = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs"() {
      init_const11();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs
  var loadDDS;
  var init_loadDDS = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs"() {
      init_LoaderParser();
      init_createTexture();
      init_checkExtension();
      init_Extensions();
      init_CompressedSource();
      init_getSupportedTextureFormats();
      init_parseDDS();
      loadDDS = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High,
          name: "loadDDS"
        },
        name: "loadDDS",
        test(url) {
          return checkExtension(url, [".dds"]);
        },
        async load(url, _asset, loader) {
          const supportedTextures = await getSupportedTextureFormats();
          const ddsResponse = await fetch(url);
          const ddsArrayBuffer = await ddsResponse.arrayBuffer();
          const textureOptions = parseDDS(ddsArrayBuffer, supportedTextures);
          const compressedTextureSource = new CompressedSource(textureOptions);
          return createTexture(compressedTextureSource, loader, url);
        },
        unload(texture) {
          if (Array.isArray(texture)) {
            texture.forEach((t2) => t2.destroy(true));
          } else {
            texture.destroy(true);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs
  var GL_INTERNAL_FORMAT, INTERNAL_FORMAT_TO_TEXTURE_FORMATS, FILE_IDENTIFIER, FIELDS, FILE_HEADER_SIZE, ENDIANNESS, TYPES_TO_BYTES_PER_COMPONENT, FORMATS_TO_COMPONENTS, TYPES_TO_BYTES_PER_PIXEL, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, KTX;
  var init_const12 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs"() {
      "use strict";
      GL_INTERNAL_FORMAT = /* @__PURE__ */ ((GL_INTERNAL_FORMAT2) => {
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA"] = 6408] = "RGBA";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8UI"] = 36220] = "RGBA8UI";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8I"] = 36238] = "RGBA8I";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8"] = 32856] = "RGBA8";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
        GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
        return GL_INTERNAL_FORMAT2;
      })(GL_INTERNAL_FORMAT || {});
      INTERNAL_FORMAT_TO_TEXTURE_FORMATS = {
        [
          33776
          /* COMPRESSED_RGB_S3TC_DXT1_EXT */
        ]: "bc1-rgba-unorm",
        // TODO: ???
        [
          33777
          /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
        ]: "bc1-rgba-unorm",
        [
          33778
          /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
        ]: "bc2-rgba-unorm",
        [
          33779
          /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
        ]: "bc3-rgba-unorm",
        [
          35916
          /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
        ]: "bc1-rgba-unorm-srgb",
        // TODO: ???
        [
          35917
          /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
        ]: "bc1-rgba-unorm-srgb",
        [
          35918
          /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
        ]: "bc2-rgba-unorm-srgb",
        [
          35919
          /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
        ]: "bc3-rgba-unorm-srgb",
        [
          36283
          /* COMPRESSED_RED_RGTC1_EXT */
        ]: "bc4-r-unorm",
        [
          36284
          /* COMPRESSED_SIGNED_RED_RGTC1_EXT */
        ]: "bc4-r-snorm",
        [
          36285
          /* COMPRESSED_RED_GREEN_RGTC2_EXT */
        ]: "bc5-rg-unorm",
        [
          36286
          /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
        ]: "bc5-rg-snorm",
        [
          37488
          /* COMPRESSED_R11_EAC */
        ]: "eac-r11unorm",
        // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',
        [
          37490
          /* COMPRESSED_RG11_EAC */
        ]: "eac-rg11snorm",
        // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',
        [
          37492
          /* COMPRESSED_RGB8_ETC2 */
        ]: "etc2-rgb8unorm",
        [
          37496
          /* COMPRESSED_RGBA8_ETC2_EAC */
        ]: "etc2-rgba8unorm",
        [
          37493
          /* COMPRESSED_SRGB8_ETC2 */
        ]: "etc2-rgb8unorm-srgb",
        [
          37497
          /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
        ]: "etc2-rgba8unorm-srgb",
        [
          37494
          /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ]: "etc2-rgb8a1unorm",
        [
          37495
          /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ]: "etc2-rgb8a1unorm-srgb",
        [
          37808
          /* COMPRESSED_RGBA_ASTC_4x4_KHR */
        ]: "astc-4x4-unorm",
        [
          37840
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
        ]: "astc-4x4-unorm-srgb",
        [
          37809
          /* COMPRESSED_RGBA_ASTC_5x4_KHR */
        ]: "astc-5x4-unorm",
        [
          37841
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
        ]: "astc-5x4-unorm-srgb",
        [
          37810
          /* COMPRESSED_RGBA_ASTC_5x5_KHR */
        ]: "astc-5x5-unorm",
        [
          37842
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
        ]: "astc-5x5-unorm-srgb",
        [
          37811
          /* COMPRESSED_RGBA_ASTC_6x5_KHR */
        ]: "astc-6x5-unorm",
        [
          37843
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
        ]: "astc-6x5-unorm-srgb",
        [
          37812
          /* COMPRESSED_RGBA_ASTC_6x6_KHR */
        ]: "astc-6x6-unorm",
        [
          37844
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
        ]: "astc-6x6-unorm-srgb",
        [
          37813
          /* COMPRESSED_RGBA_ASTC_8x5_KHR */
        ]: "astc-8x5-unorm",
        [
          37845
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
        ]: "astc-8x5-unorm-srgb",
        [
          37814
          /* COMPRESSED_RGBA_ASTC_8x6_KHR */
        ]: "astc-8x6-unorm",
        [
          37846
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
        ]: "astc-8x6-unorm-srgb",
        [
          37815
          /* COMPRESSED_RGBA_ASTC_8x8_KHR */
        ]: "astc-8x8-unorm",
        [
          37847
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
        ]: "astc-8x8-unorm-srgb",
        [
          37816
          /* COMPRESSED_RGBA_ASTC_10x5_KHR */
        ]: "astc-10x5-unorm",
        [
          37848
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
        ]: "astc-10x5-unorm-srgb",
        [
          37817
          /* COMPRESSED_RGBA_ASTC_10x6_KHR */
        ]: "astc-10x6-unorm",
        [
          37849
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
        ]: "astc-10x6-unorm-srgb",
        [
          37818
          /* COMPRESSED_RGBA_ASTC_10x8_KHR */
        ]: "astc-10x8-unorm",
        [
          37850
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
        ]: "astc-10x8-unorm-srgb",
        [
          37819
          /* COMPRESSED_RGBA_ASTC_10x10_KHR */
        ]: "astc-10x10-unorm",
        [
          37851
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
        ]: "astc-10x10-unorm-srgb",
        [
          37820
          /* COMPRESSED_RGBA_ASTC_12x10_KHR */
        ]: "astc-12x10-unorm",
        [
          37852
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
        ]: "astc-12x10-unorm-srgb",
        [
          37821
          /* COMPRESSED_RGBA_ASTC_12x12_KHR */
        ]: "astc-12x12-unorm",
        [
          37853
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */
        ]: "astc-12x12-unorm-srgb",
        [
          36492
          /* COMPRESSED_RGBA_BPTC_UNORM_EXT */
        ]: "bc7-rgba-unorm",
        [
          36493
          /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */
        ]: "bc7-rgba-unorm-srgb",
        [
          36494
          /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */
        ]: "bc6h-rgb-float",
        [
          36495
          /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */
        ]: "bc6h-rgb-ufloat",
        [
          35907
          /* SRGB8_ALPHA8 */
        ]: "rgba8unorm-srgb",
        [
          36759
          /* RGBA8_SNORM */
        ]: "rgba8snorm",
        [
          36220
          /* RGBA8UI */
        ]: "rgba8uint",
        [
          36238
          /* RGBA8I */
        ]: "rgba8sint",
        [
          6408
          /* RGBA */
        ]: "rgba8unorm"
        // [GL_INTERNAL_FORMAT.RGBA8]: 'bgra8unorm'
      };
      FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
      FIELDS = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
      };
      FILE_HEADER_SIZE = 64;
      ENDIANNESS = 67305985;
      TYPES_TO_BYTES_PER_COMPONENT = {
        [
          5121
          /* UNSIGNED_BYTE */
        ]: 1,
        [
          5123
          /* UNSIGNED_SHORT */
        ]: 2,
        [
          5124
          /* INT */
        ]: 4,
        [
          5125
          /* UNSIGNED_INT */
        ]: 4,
        [
          5126
          /* FLOAT */
        ]: 4,
        [
          36193
          /* HALF_FLOAT */
        ]: 8
      };
      FORMATS_TO_COMPONENTS = {
        [
          6408
          /* RGBA */
        ]: 4,
        [
          6407
          /* RGB */
        ]: 3,
        [
          33319
          /* RG */
        ]: 2,
        [
          6403
          /* RED */
        ]: 1,
        [
          6409
          /* LUMINANCE */
        ]: 1,
        [
          6410
          /* LUMINANCE_ALPHA */
        ]: 2,
        [
          6406
          /* ALPHA */
        ]: 1
      };
      TYPES_TO_BYTES_PER_PIXEL = {
        [
          32819
          /* UNSIGNED_SHORT_4_4_4_4 */
        ]: 2,
        [
          32820
          /* UNSIGNED_SHORT_5_5_5_1 */
        ]: 2,
        [
          33635
          /* UNSIGNED_SHORT_5_6_5 */
        ]: 2
      };
      INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
        [
          33776
          /* COMPRESSED_RGB_S3TC_DXT1_EXT */
        ]: 0.5,
        [
          33777
          /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
        ]: 0.5,
        [
          33778
          /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
        ]: 1,
        [
          33779
          /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
        ]: 1,
        [
          35916
          /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
        ]: 0.5,
        [
          35917
          /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
        ]: 0.5,
        [
          35918
          /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
        ]: 1,
        [
          35919
          /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
        ]: 1,
        [
          36283
          /* COMPRESSED_RED_RGTC1_EXT */
        ]: 0.5,
        [
          36284
          /* COMPRESSED_SIGNED_RED_RGTC1_EXT */
        ]: 0.5,
        [
          36285
          /* COMPRESSED_RED_GREEN_RGTC2_EXT */
        ]: 1,
        [
          36286
          /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
        ]: 1,
        [
          37488
          /* COMPRESSED_R11_EAC */
        ]: 0.5,
        [
          37489
          /* COMPRESSED_SIGNED_R11_EAC */
        ]: 0.5,
        [
          37490
          /* COMPRESSED_RG11_EAC */
        ]: 1,
        [
          37491
          /* COMPRESSED_SIGNED_RG11_EAC */
        ]: 1,
        [
          37492
          /* COMPRESSED_RGB8_ETC2 */
        ]: 0.5,
        [
          37496
          /* COMPRESSED_RGBA8_ETC2_EAC */
        ]: 1,
        [
          37493
          /* COMPRESSED_SRGB8_ETC2 */
        ]: 0.5,
        [
          37497
          /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
        ]: 1,
        [
          37494
          /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ]: 0.5,
        [
          37495
          /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
        ]: 0.5,
        [
          37808
          /* COMPRESSED_RGBA_ASTC_4x4_KHR */
        ]: 1,
        [
          37840
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
        ]: 1,
        [
          37809
          /* COMPRESSED_RGBA_ASTC_5x4_KHR */
        ]: 0.8,
        [
          37841
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
        ]: 0.8,
        [
          37810
          /* COMPRESSED_RGBA_ASTC_5x5_KHR */
        ]: 0.64,
        [
          37842
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
        ]: 0.64,
        [
          37811
          /* COMPRESSED_RGBA_ASTC_6x5_KHR */
        ]: 0.53375,
        [
          37843
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
        ]: 0.53375,
        [
          37812
          /* COMPRESSED_RGBA_ASTC_6x6_KHR */
        ]: 0.445,
        [
          37844
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
        ]: 0.445,
        [
          37813
          /* COMPRESSED_RGBA_ASTC_8x5_KHR */
        ]: 0.4,
        [
          37845
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
        ]: 0.4,
        [
          37814
          /* COMPRESSED_RGBA_ASTC_8x6_KHR */
        ]: 0.33375,
        [
          37846
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
        ]: 0.33375,
        [
          37815
          /* COMPRESSED_RGBA_ASTC_8x8_KHR */
        ]: 0.25,
        [
          37847
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
        ]: 0.25,
        [
          37816
          /* COMPRESSED_RGBA_ASTC_10x5_KHR */
        ]: 0.32,
        [
          37848
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
        ]: 0.32,
        [
          37817
          /* COMPRESSED_RGBA_ASTC_10x6_KHR */
        ]: 0.26625,
        [
          37849
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
        ]: 0.26625,
        [
          37818
          /* COMPRESSED_RGBA_ASTC_10x8_KHR */
        ]: 0.2,
        [
          37850
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
        ]: 0.2,
        [
          37819
          /* COMPRESSED_RGBA_ASTC_10x10_KHR */
        ]: 0.16,
        [
          37851
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
        ]: 0.16,
        [
          37820
          /* COMPRESSED_RGBA_ASTC_12x10_KHR */
        ]: 0.13375,
        [
          37852
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
        ]: 0.13375,
        [
          37821
          /* COMPRESSED_RGBA_ASTC_12x12_KHR */
        ]: 0.11125,
        [
          37853
          /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */
        ]: 0.11125,
        [
          36492
          /* COMPRESSED_RGBA_BPTC_UNORM_EXT */
        ]: 1,
        [
          36493
          /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */
        ]: 1,
        [
          36494
          /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */
        ]: 1,
        [
          36495
          /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */
        ]: 1
      };
      KTX = {
        FILE_HEADER_SIZE,
        FILE_IDENTIFIER,
        FORMATS_TO_COMPONENTS,
        INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
        INTERNAL_FORMAT_TO_TEXTURE_FORMATS,
        FIELDS,
        TYPES_TO_BYTES_PER_COMPONENT,
        TYPES_TO_BYTES_PER_PIXEL,
        ENDIANNESS
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs
  function parseKTX(arrayBuffer, supportedFormats) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(dataView)) {
      throw new Error("Invalid KTX identifier in header");
    }
    const {
      littleEndian,
      glType,
      glFormat,
      glInternalFormat,
      pixelWidth,
      pixelHeight,
      numberOfMipmapLevels,
      offset
    } = parseKTXHeader(dataView);
    const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];
    if (!textureFormat) {
      throw new Error(`Unknown texture format ${glInternalFormat}`);
    }
    if (!supportedFormats.includes(textureFormat)) {
      throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);
    }
    const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);
    const imageBuffers = getImageBuffers(
      dataView,
      glType,
      imagePixelByteSize,
      pixelWidth,
      pixelHeight,
      offset,
      numberOfMipmapLevels,
      littleEndian
    );
    return {
      format: textureFormat,
      width: pixelWidth,
      height: pixelHeight,
      resource: imageBuffers,
      alphaMode: "no-premultiply-alpha"
    };
  }
  function getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {
    const alignedWidth = pixelWidth + 3 & ~3;
    const alignedHeight = pixelHeight + 3 & ~3;
    let imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
      imagePixels = alignedWidth * alignedHeight;
    }
    let mipByteSize = imagePixels * imagePixelByteSize;
    let mipWidth = pixelWidth;
    let mipHeight = pixelHeight;
    let alignedMipWidth = alignedWidth;
    let alignedMipHeight = alignedHeight;
    let imageOffset = offset;
    const imageBuffers = new Array(numberOfMipmapLevels);
    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      const imageSize = dataView.getUint32(imageOffset, littleEndian);
      let elementOffset = imageOffset + 4;
      imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);
      elementOffset += mipByteSize;
      imageOffset += imageSize + 4;
      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);
      alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);
      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    return imageBuffers;
  }
  function getImagePixelByteSize(glType, glFormat, glInternalFormat) {
    let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    if (glType !== 0) {
      if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType]) {
        imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];
      } else {
        imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];
      }
    }
    if (imagePixelByteSize === void 0) {
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    return imagePixelByteSize;
  }
  function parseKTXHeader(dataView) {
    const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;
    const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);
    const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);
    const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);
    const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);
    const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
      throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
      throw new Error("WebGL does not support array textures");
    }
    return {
      littleEndian,
      glType,
      glFormat,
      glInternalFormat,
      pixelWidth,
      pixelHeight,
      numberOfMipmapLevels,
      offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData
    };
  }
  function validate(dataView) {
    for (let i3 = 0; i3 < KTX.FILE_IDENTIFIER.length; i3++) {
      if (dataView.getUint8(i3) !== KTX.FILE_IDENTIFIER[i3]) {
        return false;
      }
    }
    return true;
  }
  var init_parseKTX = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs"() {
      init_const12();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs
  var loadKTX;
  var init_loadKTX = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs"() {
      init_LoaderParser();
      init_createTexture();
      init_checkExtension();
      init_Extensions();
      init_CompressedSource();
      init_getSupportedTextureFormats();
      init_parseKTX();
      loadKTX = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High,
          name: "loadKTX"
        },
        name: "loadKTX",
        test(url) {
          return checkExtension(url, ".ktx");
        },
        async load(url, _asset, loader) {
          const supportedTextures = await getSupportedTextureFormats();
          const ktxResponse = await fetch(url);
          const ktxArrayBuffer = await ktxResponse.arrayBuffer();
          const textureOptions = parseKTX(ktxArrayBuffer, supportedTextures);
          const compressedTextureSource = new CompressedSource(textureOptions);
          return createTexture(compressedTextureSource, loader, url);
        },
        unload(texture) {
          if (Array.isArray(texture)) {
            texture.forEach((t2) => t2.destroy(true));
          } else {
            texture.destroy(true);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/ktx.worker.mjs
  var WORKER_CODE4, WORKER_URL4, WorkerInstance4;
  var init_ktx_worker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/_virtual/ktx.worker.mjs"() {
      WORKER_CODE4 = '(function () {\n    \'use strict\';\n\n    const converters = {\n      rgb8unorm: {\n        convertedFormat: "rgba8unorm",\n        convertFunction: convertRGBtoRGBA\n      },\n      "rgb8unorm-srgb": {\n        convertedFormat: "rgba8unorm-srgb",\n        convertFunction: convertRGBtoRGBA\n      }\n    };\n    function convertFormatIfRequired(textureOptions) {\n      const format = textureOptions.format;\n      if (converters[format]) {\n        const convertFunction = converters[format].convertFunction;\n        const levelBuffers = textureOptions.resource;\n        for (let i = 0; i < levelBuffers.length; i++) {\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\n        }\n        textureOptions.format = converters[format].convertedFormat;\n      }\n    }\n    function convertRGBtoRGBA(levelBuffer) {\n      const pixelCount = levelBuffer.byteLength / 3;\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\n      for (let i = 0; i < pixelCount; ++i) {\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\n      }\n      return new Uint8Array(levelBufferWithAlpha.buffer);\n    }\n\n    function createLevelBuffersFromKTX(ktxTexture) {\n      const levelBuffers = [];\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\n        const imageData = ktxTexture.getImageData(i, 0, 0);\n        const levelBuffer = new Uint8Array(imageData.byteLength);\n        levelBuffer.set(imageData);\n        levelBuffers.push(levelBuffer);\n      }\n      return levelBuffers;\n    }\n\n    const glFormatToGPUFormatMap = {\n      6408: "rgba8unorm",\n      32856: "bgra8unorm",\n      //\n      32857: "rgb10a2unorm",\n      33189: "depth16unorm",\n      33190: "depth24plus",\n      33321: "r8unorm",\n      33323: "rg8unorm",\n      33325: "r16float",\n      33326: "r32float",\n      33327: "rg16float",\n      33328: "rg32float",\n      33329: "r8sint",\n      33330: "r8uint",\n      33331: "r16sint",\n      33332: "r16uint",\n      33333: "r32sint",\n      33334: "r32uint",\n      33335: "rg8sint",\n      33336: "rg8uint",\n      33337: "rg16sint",\n      33338: "rg16uint",\n      33339: "rg32sint",\n      33340: "rg32uint",\n      33778: "bc2-rgba-unorm",\n      33779: "bc3-rgba-unorm",\n      34836: "rgba32float",\n      34842: "rgba16float",\n      35056: "depth24plus-stencil8",\n      35898: "rg11b10ufloat",\n      35901: "rgb9e5ufloat",\n      35907: "rgba8unorm-srgb",\n      // bgra8unorm-srgb\n      36012: "depth32float",\n      36013: "depth32float-stencil8",\n      36168: "stencil8",\n      36208: "rgba32uint",\n      36214: "rgba16uint",\n      36220: "rgba8uint",\n      36226: "rgba32sint",\n      36232: "rgba16sint",\n      36238: "rgba8sint",\n      36492: "bc7-rgba-unorm",\n      36756: "r8snorm",\n      36757: "rg8snorm",\n      36759: "rgba8snorm",\n      37496: "etc2-rgba8unorm",\n      37808: "astc-4x4-unorm"\n    };\n    function glFormatToGPUFormat(glInternalFormat) {\n      const format = glFormatToGPUFormatMap[glInternalFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n    }\n\n    const vkFormatToGPUFormatMap = {\n      23: "rgb8unorm",\n      // VK_FORMAT_R8G8B8_UNORM\n      37: "rgba8unorm",\n      // VK_FORMAT_R8G8B8A8_UNORM\n      43: "rgba8unorm-srgb"\n      // VK_FORMAT_R8G8B8A8_SRGB\n      // TODO add more!\n    };\n    function vkFormatToGPUFormat(vkFormat) {\n      const format = vkFormatToGPUFormatMap[vkFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n    }\n\n    function getTextureFormatFromKTXTexture(ktxTexture) {\n      if (ktxTexture.classId === 2) {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n      }\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      "bc3-rgba-unorm": "BC3_RGBA",\n      "bc7-rgba-unorm": "BC7_M5_RGBA",\n      "etc2-rgba8unorm": "ETC2_RGBA",\n      "astc-4x4-unorm": "ASTC_4x4_RGBA",\n      // Uncompressed\n      rgba8unorm: "RGBA32",\n      rg11b10ufloat: "R11F_G11F_B10F"\n    };\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: "",\n      wasmUrl: ""\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let ktxPromise;\n    async function getKTX() {\n      if (!ktxPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        ktxPromise = new Promise((resolve) => {\n          LIBKTX({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((libktx) => {\n            resolve(libktx);\n          });\n        });\n      }\n      return ktxPromise;\n    }\n    async function fetchKTXTexture(url, ktx) {\n      const ktx2Response = await fetch(url);\n      if (ktx2Response.ok) {\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\n      }\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const ktx = await getKTX();\n      const ktxTexture = await fetchKTXTexture(url, ktx);\n      let format;\n      if (ktxTexture.needsTranscoding) {\n        format = basisTranscodedTextureFormat;\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\n        if (result !== ktx.ErrorCode.SUCCESS) {\n          throw new Error("Unable to transcode basis texture.");\n        }\n      } else {\n        format = getTextureFormatFromKTXTexture(ktxTexture);\n      }\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\n      const textureOptions = {\n        width: ktxTexture.baseWidth,\n        height: ktxTexture.baseHeight,\n        format,\n        mipLevelCount: ktxTexture.numLevels,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n      convertFormatIfRequired(textureOptions);\n      return textureOptions;\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getKTX();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type]?.(message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n';
      WORKER_URL4 = null;
      WorkerInstance4 = class {
        constructor() {
          if (!WORKER_URL4) {
            WORKER_URL4 = URL.createObjectURL(new Blob([WORKER_CODE4], { type: "application/javascript" }));
          }
          this.worker = new Worker(WORKER_URL4);
        }
      };
      WorkerInstance4.revokeObjectURL = function revokeObjectURL4() {
        if (WORKER_URL4) {
          URL.revokeObjectURL(WORKER_URL4);
          WORKER_URL4 = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs
  function setKTXTranscoderPath(config3) {
    Object.assign(ktxTranscoderUrls, config3);
  }
  var ktxTranscoderUrls;
  var init_setKTXTranscoderPath = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs"() {
      "use strict";
      ktxTranscoderUrls = {
        jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
        wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs
  function getKTX2Worker(supportedTextures) {
    if (!ktxWorker) {
      ktxWorker = new WorkerInstance4().worker;
      ktxWorker.onmessage = (messageEvent) => {
        const { success, url, textureOptions } = messageEvent.data;
        if (!success) {
          console.warn("Failed to load KTX texture", url);
        }
        urlHash2[url](textureOptions);
      };
      ktxWorker.postMessage({
        type: "init",
        jsUrl: ktxTranscoderUrls.jsUrl,
        wasmUrl: ktxTranscoderUrls.wasmUrl,
        supportedTextures
      });
    }
    return ktxWorker;
  }
  function loadKTX2onWorker(url, supportedTextures) {
    const ktxWorker2 = getKTX2Worker(supportedTextures);
    return new Promise((resolve) => {
      urlHash2[url] = resolve;
      ktxWorker2.postMessage({ type: "load", url });
    });
  }
  var ktxWorker, urlHash2;
  var init_loadKTX2onWorker = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs"() {
      init_ktx_worker();
      init_setKTXTranscoderPath();
      urlHash2 = {};
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs
  var loadKTX2;
  var init_loadKTX2 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs"() {
      init_LoaderParser();
      init_createTexture();
      init_checkExtension();
      init_Extensions();
      init_CompressedSource();
      init_getSupportedTextureFormats();
      init_loadKTX2onWorker();
      loadKTX2 = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High,
          name: "loadKTX2"
        },
        name: "loadKTX2",
        test(url) {
          return checkExtension(url, ".ktx2");
        },
        async load(url, _asset, loader) {
          const supportedTextures = await getSupportedTextureFormats();
          const textureOptions = await loadKTX2onWorker(url, supportedTextures);
          const compressedTextureSource = new CompressedSource(textureOptions);
          return createTexture(compressedTextureSource, loader, url);
        },
        async unload(texture) {
          if (Array.isArray(texture)) {
            texture.forEach((t2) => t2.destroy(true));
          } else {
            texture.destroy(true);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs
  function convertFormatIfRequired(textureOptions) {
    const format = textureOptions.format;
    if (converters[format]) {
      const convertFunction = converters[format].convertFunction;
      const levelBuffers = textureOptions.resource;
      for (let i3 = 0; i3 < levelBuffers.length; i3++) {
        levelBuffers[i3] = convertFunction(levelBuffers[i3]);
      }
      textureOptions.format = converters[format].convertedFormat;
    }
  }
  function convertRGBtoRGBA(levelBuffer) {
    const pixelCount = levelBuffer.byteLength / 3;
    const levelBufferWithAlpha = new Uint32Array(pixelCount);
    for (let i3 = 0; i3 < pixelCount; ++i3) {
      levelBufferWithAlpha[i3] = levelBuffer[i3 * 3] + (levelBuffer[i3 * 3 + 1] << 8) + (levelBuffer[i3 * 3 + 2] << 16) + 4278190080;
    }
    return new Uint8Array(levelBufferWithAlpha.buffer);
  }
  var converters;
  var init_convertFormatIfRequired = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs"() {
      "use strict";
      converters = {
        rgb8unorm: {
          convertedFormat: "rgba8unorm",
          convertFunction: convertRGBtoRGBA
        },
        "rgb8unorm-srgb": {
          convertedFormat: "rgba8unorm-srgb",
          convertFunction: convertRGBtoRGBA
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs
  function createLevelBuffersFromKTX(ktxTexture) {
    const levelBuffers = [];
    for (let i3 = 0; i3 < ktxTexture.numLevels; i3++) {
      const imageData = ktxTexture.getImageData(i3, 0, 0);
      const levelBuffer = new Uint8Array(imageData.byteLength);
      levelBuffer.set(imageData);
      levelBuffers.push(levelBuffer);
    }
    return levelBuffers;
  }
  var init_createLevelBuffersFromKTX = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs
  function glFormatToGPUFormat(glInternalFormat) {
    const format = glFormatToGPUFormatMap[glInternalFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);
  }
  var glFormatToGPUFormatMap;
  var init_glFormatToGPUFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs"() {
      "use strict";
      glFormatToGPUFormatMap = {
        6408: "rgba8unorm",
        32856: "bgra8unorm",
        //
        32857: "rgb10a2unorm",
        33189: "depth16unorm",
        33190: "depth24plus",
        33321: "r8unorm",
        33323: "rg8unorm",
        33325: "r16float",
        33326: "r32float",
        33327: "rg16float",
        33328: "rg32float",
        33329: "r8sint",
        33330: "r8uint",
        33331: "r16sint",
        33332: "r16uint",
        33333: "r32sint",
        33334: "r32uint",
        33335: "rg8sint",
        33336: "rg8uint",
        33337: "rg16sint",
        33338: "rg16uint",
        33339: "rg32sint",
        33340: "rg32uint",
        33778: "bc2-rgba-unorm",
        33779: "bc3-rgba-unorm",
        34836: "rgba32float",
        34842: "rgba16float",
        35056: "depth24plus-stencil8",
        35898: "rg11b10ufloat",
        35901: "rgb9e5ufloat",
        35907: "rgba8unorm-srgb",
        // bgra8unorm-srgb
        36012: "depth32float",
        36013: "depth32float-stencil8",
        36168: "stencil8",
        36208: "rgba32uint",
        36214: "rgba16uint",
        36220: "rgba8uint",
        36226: "rgba32sint",
        36232: "rgba16sint",
        36238: "rgba8sint",
        36492: "bc7-rgba-unorm",
        36756: "r8snorm",
        36757: "rg8snorm",
        36759: "rgba8snorm",
        37496: "etc2-rgba8unorm",
        37808: "astc-4x4-unorm"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs
  function vkFormatToGPUFormat(vkFormat) {
    const format = vkFormatToGPUFormatMap[vkFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported VkFormat: ${vkFormat}`);
  }
  var vkFormatToGPUFormatMap;
  var init_vkFormatToGPUFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs"() {
      "use strict";
      vkFormatToGPUFormatMap = {
        23: "rgb8unorm",
        // VK_FORMAT_R8G8B8_UNORM
        37: "rgba8unorm",
        // VK_FORMAT_R8G8B8A8_UNORM
        43: "rgba8unorm-srgb"
        // VK_FORMAT_R8G8B8A8_SRGB
        // TODO add more!
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs
  function getTextureFormatFromKTXTexture(ktxTexture) {
    if (ktxTexture.classId === 2) {
      return vkFormatToGPUFormat(ktxTexture.vkFormat);
    }
    return glFormatToGPUFormat(ktxTexture.glInternalformat);
  }
  var init_getTextureFormatFromKTXTexture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs"() {
      init_glFormatToGPUFormat();
      init_vkFormatToGPUFormat();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs
  function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
    const format = gpuFormatToBasisTranscoderFormatMap2[transcoderFormat];
    if (format) {
      return format;
    }
    throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
  }
  var gpuFormatToBasisTranscoderFormatMap2;
  var init_gpuFormatToKTXBasisTranscoderFormat = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs"() {
      "use strict";
      gpuFormatToBasisTranscoderFormatMap2 = {
        "bc3-rgba-unorm": "BC3_RGBA",
        "bc7-rgba-unorm": "BC7_M5_RGBA",
        "etc2-rgba8unorm": "ETC2_RGBA",
        "astc-4x4-unorm": "ASTC_4x4_RGBA",
        // Uncompressed
        rgba8unorm: "RGBA32",
        rg11b10ufloat: "R11F_G11F_B10F"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs
  var validFormats, resolveCompressedTextureUrl;
  var init_resolveCompressedTextureUrl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs"() {
      init_Resolver();
      init_checkExtension();
      init_Extensions();
      validFormats = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"];
      resolveCompressedTextureUrl = {
        extension: ExtensionType.ResolveParser,
        test: (value) => checkExtension(value, [".ktx", ".ktx2", ".dds"]),
        parse: (value) => {
          let format;
          const splitValue = value.split(".");
          if (splitValue.length > 2) {
            const newFormat = splitValue[splitValue.length - 2];
            if (validFormats.includes(newFormat)) {
              format = newFormat;
            }
          } else {
            format = splitValue[splitValue.length - 1];
          }
          return {
            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format,
            src: value
          };
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs
  function extractExtensionsForCompressedTextureFormats(formats) {
    const extensions2 = ["basis"];
    const dupeMap = {};
    formats.forEach((format) => {
      const extension = format.split("-")[0];
      if (extension && !dupeMap[extension]) {
        dupeMap[extension] = true;
        extensions2.push(extension);
      }
    });
    extensions2.sort((a2, b2) => {
      const aIndex = validFormats.indexOf(a2);
      const bIndex = validFormats.indexOf(b2);
      if (aIndex === -1) {
        return 1;
      }
      if (bIndex === -1) {
        return -1;
      }
      return aIndex - bIndex;
    });
    return extensions2;
  }
  var compressedTextureExtensions, detectCompressed;
  var init_detectCompressed = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs"() {
      init_Extensions();
      init_getSupportedCompressedTextureFormats();
      init_isWebGLSupported();
      init_isWebGPUSupported();
      init_resolveCompressedTextureUrl();
      detectCompressed = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 2
        },
        test: async () => {
          if (await isWebGPUSupported())
            return true;
          if (isWebGLSupported())
            return true;
          return false;
        },
        add: async (formats) => {
          const supportedCompressedTextureFormats2 = await getSupportedCompressedTextureFormats();
          compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats2);
          return [...compressedTextureExtensions, ...formats];
        },
        remove: async (formats) => {
          if (compressedTextureExtensions) {
            return formats.filter((f2) => !(f2 in compressedTextureExtensions));
          }
          return formats;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/culling/Culler.mjs
  var tempBounds5, _Culler, Culler;
  var init_Culler = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/culling/Culler.mjs"() {
      init_Bounds();
      init_getGlobalBounds();
      tempBounds5 = new Bounds();
      _Culler = class _Culler2 {
        /**
         * Culls the children of a specific container based on the given view. This will also cull items that are not
         * being explicitly managed by the culler.
         * @param container - The container to cull.
         * @param view - The view rectangle.
         * @param skipUpdateTransform - Whether to skip updating the transform.
         */
        cull(container, view, skipUpdateTransform = true) {
          this._cullRecursive(container, view, skipUpdateTransform);
        }
        _cullRecursive(container, view, skipUpdateTransform = true) {
          if (container.cullable && container.measurable && container.includeInBuild) {
            const bounds = container.cullArea ?? getGlobalBounds(container, skipUpdateTransform, tempBounds5);
            container.culled = bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y;
          } else {
            container.culled = false;
          }
          if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild)
            return;
          for (let i3 = 0; i3 < container.children.length; i3++) {
            this._cullRecursive(container.children[i3], view, skipUpdateTransform);
          }
        }
      };
      _Culler.shared = new _Culler();
      Culler = _Culler;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/culling/CullerPlugin.mjs
  var CullerPlugin;
  var init_CullerPlugin = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/culling/CullerPlugin.mjs"() {
      init_Extensions();
      init_Culler();
      CullerPlugin = class {
        static init() {
          this._renderRef = this.render.bind(this);
          this.render = () => {
            Culler.shared.cull(this.stage, this.renderer.screen);
            this.renderer.render({ container: this.stage });
          };
        }
        static destroy() {
          this.render = this._renderRef;
        }
      };
      CullerPlugin.extension = {
        priority: 10,
        type: ExtensionType.Application,
        name: "culler"
      };
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/conventions.js
  var require_conventions = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
      "use strict";
      function find(list, predicate, ac) {
        if (ac === void 0) {
          ac = Array.prototype;
        }
        if (list && typeof ac.find === "function") {
          return ac.find.call(list, predicate);
        }
        for (var i3 = 0; i3 < list.length; i3++) {
          if (Object.prototype.hasOwnProperty.call(list, i3)) {
            var item = list[i3];
            if (predicate.call(void 0, item, i3, list)) {
              return item;
            }
          }
        }
      }
      function freeze(object, oc) {
        if (oc === void 0) {
          oc = Object;
        }
        return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
      }
      function assign(target, source7) {
        if (target === null || typeof target !== "object") {
          throw new TypeError("target is not an object");
        }
        for (var key in source7) {
          if (Object.prototype.hasOwnProperty.call(source7, key)) {
            target[key] = source7[key];
          }
        }
        return target;
      }
      var MIME_TYPE = freeze({
        /**
         * `text/html`, the only mime type that triggers treating an XML document as HTML.
         *
         * @see DOMParser.SupportedType.isHTML
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
         */
        HTML: "text/html",
        /**
         * Helper method to check a mime type if it indicates an HTML document
         *
         * @param {string} [value]
         * @returns {boolean}
         *
         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/HTML Wikipedia
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
        isHTML: function(value) {
          return value === MIME_TYPE.HTML;
        },
        /**
         * `application/xml`, the standard mime type for XML documents.
         *
         * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
         * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_APPLICATION: "application/xml",
        /**
         * `text/html`, an alias for `application/xml`.
         *
         * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
         * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
         */
        XML_TEXT: "text/xml",
        /**
         * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
         * but is parsed as an XML document.
         *
         * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
         * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
         */
        XML_XHTML_APPLICATION: "application/xhtml+xml",
        /**
         * `image/svg+xml`,
         *
         * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
         * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
         * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
         */
        XML_SVG_IMAGE: "image/svg+xml"
      });
      var NAMESPACE = freeze({
        /**
         * The XHTML namespace.
         *
         * @see http://www.w3.org/1999/xhtml
         */
        HTML: "http://www.w3.org/1999/xhtml",
        /**
         * Checks if `uri` equals `NAMESPACE.HTML`.
         *
         * @param {string} [uri]
         *
         * @see NAMESPACE.HTML
         */
        isHTML: function(uri) {
          return uri === NAMESPACE.HTML;
        },
        /**
         * The SVG namespace.
         *
         * @see http://www.w3.org/2000/svg
         */
        SVG: "http://www.w3.org/2000/svg",
        /**
         * The `xml:` namespace.
         *
         * @see http://www.w3.org/XML/1998/namespace
         */
        XML: "http://www.w3.org/XML/1998/namespace",
        /**
         * The `xmlns:` namespace
         *
         * @see https://www.w3.org/2000/xmlns/
         */
        XMLNS: "http://www.w3.org/2000/xmlns/"
      });
      exports.assign = assign;
      exports.find = find;
      exports.freeze = freeze;
      exports.MIME_TYPE = MIME_TYPE;
      exports.NAMESPACE = NAMESPACE;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/dom.js
  var require_dom = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
      var conventions = require_conventions();
      var find = conventions.find;
      var NAMESPACE = conventions.NAMESPACE;
      function notEmptyString(input) {
        return input !== "";
      }
      function splitOnASCIIWhitespace(input) {
        return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
      }
      function orderedSetReducer(current, element) {
        if (!current.hasOwnProperty(element)) {
          current[element] = true;
        }
        return current;
      }
      function toOrderedSet(input) {
        if (!input)
          return [];
        var list = splitOnASCIIWhitespace(input);
        return Object.keys(list.reduce(orderedSetReducer, {}));
      }
      function arrayIncludes(list) {
        return function(element) {
          return list && list.indexOf(element) !== -1;
        };
      }
      function copy(src, dest) {
        for (var p3 in src) {
          if (Object.prototype.hasOwnProperty.call(src, p3)) {
            dest[p3] = src[p3];
          }
        }
      }
      function _extends(Class, Super) {
        var pt = Class.prototype;
        if (!(pt instanceof Super)) {
          let t3 = function() {
          };
          var t2 = t3;
          ;
          t3.prototype = Super.prototype;
          t3 = new t3();
          copy(pt, t3);
          Class.prototype = pt = t3;
        }
        if (pt.constructor != Class) {
          if (typeof Class != "function") {
            console.error("unknown Class:" + Class);
          }
          pt.constructor = Class;
        }
      }
      var NodeType = {};
      var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
      var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
      var TEXT_NODE = NodeType.TEXT_NODE = 3;
      var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
      var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
      var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
      var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
      var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
      var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
      var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
      var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
      var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
      var ExceptionCode = {};
      var ExceptionMessage = {};
      var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
      var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
      var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
      var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
      var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
      var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
      var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
      var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
      var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
      var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
      var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
      var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
      var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
      var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
      var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
      function DOMException(code, message) {
        if (message instanceof Error) {
          var error = message;
        } else {
          error = this;
          Error.call(this, ExceptionMessage[code]);
          this.message = ExceptionMessage[code];
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, DOMException);
        }
        error.code = code;
        if (message)
          this.message = this.message + ": " + message;
        return error;
      }
      DOMException.prototype = Error.prototype;
      copy(ExceptionCode, DOMException);
      function NodeList() {
      }
      NodeList.prototype = {
        /**
         * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
         * @standard level1
         */
        length: 0,
        /**
         * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
         * @standard level1
         * @param index  unsigned long
         *   Index into the collection.
         * @return Node
         * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
         */
        item: function(index) {
          return index >= 0 && index < this.length ? this[index] : null;
        },
        toString: function(isHTML, nodeFilter) {
          for (var buf = [], i3 = 0; i3 < this.length; i3++) {
            serializeToString(this[i3], buf, isHTML, nodeFilter);
          }
          return buf.join("");
        },
        /**
         * @private
         * @param {function (Node):boolean} predicate
         * @returns {Node[]}
         */
        filter: function(predicate) {
          return Array.prototype.filter.call(this, predicate);
        },
        /**
         * @private
         * @param {Node} item
         * @returns {number}
         */
        indexOf: function(item) {
          return Array.prototype.indexOf.call(this, item);
        }
      };
      function LiveNodeList(node, refresh) {
        this._node = node;
        this._refresh = refresh;
        _updateLiveList(this);
      }
      function _updateLiveList(list) {
        var inc = list._node._inc || list._node.ownerDocument._inc;
        if (list._inc !== inc) {
          var ls = list._refresh(list._node);
          __set__(list, "length", ls.length);
          if (!list.$$length || ls.length < list.$$length) {
            for (var i3 = ls.length; i3 in list; i3++) {
              if (Object.prototype.hasOwnProperty.call(list, i3)) {
                delete list[i3];
              }
            }
          }
          copy(ls, list);
          list._inc = inc;
        }
      }
      LiveNodeList.prototype.item = function(i3) {
        _updateLiveList(this);
        return this[i3] || null;
      };
      _extends(LiveNodeList, NodeList);
      function NamedNodeMap() {
      }
      function _findNodeIndex(list, node) {
        var i3 = list.length;
        while (i3--) {
          if (list[i3] === node) {
            return i3;
          }
        }
      }
      function _addNamedNode(el, list, newAttr, oldAttr) {
        if (oldAttr) {
          list[_findNodeIndex(list, oldAttr)] = newAttr;
        } else {
          list[list.length++] = newAttr;
        }
        if (el) {
          newAttr.ownerElement = el;
          var doc = el.ownerDocument;
          if (doc) {
            oldAttr && _onRemoveAttribute(doc, el, oldAttr);
            _onAddAttribute(doc, el, newAttr);
          }
        }
      }
      function _removeNamedNode(el, list, attr) {
        var i3 = _findNodeIndex(list, attr);
        if (i3 >= 0) {
          var lastIndex = list.length - 1;
          while (i3 < lastIndex) {
            list[i3] = list[++i3];
          }
          list.length = lastIndex;
          if (el) {
            var doc = el.ownerDocument;
            if (doc) {
              _onRemoveAttribute(doc, el, attr);
              attr.ownerElement = null;
            }
          }
        } else {
          throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
        }
      }
      NamedNodeMap.prototype = {
        length: 0,
        item: NodeList.prototype.item,
        getNamedItem: function(key) {
          var i3 = this.length;
          while (i3--) {
            var attr = this[i3];
            if (attr.nodeName == key) {
              return attr;
            }
          }
        },
        setNamedItem: function(attr) {
          var el = attr.ownerElement;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          var oldAttr = this.getNamedItem(attr.nodeName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        /* returns Node */
        setNamedItemNS: function(attr) {
          var el = attr.ownerElement, oldAttr;
          if (el && el != this._ownerElement) {
            throw new DOMException(INUSE_ATTRIBUTE_ERR);
          }
          oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
          _addNamedNode(this._ownerElement, this, attr, oldAttr);
          return oldAttr;
        },
        /* returns Node */
        removeNamedItem: function(key) {
          var attr = this.getNamedItem(key);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
        //for level2
        removeNamedItemNS: function(namespaceURI, localName) {
          var attr = this.getNamedItemNS(namespaceURI, localName);
          _removeNamedNode(this._ownerElement, this, attr);
          return attr;
        },
        getNamedItemNS: function(namespaceURI, localName) {
          var i3 = this.length;
          while (i3--) {
            var node = this[i3];
            if (node.localName == localName && node.namespaceURI == namespaceURI) {
              return node;
            }
          }
          return null;
        }
      };
      function DOMImplementation() {
      }
      DOMImplementation.prototype = {
        /**
         * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
         * The different implementations fairly diverged in what kind of features were reported.
         * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
         *
         * @deprecated It is deprecated and modern browsers return true in all cases.
         *
         * @param {string} feature
         * @param {string} [version]
         * @returns {boolean} always true
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
         * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
         */
        hasFeature: function(feature, version) {
          return true;
        },
        /**
         * Creates an XML Document object of the specified type with its document element.
         *
         * __It behaves slightly different from the description in the living standard__:
         * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
         * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
         * - this implementation is not validating names or qualified names
         *   (when parsing XML strings, the SAX parser takes care of that)
         *
         * @param {string|null} namespaceURI
         * @param {string} qualifiedName
         * @param {DocumentType=null} doctype
         * @returns {Document}
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
         *
         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
         */
        createDocument: function(namespaceURI, qualifiedName, doctype) {
          var doc = new Document();
          doc.implementation = this;
          doc.childNodes = new NodeList();
          doc.doctype = doctype || null;
          if (doctype) {
            doc.appendChild(doctype);
          }
          if (qualifiedName) {
            var root = doc.createElementNS(namespaceURI, qualifiedName);
            doc.appendChild(root);
          }
          return doc;
        },
        /**
         * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
         *
         * __This behavior is slightly different from the in the specs__:
         * - this implementation is not validating names or qualified names
         *   (when parsing XML strings, the SAX parser takes care of that)
         *
         * @param {string} qualifiedName
         * @param {string} [publicId]
         * @param {string} [systemId]
         * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
         * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
         *
         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
         */
        createDocumentType: function(qualifiedName, publicId, systemId) {
          var node = new DocumentType();
          node.name = qualifiedName;
          node.nodeName = qualifiedName;
          node.publicId = publicId || "";
          node.systemId = systemId || "";
          return node;
        }
      };
      function Node() {
      }
      Node.prototype = {
        firstChild: null,
        lastChild: null,
        previousSibling: null,
        nextSibling: null,
        attributes: null,
        parentNode: null,
        childNodes: null,
        ownerDocument: null,
        nodeValue: null,
        namespaceURI: null,
        prefix: null,
        localName: null,
        // Modified in DOM Level 2:
        insertBefore: function(newChild, refChild) {
          return _insertBefore(this, newChild, refChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          if (oldChild) {
            this.removeChild(oldChild);
          }
        },
        removeChild: function(oldChild) {
          return _removeChild(this, oldChild);
        },
        appendChild: function(newChild) {
          return this.insertBefore(newChild, null);
        },
        hasChildNodes: function() {
          return this.firstChild != null;
        },
        cloneNode: function(deep) {
          return cloneNode(this.ownerDocument || this, this, deep);
        },
        // Modified in DOM Level 2:
        normalize: function() {
          var child = this.firstChild;
          while (child) {
            var next = child.nextSibling;
            if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
              this.removeChild(next);
              child.appendData(next.data);
            } else {
              child.normalize();
              child = next;
            }
          }
        },
        // Introduced in DOM Level 2:
        isSupported: function(feature, version) {
          return this.ownerDocument.implementation.hasFeature(feature, version);
        },
        // Introduced in DOM Level 2:
        hasAttributes: function() {
          return this.attributes.length > 0;
        },
        /**
         * Look up the prefix associated to the given namespace URI, starting from this node.
         * **The default namespace declarations are ignored by this method.**
         * See Namespace Prefix Lookup for details on the algorithm used by this method.
         *
         * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
         *
         * @param {string | null} namespaceURI
         * @returns {string | null}
         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
         * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
         * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
         * @see https://github.com/xmldom/xmldom/issues/322
         */
        lookupPrefix: function(namespaceURI) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              for (var n2 in map) {
                if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
                  return n2;
                }
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        // Introduced in DOM Level 3:
        lookupNamespaceURI: function(prefix) {
          var el = this;
          while (el) {
            var map = el._nsMap;
            if (map) {
              if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                return map[prefix];
              }
            }
            el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
          }
          return null;
        },
        // Introduced in DOM Level 3:
        isDefaultNamespace: function(namespaceURI) {
          var prefix = this.lookupPrefix(namespaceURI);
          return prefix == null;
        }
      };
      function _xmlEncoder(c2) {
        return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
      }
      copy(NodeType, Node);
      copy(NodeType, Node.prototype);
      function _visitNode(node, callback) {
        if (callback(node)) {
          return true;
        }
        if (node = node.firstChild) {
          do {
            if (_visitNode(node, callback)) {
              return true;
            }
          } while (node = node.nextSibling);
        }
      }
      function Document() {
        this.ownerDocument = this;
      }
      function _onAddAttribute(doc, el, newAttr) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
        }
      }
      function _onRemoveAttribute(doc, el, newAttr, remove) {
        doc && doc._inc++;
        var ns = newAttr.namespaceURI;
        if (ns === NAMESPACE.XMLNS) {
          delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
        }
      }
      function _onUpdateChild(doc, el, newChild) {
        if (doc && doc._inc) {
          doc._inc++;
          var cs = el.childNodes;
          if (newChild) {
            cs[cs.length++] = newChild;
          } else {
            var child = el.firstChild;
            var i3 = 0;
            while (child) {
              cs[i3++] = child;
              child = child.nextSibling;
            }
            cs.length = i3;
            delete cs[cs.length];
          }
        }
      }
      function _removeChild(parentNode, child) {
        var previous = child.previousSibling;
        var next = child.nextSibling;
        if (previous) {
          previous.nextSibling = next;
        } else {
          parentNode.firstChild = next;
        }
        if (next) {
          next.previousSibling = previous;
        } else {
          parentNode.lastChild = previous;
        }
        child.parentNode = null;
        child.previousSibling = null;
        child.nextSibling = null;
        _onUpdateChild(parentNode.ownerDocument, parentNode);
        return child;
      }
      function hasValidParentNodeType(node) {
        return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
      }
      function hasInsertableNodeType(node) {
        return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
      }
      function isDocTypeNode(node) {
        return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
      }
      function isElementNode(node) {
        return node && node.nodeType === Node.ELEMENT_NODE;
      }
      function isTextNode(node) {
        return node && node.nodeType === Node.TEXT_NODE;
      }
      function isElementInsertionPossible(doc, child) {
        var parentChildNodes = doc.childNodes || [];
        if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function isElementReplacementPossible(doc, child) {
        var parentChildNodes = doc.childNodes || [];
        function hasElementChildThatIsNotChild(node) {
          return isElementNode(node) && node !== child;
        }
        if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
          return false;
        }
        var docTypeNode = find(parentChildNodes, isDocTypeNode);
        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
      }
      function assertPreInsertionValidity1to5(parent, node, child) {
        if (!hasValidParentNodeType(parent)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
        }
        if (child && child.parentNode !== parent) {
          throw new DOMException(NOT_FOUND_ERR, "child not in parent");
        }
        if (
          // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
          !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
          // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
          // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
          // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
          isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
        ) {
          throw new DOMException(
            HIERARCHY_REQUEST_ERR,
            "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
          );
        }
      }
      function assertPreInsertionValidityInDocument(parent, node, child) {
        var parentChildNodes = parent.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementInsertionPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          if (find(parentChildNodes, isDocTypeNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
          if (!child && parentElementChild) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
          }
        }
      }
      function assertPreReplacementValidityInDocument(parent, node, child) {
        var parentChildNodes = parent.childNodes || [];
        var nodeChildNodes = node.childNodes || [];
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var nodeChildElements = nodeChildNodes.filter(isElementNode);
          if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
          }
          if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
          }
        }
        if (isElementNode(node)) {
          if (!isElementReplacementPossible(parent, child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
          }
        }
        if (isDocTypeNode(node)) {
          let hasDoctypeChildThatIsNotChild2 = function(node2) {
            return isDocTypeNode(node2) && node2 !== child;
          };
          var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
          if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
          }
          var parentElementChild = find(parentChildNodes, isElementNode);
          if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
            throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
          }
        }
      }
      function _insertBefore(parent, node, child, _inDocumentAssertion) {
        assertPreInsertionValidity1to5(parent, node, child);
        if (parent.nodeType === Node.DOCUMENT_NODE) {
          (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
        }
        var cp = node.parentNode;
        if (cp) {
          cp.removeChild(node);
        }
        if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var newFirst = node.firstChild;
          if (newFirst == null) {
            return node;
          }
          var newLast = node.lastChild;
        } else {
          newFirst = newLast = node;
        }
        var pre = child ? child.previousSibling : parent.lastChild;
        newFirst.previousSibling = pre;
        newLast.nextSibling = child;
        if (pre) {
          pre.nextSibling = newFirst;
        } else {
          parent.firstChild = newFirst;
        }
        if (child == null) {
          parent.lastChild = newLast;
        } else {
          child.previousSibling = newLast;
        }
        do {
          newFirst.parentNode = parent;
        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
        _onUpdateChild(parent.ownerDocument || parent, parent);
        if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
          node.firstChild = node.lastChild = null;
        }
        return node;
      }
      function _appendSingleChild(parentNode, newChild) {
        if (newChild.parentNode) {
          newChild.parentNode.removeChild(newChild);
        }
        newChild.parentNode = parentNode;
        newChild.previousSibling = parentNode.lastChild;
        newChild.nextSibling = null;
        if (newChild.previousSibling) {
          newChild.previousSibling.nextSibling = newChild;
        } else {
          parentNode.firstChild = newChild;
        }
        parentNode.lastChild = newChild;
        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
        return newChild;
      }
      Document.prototype = {
        //implementation : null,
        nodeName: "#document",
        nodeType: DOCUMENT_NODE,
        /**
         * The DocumentType node of the document.
         *
         * @readonly
         * @type DocumentType
         */
        doctype: null,
        documentElement: null,
        _inc: 1,
        insertBefore: function(newChild, refChild) {
          if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
            var child = newChild.firstChild;
            while (child) {
              var next = child.nextSibling;
              this.insertBefore(child, refChild);
              child = next;
            }
            return newChild;
          }
          _insertBefore(this, newChild, refChild);
          newChild.ownerDocument = this;
          if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
            this.documentElement = newChild;
          }
          return newChild;
        },
        removeChild: function(oldChild) {
          if (this.documentElement == oldChild) {
            this.documentElement = null;
          }
          return _removeChild(this, oldChild);
        },
        replaceChild: function(newChild, oldChild) {
          _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
          newChild.ownerDocument = this;
          if (oldChild) {
            this.removeChild(oldChild);
          }
          if (isElementNode(newChild)) {
            this.documentElement = newChild;
          }
        },
        // Introduced in DOM Level 2:
        importNode: function(importedNode, deep) {
          return importNode(this, importedNode, deep);
        },
        // Introduced in DOM Level 2:
        getElementById: function(id) {
          var rtv = null;
          _visitNode(this.documentElement, function(node) {
            if (node.nodeType == ELEMENT_NODE) {
              if (node.getAttribute("id") == id) {
                rtv = node;
                return true;
              }
            }
          });
          return rtv;
        },
        /**
         * The `getElementsByClassName` method of `Document` interface returns an array-like object
         * of all child elements which have **all** of the given class name(s).
         *
         * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
         *
         *
         * Warning: This is a live LiveNodeList.
         * Changes in the DOM will reflect in the array as the changes occur.
         * If an element selected by this array no longer qualifies for the selector,
         * it will automatically be removed. Be aware of this for iteration purposes.
         *
         * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
         */
        getElementsByClassName: function(classNames) {
          var classNamesSet = toOrderedSet(classNames);
          return new LiveNodeList(this, function(base) {
            var ls = [];
            if (classNamesSet.length > 0) {
              _visitNode(base.documentElement, function(node) {
                if (node !== base && node.nodeType === ELEMENT_NODE) {
                  var nodeClassNames = node.getAttribute("class");
                  if (nodeClassNames) {
                    var matches = classNames === nodeClassNames;
                    if (!matches) {
                      var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                      matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                    }
                    if (matches) {
                      ls.push(node);
                    }
                  }
                }
              });
            }
            return ls;
          });
        },
        //document factory method:
        createElement: function(tagName) {
          var node = new Element();
          node.ownerDocument = this;
          node.nodeName = tagName;
          node.tagName = tagName;
          node.localName = tagName;
          node.childNodes = new NodeList();
          var attrs = node.attributes = new NamedNodeMap();
          attrs._ownerElement = node;
          return node;
        },
        createDocumentFragment: function() {
          var node = new DocumentFragment();
          node.ownerDocument = this;
          node.childNodes = new NodeList();
          return node;
        },
        createTextNode: function(data) {
          var node = new Text2();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createComment: function(data) {
          var node = new Comment();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createCDATASection: function(data) {
          var node = new CDATASection();
          node.ownerDocument = this;
          node.appendData(data);
          return node;
        },
        createProcessingInstruction: function(target, data) {
          var node = new ProcessingInstruction();
          node.ownerDocument = this;
          node.tagName = node.nodeName = node.target = target;
          node.nodeValue = node.data = data;
          return node;
        },
        createAttribute: function(name) {
          var node = new Attr();
          node.ownerDocument = this;
          node.name = name;
          node.nodeName = name;
          node.localName = name;
          node.specified = true;
          return node;
        },
        createEntityReference: function(name) {
          var node = new EntityReference();
          node.ownerDocument = this;
          node.nodeName = name;
          return node;
        },
        // Introduced in DOM Level 2:
        createElementNS: function(namespaceURI, qualifiedName) {
          var node = new Element();
          var pl = qualifiedName.split(":");
          var attrs = node.attributes = new NamedNodeMap();
          node.childNodes = new NodeList();
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.tagName = qualifiedName;
          node.namespaceURI = namespaceURI;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          attrs._ownerElement = node;
          return node;
        },
        // Introduced in DOM Level 2:
        createAttributeNS: function(namespaceURI, qualifiedName) {
          var node = new Attr();
          var pl = qualifiedName.split(":");
          node.ownerDocument = this;
          node.nodeName = qualifiedName;
          node.name = qualifiedName;
          node.namespaceURI = namespaceURI;
          node.specified = true;
          if (pl.length == 2) {
            node.prefix = pl[0];
            node.localName = pl[1];
          } else {
            node.localName = qualifiedName;
          }
          return node;
        }
      };
      _extends(Document, Node);
      function Element() {
        this._nsMap = {};
      }
      Element.prototype = {
        nodeType: ELEMENT_NODE,
        hasAttribute: function(name) {
          return this.getAttributeNode(name) != null;
        },
        getAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          return attr && attr.value || "";
        },
        getAttributeNode: function(name) {
          return this.attributes.getNamedItem(name);
        },
        setAttribute: function(name, value) {
          var attr = this.ownerDocument.createAttribute(name);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        removeAttribute: function(name) {
          var attr = this.getAttributeNode(name);
          attr && this.removeAttributeNode(attr);
        },
        //four real opeartion method
        appendChild: function(newChild) {
          if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
            return this.insertBefore(newChild, null);
          } else {
            return _appendSingleChild(this, newChild);
          }
        },
        setAttributeNode: function(newAttr) {
          return this.attributes.setNamedItem(newAttr);
        },
        setAttributeNodeNS: function(newAttr) {
          return this.attributes.setNamedItemNS(newAttr);
        },
        removeAttributeNode: function(oldAttr) {
          return this.attributes.removeNamedItem(oldAttr.nodeName);
        },
        //get real attribute name,and remove it by removeAttributeNode
        removeAttributeNS: function(namespaceURI, localName) {
          var old = this.getAttributeNodeNS(namespaceURI, localName);
          old && this.removeAttributeNode(old);
        },
        hasAttributeNS: function(namespaceURI, localName) {
          return this.getAttributeNodeNS(namespaceURI, localName) != null;
        },
        getAttributeNS: function(namespaceURI, localName) {
          var attr = this.getAttributeNodeNS(namespaceURI, localName);
          return attr && attr.value || "";
        },
        setAttributeNS: function(namespaceURI, qualifiedName, value) {
          var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        },
        getAttributeNodeNS: function(namespaceURI, localName) {
          return this.attributes.getNamedItemNS(namespaceURI, localName);
        },
        getElementsByTagName: function(tagName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        },
        getElementsByTagNameNS: function(namespaceURI, localName) {
          return new LiveNodeList(this, function(base) {
            var ls = [];
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                ls.push(node);
              }
            });
            return ls;
          });
        }
      };
      Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
      Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
      _extends(Element, Node);
      function Attr() {
      }
      Attr.prototype.nodeType = ATTRIBUTE_NODE;
      _extends(Attr, Node);
      function CharacterData() {
      }
      CharacterData.prototype = {
        data: "",
        substringData: function(offset, count2) {
          return this.data.substring(offset, offset + count2);
        },
        appendData: function(text) {
          text = this.data + text;
          this.nodeValue = this.data = text;
          this.length = text.length;
        },
        insertData: function(offset, text) {
          this.replaceData(offset, 0, text);
        },
        appendChild: function(newChild) {
          throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
        },
        deleteData: function(offset, count2) {
          this.replaceData(offset, count2, "");
        },
        replaceData: function(offset, count2, text) {
          var start = this.data.substring(0, offset);
          var end = this.data.substring(offset + count2);
          text = start + text + end;
          this.nodeValue = this.data = text;
          this.length = text.length;
        }
      };
      _extends(CharacterData, Node);
      function Text2() {
      }
      Text2.prototype = {
        nodeName: "#text",
        nodeType: TEXT_NODE,
        splitText: function(offset) {
          var text = this.data;
          var newText = text.substring(offset);
          text = text.substring(0, offset);
          this.data = this.nodeValue = text;
          this.length = text.length;
          var newNode = this.ownerDocument.createTextNode(newText);
          if (this.parentNode) {
            this.parentNode.insertBefore(newNode, this.nextSibling);
          }
          return newNode;
        }
      };
      _extends(Text2, CharacterData);
      function Comment() {
      }
      Comment.prototype = {
        nodeName: "#comment",
        nodeType: COMMENT_NODE
      };
      _extends(Comment, CharacterData);
      function CDATASection() {
      }
      CDATASection.prototype = {
        nodeName: "#cdata-section",
        nodeType: CDATA_SECTION_NODE
      };
      _extends(CDATASection, CharacterData);
      function DocumentType() {
      }
      DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
      _extends(DocumentType, Node);
      function Notation() {
      }
      Notation.prototype.nodeType = NOTATION_NODE;
      _extends(Notation, Node);
      function Entity() {
      }
      Entity.prototype.nodeType = ENTITY_NODE;
      _extends(Entity, Node);
      function EntityReference() {
      }
      EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
      _extends(EntityReference, Node);
      function DocumentFragment() {
      }
      DocumentFragment.prototype.nodeName = "#document-fragment";
      DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
      _extends(DocumentFragment, Node);
      function ProcessingInstruction() {
      }
      ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
      _extends(ProcessingInstruction, Node);
      function XMLSerializer2() {
      }
      XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
        return nodeSerializeToString.call(node, isHtml, nodeFilter);
      };
      Node.prototype.toString = nodeSerializeToString;
      function nodeSerializeToString(isHtml, nodeFilter) {
        var buf = [];
        var refNode = this.nodeType == 9 && this.documentElement || this;
        var prefix = refNode.prefix;
        var uri = refNode.namespaceURI;
        if (uri && prefix == null) {
          var prefix = refNode.lookupPrefix(uri);
          if (prefix == null) {
            var visibleNamespaces = [
              { namespace: uri, prefix: null }
              //{namespace:uri,prefix:''}
            ];
          }
        }
        serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
        return buf.join("");
      }
      function needNamespaceDefine(node, isHTML, visibleNamespaces) {
        var prefix = node.prefix || "";
        var uri = node.namespaceURI;
        if (!uri) {
          return false;
        }
        if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
          return false;
        }
        var i3 = visibleNamespaces.length;
        while (i3--) {
          var ns = visibleNamespaces[i3];
          if (ns.prefix === prefix) {
            return ns.namespace !== uri;
          }
        }
        return true;
      }
      function addSerializedAttribute(buf, qualifiedName, value) {
        buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
      }
      function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
        if (!visibleNamespaces) {
          visibleNamespaces = [];
        }
        if (nodeFilter) {
          node = nodeFilter(node);
          if (node) {
            if (typeof node == "string") {
              buf.push(node);
              return;
            }
          } else {
            return;
          }
        }
        switch (node.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var len = attrs.length;
            var child = node.firstChild;
            var nodeName = node.tagName;
            isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
            var prefixedNodeName = nodeName;
            if (!isHTML && !node.prefix && node.namespaceURI) {
              var defaultNS;
              for (var ai = 0; ai < attrs.length; ai++) {
                if (attrs.item(ai).name === "xmlns") {
                  defaultNS = attrs.item(ai).value;
                  break;
                }
              }
              if (!defaultNS) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                    defaultNS = namespace.namespace;
                    break;
                  }
                }
              }
              if (defaultNS !== node.namespaceURI) {
                for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                  var namespace = visibleNamespaces[nsi];
                  if (namespace.namespace === node.namespaceURI) {
                    if (namespace.prefix) {
                      prefixedNodeName = namespace.prefix + ":" + nodeName;
                    }
                    break;
                  }
                }
              }
            }
            buf.push("<", prefixedNodeName);
            for (var i3 = 0; i3 < len; i3++) {
              var attr = attrs.item(i3);
              if (attr.prefix == "xmlns") {
                visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
              } else if (attr.nodeName == "xmlns") {
                visibleNamespaces.push({ prefix: "", namespace: attr.value });
              }
            }
            for (var i3 = 0; i3 < len; i3++) {
              var attr = attrs.item(i3);
              if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                var prefix = attr.prefix || "";
                var uri = attr.namespaceURI;
                addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                visibleNamespaces.push({ prefix, namespace: uri });
              }
              serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
            }
            if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
              var prefix = node.prefix || "";
              var uri = node.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
              buf.push(">");
              if (isHTML && /^script$/i.test(nodeName)) {
                while (child) {
                  if (child.data) {
                    buf.push(child.data);
                  } else {
                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  }
                  child = child.nextSibling;
                }
              } else {
                while (child) {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  child = child.nextSibling;
                }
              }
              buf.push("</", prefixedNodeName, ">");
            } else {
              buf.push("/>");
            }
            return;
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var child = node.firstChild;
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
            return;
          case ATTRIBUTE_NODE:
            return addSerializedAttribute(buf, node.name, node.value);
          case TEXT_NODE:
            return buf.push(
              node.data.replace(/[<&>]/g, _xmlEncoder)
            );
          case CDATA_SECTION_NODE:
            return buf.push("<![CDATA[", node.data, "]]>");
          case COMMENT_NODE:
            return buf.push("<!--", node.data, "-->");
          case DOCUMENT_TYPE_NODE:
            var pubid = node.publicId;
            var sysid = node.systemId;
            buf.push("<!DOCTYPE ", node.name);
            if (pubid) {
              buf.push(" PUBLIC ", pubid);
              if (sysid && sysid != ".") {
                buf.push(" ", sysid);
              }
              buf.push(">");
            } else if (sysid && sysid != ".") {
              buf.push(" SYSTEM ", sysid, ">");
            } else {
              var sub = node.internalSubset;
              if (sub) {
                buf.push(" [", sub, "]");
              }
              buf.push(">");
            }
            return;
          case PROCESSING_INSTRUCTION_NODE:
            return buf.push("<?", node.target, " ", node.data, "?>");
          case ENTITY_REFERENCE_NODE:
            return buf.push("&", node.nodeName, ";");
          default:
            buf.push("??", node.nodeName);
        }
      }
      function importNode(doc, node, deep) {
        var node2;
        switch (node.nodeType) {
          case ELEMENT_NODE:
            node2 = node.cloneNode(false);
            node2.ownerDocument = doc;
          case DOCUMENT_FRAGMENT_NODE:
            break;
          case ATTRIBUTE_NODE:
            deep = true;
            break;
        }
        if (!node2) {
          node2 = node.cloneNode(false);
        }
        node2.ownerDocument = doc;
        node2.parentNode = null;
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(importNode(doc, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function cloneNode(doc, node, deep) {
        var node2 = new node.constructor();
        for (var n2 in node) {
          if (Object.prototype.hasOwnProperty.call(node, n2)) {
            var v2 = node[n2];
            if (typeof v2 != "object") {
              if (v2 != node2[n2]) {
                node2[n2] = v2;
              }
            }
          }
        }
        if (node.childNodes) {
          node2.childNodes = new NodeList();
        }
        node2.ownerDocument = doc;
        switch (node2.nodeType) {
          case ELEMENT_NODE:
            var attrs = node.attributes;
            var attrs2 = node2.attributes = new NamedNodeMap();
            var len = attrs.length;
            attrs2._ownerElement = node2;
            for (var i3 = 0; i3 < len; i3++) {
              node2.setAttributeNode(cloneNode(doc, attrs.item(i3), true));
            }
            break;
            ;
          case ATTRIBUTE_NODE:
            deep = true;
        }
        if (deep) {
          var child = node.firstChild;
          while (child) {
            node2.appendChild(cloneNode(doc, child, deep));
            child = child.nextSibling;
          }
        }
        return node2;
      }
      function __set__(object, key, value) {
        object[key] = value;
      }
      try {
        if (Object.defineProperty) {
          let getTextContent2 = function(node) {
            switch (node.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                var buf = [];
                node = node.firstChild;
                while (node) {
                  if (node.nodeType !== 7 && node.nodeType !== 8) {
                    buf.push(getTextContent2(node));
                  }
                  node = node.nextSibling;
                }
                return buf.join("");
              default:
                return node.nodeValue;
            }
          };
          getTextContent = getTextContent2;
          Object.defineProperty(LiveNodeList.prototype, "length", {
            get: function() {
              _updateLiveList(this);
              return this.$$length;
            }
          });
          Object.defineProperty(Node.prototype, "textContent", {
            get: function() {
              return getTextContent2(this);
            },
            set: function(data) {
              switch (this.nodeType) {
                case ELEMENT_NODE:
                case DOCUMENT_FRAGMENT_NODE:
                  while (this.firstChild) {
                    this.removeChild(this.firstChild);
                  }
                  if (data || String(data)) {
                    this.appendChild(this.ownerDocument.createTextNode(data));
                  }
                  break;
                default:
                  this.data = data;
                  this.value = data;
                  this.nodeValue = data;
              }
            }
          });
          __set__ = function(object, key, value) {
            object["$$" + key] = value;
          };
        }
      } catch (e2) {
      }
      var getTextContent;
      exports.DocumentType = DocumentType;
      exports.DOMException = DOMException;
      exports.DOMImplementation = DOMImplementation;
      exports.Element = Element;
      exports.Node = Node;
      exports.NodeList = NodeList;
      exports.XMLSerializer = XMLSerializer2;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/entities.js
  var require_entities = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
      "use strict";
      var freeze = require_conventions().freeze;
      exports.XML_ENTITIES = freeze({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"'
      });
      exports.HTML_ENTITIES = freeze({
        Aacute: "\xC1",
        aacute: "\xE1",
        Abreve: "\u0102",
        abreve: "\u0103",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        Acy: "\u0410",
        acy: "\u0430",
        AElig: "\xC6",
        aelig: "\xE6",
        af: "\u2061",
        Afr: "\u{1D504}",
        afr: "\u{1D51E}",
        Agrave: "\xC0",
        agrave: "\xE0",
        alefsym: "\u2135",
        aleph: "\u2135",
        Alpha: "\u0391",
        alpha: "\u03B1",
        Amacr: "\u0100",
        amacr: "\u0101",
        amalg: "\u2A3F",
        AMP: "&",
        amp: "&",
        And: "\u2A53",
        and: "\u2227",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        Aogon: "\u0104",
        aogon: "\u0105",
        Aopf: "\u{1D538}",
        aopf: "\u{1D552}",
        ap: "\u2248",
        apacir: "\u2A6F",
        apE: "\u2A70",
        ape: "\u224A",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        Aring: "\xC5",
        aring: "\xE5",
        Ascr: "\u{1D49C}",
        ascr: "\u{1D4B6}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        Atilde: "\xC3",
        atilde: "\xE3",
        Auml: "\xC4",
        auml: "\xE4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        Barwed: "\u2306",
        barwed: "\u2305",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        Bcy: "\u0411",
        bcy: "\u0431",
        bdquo: "\u201E",
        becaus: "\u2235",
        Because: "\u2235",
        because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        Beta: "\u0392",
        beta: "\u03B2",
        beth: "\u2136",
        between: "\u226C",
        Bfr: "\u{1D505}",
        bfr: "\u{1D51F}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bNot: "\u2AED",
        bnot: "\u2310",
        Bopf: "\u{1D539}",
        bopf: "\u{1D553}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxDL: "\u2557",
        boxDl: "\u2556",
        boxdL: "\u2555",
        boxdl: "\u2510",
        boxDR: "\u2554",
        boxDr: "\u2553",
        boxdR: "\u2552",
        boxdr: "\u250C",
        boxH: "\u2550",
        boxh: "\u2500",
        boxHD: "\u2566",
        boxHd: "\u2564",
        boxhD: "\u2565",
        boxhd: "\u252C",
        boxHU: "\u2569",
        boxHu: "\u2567",
        boxhU: "\u2568",
        boxhu: "\u2534",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxUL: "\u255D",
        boxUl: "\u255C",
        boxuL: "\u255B",
        boxul: "\u2518",
        boxUR: "\u255A",
        boxUr: "\u2559",
        boxuR: "\u2558",
        boxur: "\u2514",
        boxV: "\u2551",
        boxv: "\u2502",
        boxVH: "\u256C",
        boxVh: "\u256B",
        boxvH: "\u256A",
        boxvh: "\u253C",
        boxVL: "\u2563",
        boxVl: "\u2562",
        boxvL: "\u2561",
        boxvl: "\u2524",
        boxVR: "\u2560",
        boxVr: "\u255F",
        boxvR: "\u255E",
        boxvr: "\u251C",
        bprime: "\u2035",
        Breve: "\u02D8",
        breve: "\u02D8",
        brvbar: "\xA6",
        Bscr: "\u212C",
        bscr: "\u{1D4B7}",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpE: "\u2AAE",
        bumpe: "\u224F",
        Bumpeq: "\u224E",
        bumpeq: "\u224F",
        Cacute: "\u0106",
        cacute: "\u0107",
        Cap: "\u22D2",
        cap: "\u2229",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        Ccaron: "\u010C",
        ccaron: "\u010D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        Ccirc: "\u0108",
        ccirc: "\u0109",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        Cdot: "\u010A",
        cdot: "\u010B",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        CenterDot: "\xB7",
        centerdot: "\xB7",
        Cfr: "\u212D",
        cfr: "\u{1D520}",
        CHcy: "\u0427",
        chcy: "\u0447",
        check: "\u2713",
        checkmark: "\u2713",
        Chi: "\u03A7",
        chi: "\u03C7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cirE: "\u29C3",
        cire: "\u2257",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        Colon: "\u2237",
        colon: ":",
        Colone: "\u2A74",
        colone: "\u2254",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        Conint: "\u222F",
        conint: "\u222E",
        ContourIntegral: "\u222E",
        Copf: "\u2102",
        copf: "\u{1D554}",
        coprod: "\u2210",
        Coproduct: "\u2210",
        COPY: "\xA9",
        copy: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        Cross: "\u2A2F",
        cross: "\u2717",
        Cscr: "\u{1D49E}",
        cscr: "\u{1D4B8}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        Cup: "\u22D3",
        cup: "\u222A",
        cupbrcap: "\u2A48",
        CupCap: "\u224D",
        cupcap: "\u2A46",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        Dagger: "\u2021",
        dagger: "\u2020",
        daleth: "\u2138",
        Darr: "\u21A1",
        dArr: "\u21D3",
        darr: "\u2193",
        dash: "\u2010",
        Dashv: "\u2AE4",
        dashv: "\u22A3",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        Dcaron: "\u010E",
        dcaron: "\u010F",
        Dcy: "\u0414",
        dcy: "\u0434",
        DD: "\u2145",
        dd: "\u2146",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        Delta: "\u0394",
        delta: "\u03B4",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        Dfr: "\u{1D507}",
        dfr: "\u{1D521}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        Diamond: "\u22C4",
        diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        DJcy: "\u0402",
        djcy: "\u0452",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        Dopf: "\u{1D53B}",
        dopf: "\u{1D555}",
        Dot: "\xA8",
        dot: "\u02D9",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        DownArrow: "\u2193",
        Downarrow: "\u21D3",
        downarrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        Dscr: "\u{1D49F}",
        dscr: "\u{1D4B9}",
        DScy: "\u0405",
        dscy: "\u0455",
        dsol: "\u29F6",
        Dstrok: "\u0110",
        dstrok: "\u0111",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        DZcy: "\u040F",
        dzcy: "\u045F",
        dzigrarr: "\u27FF",
        Eacute: "\xC9",
        eacute: "\xE9",
        easter: "\u2A6E",
        Ecaron: "\u011A",
        ecaron: "\u011B",
        ecir: "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        ecolon: "\u2255",
        Ecy: "\u042D",
        ecy: "\u044D",
        eDDot: "\u2A77",
        Edot: "\u0116",
        eDot: "\u2251",
        edot: "\u0117",
        ee: "\u2147",
        efDot: "\u2252",
        Efr: "\u{1D508}",
        efr: "\u{1D522}",
        eg: "\u2A9A",
        Egrave: "\xC8",
        egrave: "\xE8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        Emacr: "\u0112",
        emacr: "\u0113",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        ENG: "\u014A",
        eng: "\u014B",
        ensp: "\u2002",
        Eogon: "\u0118",
        eogon: "\u0119",
        Eopf: "\u{1D53C}",
        eopf: "\u{1D556}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        Epsilon: "\u0395",
        epsilon: "\u03B5",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        Escr: "\u2130",
        escr: "\u212F",
        esdot: "\u2250",
        Esim: "\u2A73",
        esim: "\u2242",
        Eta: "\u0397",
        eta: "\u03B7",
        ETH: "\xD0",
        eth: "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        ExponentialE: "\u2147",
        exponentiale: "\u2147",
        fallingdotseq: "\u2252",
        Fcy: "\u0424",
        fcy: "\u0444",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        Ffr: "\u{1D509}",
        ffr: "\u{1D523}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        Fopf: "\u{1D53D}",
        fopf: "\u{1D557}",
        ForAll: "\u2200",
        forall: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        Fscr: "\u2131",
        fscr: "\u{1D4BB}",
        gacute: "\u01F5",
        Gamma: "\u0393",
        gamma: "\u03B3",
        Gammad: "\u03DC",
        gammad: "\u03DD",
        gap: "\u2A86",
        Gbreve: "\u011E",
        gbreve: "\u011F",
        Gcedil: "\u0122",
        Gcirc: "\u011C",
        gcirc: "\u011D",
        Gcy: "\u0413",
        gcy: "\u0433",
        Gdot: "\u0120",
        gdot: "\u0121",
        gE: "\u2267",
        ge: "\u2265",
        gEl: "\u2A8C",
        gel: "\u22DB",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        Gfr: "\u{1D50A}",
        gfr: "\u{1D524}",
        Gg: "\u22D9",
        gg: "\u226B",
        ggg: "\u22D9",
        gimel: "\u2137",
        GJcy: "\u0403",
        gjcy: "\u0453",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gnE: "\u2269",
        gne: "\u2A88",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        Gopf: "\u{1D53E}",
        gopf: "\u{1D558}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        Gscr: "\u{1D4A2}",
        gscr: "\u210A",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        Gt: "\u226B",
        GT: ">",
        gt: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        HARDcy: "\u042A",
        hardcy: "\u044A",
        hArr: "\u21D4",
        harr: "\u2194",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        Hcirc: "\u0124",
        hcirc: "\u0125",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        Hfr: "\u210C",
        hfr: "\u{1D525}",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        Hopf: "\u210D",
        hopf: "\u{1D559}",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        Hscr: "\u210B",
        hscr: "\u{1D4BD}",
        hslash: "\u210F",
        Hstrok: "\u0126",
        hstrok: "\u0127",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        Iacute: "\xCD",
        iacute: "\xED",
        ic: "\u2063",
        Icirc: "\xCE",
        icirc: "\xEE",
        Icy: "\u0418",
        icy: "\u0438",
        Idot: "\u0130",
        IEcy: "\u0415",
        iecy: "\u0435",
        iexcl: "\xA1",
        iff: "\u21D4",
        Ifr: "\u2111",
        ifr: "\u{1D526}",
        Igrave: "\xCC",
        igrave: "\xEC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        IJlig: "\u0132",
        ijlig: "\u0133",
        Im: "\u2111",
        Imacr: "\u012A",
        imacr: "\u012B",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        Int: "\u222C",
        int: "\u222B",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        IOcy: "\u0401",
        iocy: "\u0451",
        Iogon: "\u012E",
        iogon: "\u012F",
        Iopf: "\u{1D540}",
        iopf: "\u{1D55A}",
        Iota: "\u0399",
        iota: "\u03B9",
        iprod: "\u2A3C",
        iquest: "\xBF",
        Iscr: "\u2110",
        iscr: "\u{1D4BE}",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        Itilde: "\u0128",
        itilde: "\u0129",
        Iukcy: "\u0406",
        iukcy: "\u0456",
        Iuml: "\xCF",
        iuml: "\xEF",
        Jcirc: "\u0134",
        jcirc: "\u0135",
        Jcy: "\u0419",
        jcy: "\u0439",
        Jfr: "\u{1D50D}",
        jfr: "\u{1D527}",
        jmath: "\u0237",
        Jopf: "\u{1D541}",
        jopf: "\u{1D55B}",
        Jscr: "\u{1D4A5}",
        jscr: "\u{1D4BF}",
        Jsercy: "\u0408",
        jsercy: "\u0458",
        Jukcy: "\u0404",
        jukcy: "\u0454",
        Kappa: "\u039A",
        kappa: "\u03BA",
        kappav: "\u03F0",
        Kcedil: "\u0136",
        kcedil: "\u0137",
        Kcy: "\u041A",
        kcy: "\u043A",
        Kfr: "\u{1D50E}",
        kfr: "\u{1D528}",
        kgreen: "\u0138",
        KHcy: "\u0425",
        khcy: "\u0445",
        KJcy: "\u040C",
        kjcy: "\u045C",
        Kopf: "\u{1D542}",
        kopf: "\u{1D55C}",
        Kscr: "\u{1D4A6}",
        kscr: "\u{1D4C0}",
        lAarr: "\u21DA",
        Lacute: "\u0139",
        lacute: "\u013A",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        Lambda: "\u039B",
        lambda: "\u03BB",
        Lang: "\u27EA",
        lang: "\u27E8",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        Larr: "\u219E",
        lArr: "\u21D0",
        larr: "\u2190",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        lAtail: "\u291B",
        latail: "\u2919",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lBarr: "\u290E",
        lbarr: "\u290C",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        Lcaron: "\u013D",
        lcaron: "\u013E",
        Lcedil: "\u013B",
        lcedil: "\u013C",
        lceil: "\u2308",
        lcub: "{",
        Lcy: "\u041B",
        lcy: "\u043B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        lE: "\u2266",
        le: "\u2264",
        LeftAngleBracket: "\u27E8",
        LeftArrow: "\u2190",
        Leftarrow: "\u21D0",
        leftarrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        LeftRightArrow: "\u2194",
        Leftrightarrow: "\u21D4",
        leftrightarrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        lEg: "\u2A8B",
        leg: "\u22DA",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        Lfr: "\u{1D50F}",
        lfr: "\u{1D529}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        LJcy: "\u0409",
        ljcy: "\u0459",
        Ll: "\u22D8",
        ll: "\u226A",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        Lmidot: "\u013F",
        lmidot: "\u0140",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lnE: "\u2268",
        lne: "\u2A87",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        LongLeftArrow: "\u27F5",
        Longleftarrow: "\u27F8",
        longleftarrow: "\u27F5",
        LongLeftRightArrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        longleftrightarrow: "\u27F7",
        longmapsto: "\u27FC",
        LongRightArrow: "\u27F6",
        Longrightarrow: "\u27F9",
        longrightarrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        Lopf: "\u{1D543}",
        lopf: "\u{1D55D}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        Lscr: "\u2112",
        lscr: "\u{1D4C1}",
        Lsh: "\u21B0",
        lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        Lstrok: "\u0141",
        lstrok: "\u0142",
        Lt: "\u226A",
        LT: "<",
        lt: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        Map: "\u2905",
        map: "\u21A6",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        Mcy: "\u041C",
        mcy: "\u043C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        Mfr: "\u{1D510}",
        mfr: "\u{1D52A}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        Mopf: "\u{1D544}",
        mopf: "\u{1D55E}",
        mp: "\u2213",
        Mscr: "\u2133",
        mscr: "\u{1D4C2}",
        mstpos: "\u223E",
        Mu: "\u039C",
        mu: "\u03BC",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        Nacute: "\u0143",
        nacute: "\u0144",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        Ncaron: "\u0147",
        ncaron: "\u0148",
        Ncedil: "\u0145",
        ncedil: "\u0146",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        Ncy: "\u041D",
        ncy: "\u043D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        neArr: "\u21D7",
        nearr: "\u2197",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        Nfr: "\u{1D511}",
        nfr: "\u{1D52B}",
        ngE: "\u2267\u0338",
        nge: "\u2271",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        nGt: "\u226B\u20D2",
        ngt: "\u226F",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nhArr: "\u21CE",
        nharr: "\u21AE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        NJcy: "\u040A",
        njcy: "\u045A",
        nlArr: "\u21CD",
        nlarr: "\u219A",
        nldr: "\u2025",
        nlE: "\u2266\u0338",
        nle: "\u2270",
        nLeftarrow: "\u21CD",
        nleftarrow: "\u219A",
        nLeftrightarrow: "\u21CE",
        nleftrightarrow: "\u21AE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nLt: "\u226A\u20D2",
        nlt: "\u226E",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        Nopf: "\u2115",
        nopf: "\u{1D55F}",
        Not: "\u2AEC",
        not: "\xAC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrArr: "\u21CF",
        nrarr: "\u219B",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nRightarrow: "\u21CF",
        nrightarrow: "\u219B",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        Nscr: "\u{1D4A9}",
        nscr: "\u{1D4C3}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsubE: "\u2AC5\u0338",
        nsube: "\u2288",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupE: "\u2AC6\u0338",
        nsupe: "\u2289",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        Nu: "\u039D",
        nu: "\u03BD",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nVDash: "\u22AF",
        nVdash: "\u22AE",
        nvDash: "\u22AD",
        nvdash: "\u22AC",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwArr: "\u21D6",
        nwarr: "\u2196",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        Oacute: "\xD3",
        oacute: "\xF3",
        oast: "\u229B",
        ocir: "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        Ocy: "\u041E",
        ocy: "\u043E",
        odash: "\u229D",
        Odblac: "\u0150",
        odblac: "\u0151",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        OElig: "\u0152",
        oelig: "\u0153",
        ofcir: "\u29BF",
        Ofr: "\u{1D512}",
        ofr: "\u{1D52C}",
        ogon: "\u02DB",
        Ograve: "\xD2",
        ograve: "\xF2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        Omacr: "\u014C",
        omacr: "\u014D",
        Omega: "\u03A9",
        omega: "\u03C9",
        Omicron: "\u039F",
        omicron: "\u03BF",
        omid: "\u29B6",
        ominus: "\u2296",
        Oopf: "\u{1D546}",
        oopf: "\u{1D560}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        Or: "\u2A54",
        or: "\u2228",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        Oscr: "\u{1D4AA}",
        oscr: "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        osol: "\u2298",
        Otilde: "\xD5",
        otilde: "\xF5",
        Otimes: "\u2A37",
        otimes: "\u2297",
        otimesas: "\u2A36",
        Ouml: "\xD6",
        ouml: "\xF6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        Pcy: "\u041F",
        pcy: "\u043F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        Pfr: "\u{1D513}",
        pfr: "\u{1D52D}",
        Phi: "\u03A6",
        phi: "\u03C6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        Pi: "\u03A0",
        pi: "\u03C0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        Popf: "\u2119",
        popf: "\u{1D561}",
        pound: "\xA3",
        Pr: "\u2ABB",
        pr: "\u227A",
        prap: "\u2AB7",
        prcue: "\u227C",
        prE: "\u2AB3",
        pre: "\u2AAF",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        Prime: "\u2033",
        prime: "\u2032",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        Pscr: "\u{1D4AB}",
        pscr: "\u{1D4C5}",
        Psi: "\u03A8",
        psi: "\u03C8",
        puncsp: "\u2008",
        Qfr: "\u{1D514}",
        qfr: "\u{1D52E}",
        qint: "\u2A0C",
        Qopf: "\u211A",
        qopf: "\u{1D562}",
        qprime: "\u2057",
        Qscr: "\u{1D4AC}",
        qscr: "\u{1D4C6}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        QUOT: '"',
        quot: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        Racute: "\u0154",
        racute: "\u0155",
        radic: "\u221A",
        raemptyv: "\u29B3",
        Rang: "\u27EB",
        rang: "\u27E9",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        Rarr: "\u21A0",
        rArr: "\u21D2",
        rarr: "\u2192",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        Rarrtl: "\u2916",
        rarrtl: "\u21A3",
        rarrw: "\u219D",
        rAtail: "\u291C",
        ratail: "\u291A",
        ratio: "\u2236",
        rationals: "\u211A",
        RBarr: "\u2910",
        rBarr: "\u290F",
        rbarr: "\u290D",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        Rcaron: "\u0158",
        rcaron: "\u0159",
        Rcedil: "\u0156",
        rcedil: "\u0157",
        rceil: "\u2309",
        rcub: "}",
        Rcy: "\u0420",
        rcy: "\u0440",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        REG: "\xAE",
        reg: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        Rfr: "\u211C",
        rfr: "\u{1D52F}",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        Rho: "\u03A1",
        rho: "\u03C1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        RightArrow: "\u2192",
        Rightarrow: "\u21D2",
        rightarrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        Ropf: "\u211D",
        ropf: "\u{1D563}",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        Rscr: "\u211B",
        rscr: "\u{1D4C7}",
        Rsh: "\u21B1",
        rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        Sacute: "\u015A",
        sacute: "\u015B",
        sbquo: "\u201A",
        Sc: "\u2ABC",
        sc: "\u227B",
        scap: "\u2AB8",
        Scaron: "\u0160",
        scaron: "\u0161",
        sccue: "\u227D",
        scE: "\u2AB4",
        sce: "\u2AB0",
        Scedil: "\u015E",
        scedil: "\u015F",
        Scirc: "\u015C",
        scirc: "\u015D",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        Scy: "\u0421",
        scy: "\u0441",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        seArr: "\u21D8",
        searr: "\u2198",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        Sfr: "\u{1D516}",
        sfr: "\u{1D530}",
        sfrown: "\u2322",
        sharp: "\u266F",
        SHCHcy: "\u0429",
        shchcy: "\u0449",
        SHcy: "\u0428",
        shcy: "\u0448",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        Sigma: "\u03A3",
        sigma: "\u03C3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        SOFTcy: "\u042C",
        softcy: "\u044C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        Sopf: "\u{1D54A}",
        sopf: "\u{1D564}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        Square: "\u25A1",
        square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        Sscr: "\u{1D4AE}",
        sscr: "\u{1D4C8}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        Star: "\u22C6",
        star: "\u2606",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        Sub: "\u22D0",
        sub: "\u2282",
        subdot: "\u2ABD",
        subE: "\u2AC5",
        sube: "\u2286",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subnE: "\u2ACB",
        subne: "\u228A",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        Subset: "\u22D0",
        subset: "\u2282",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        Sum: "\u2211",
        sum: "\u2211",
        sung: "\u266A",
        Sup: "\u22D1",
        sup: "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supE: "\u2AC6",
        supe: "\u2287",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supnE: "\u2ACC",
        supne: "\u228B",
        supplus: "\u2AC0",
        Supset: "\u22D1",
        supset: "\u2283",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swArr: "\u21D9",
        swarr: "\u2199",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        Tau: "\u03A4",
        tau: "\u03C4",
        tbrk: "\u23B4",
        Tcaron: "\u0164",
        tcaron: "\u0165",
        Tcedil: "\u0162",
        tcedil: "\u0163",
        Tcy: "\u0422",
        tcy: "\u0442",
        tdot: "\u20DB",
        telrec: "\u2315",
        Tfr: "\u{1D517}",
        tfr: "\u{1D531}",
        there4: "\u2234",
        Therefore: "\u2234",
        therefore: "\u2234",
        Theta: "\u0398",
        theta: "\u03B8",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        THORN: "\xDE",
        thorn: "\xFE",
        Tilde: "\u223C",
        tilde: "\u02DC",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        Topf: "\u{1D54B}",
        topf: "\u{1D565}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        TRADE: "\u2122",
        trade: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        Tscr: "\u{1D4AF}",
        tscr: "\u{1D4C9}",
        TScy: "\u0426",
        tscy: "\u0446",
        TSHcy: "\u040B",
        tshcy: "\u045B",
        Tstrok: "\u0166",
        tstrok: "\u0167",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        Uacute: "\xDA",
        uacute: "\xFA",
        Uarr: "\u219F",
        uArr: "\u21D1",
        uarr: "\u2191",
        Uarrocir: "\u2949",
        Ubrcy: "\u040E",
        ubrcy: "\u045E",
        Ubreve: "\u016C",
        ubreve: "\u016D",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        Ucy: "\u0423",
        ucy: "\u0443",
        udarr: "\u21C5",
        Udblac: "\u0170",
        udblac: "\u0171",
        udhar: "\u296E",
        ufisht: "\u297E",
        Ufr: "\u{1D518}",
        ufr: "\u{1D532}",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        Umacr: "\u016A",
        umacr: "\u016B",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        Uogon: "\u0172",
        uogon: "\u0173",
        Uopf: "\u{1D54C}",
        uopf: "\u{1D566}",
        UpArrow: "\u2191",
        Uparrow: "\u21D1",
        uparrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        UpDownArrow: "\u2195",
        Updownarrow: "\u21D5",
        updownarrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        Upsi: "\u03D2",
        upsi: "\u03C5",
        upsih: "\u03D2",
        Upsilon: "\u03A5",
        upsilon: "\u03C5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        Uring: "\u016E",
        uring: "\u016F",
        urtri: "\u25F9",
        Uscr: "\u{1D4B0}",
        uscr: "\u{1D4CA}",
        utdot: "\u22F0",
        Utilde: "\u0168",
        utilde: "\u0169",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        Uuml: "\xDC",
        uuml: "\xFC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        vArr: "\u21D5",
        varr: "\u2195",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        Vbar: "\u2AEB",
        vBar: "\u2AE8",
        vBarv: "\u2AE9",
        Vcy: "\u0412",
        vcy: "\u0432",
        VDash: "\u22AB",
        Vdash: "\u22A9",
        vDash: "\u22A8",
        vdash: "\u22A2",
        Vdashl: "\u2AE6",
        Vee: "\u22C1",
        vee: "\u2228",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        Verbar: "\u2016",
        verbar: "|",
        Vert: "\u2016",
        vert: "|",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        Vfr: "\u{1D519}",
        vfr: "\u{1D533}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        Vopf: "\u{1D54D}",
        vopf: "\u{1D567}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        Vscr: "\u{1D4B1}",
        vscr: "\u{1D4CB}",
        vsubnE: "\u2ACB\uFE00",
        vsubne: "\u228A\uFE00",
        vsupnE: "\u2ACC\uFE00",
        vsupne: "\u228B\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        Wcirc: "\u0174",
        wcirc: "\u0175",
        wedbar: "\u2A5F",
        Wedge: "\u22C0",
        wedge: "\u2227",
        wedgeq: "\u2259",
        weierp: "\u2118",
        Wfr: "\u{1D51A}",
        wfr: "\u{1D534}",
        Wopf: "\u{1D54E}",
        wopf: "\u{1D568}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        Wscr: "\u{1D4B2}",
        wscr: "\u{1D4CC}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        Xfr: "\u{1D51B}",
        xfr: "\u{1D535}",
        xhArr: "\u27FA",
        xharr: "\u27F7",
        Xi: "\u039E",
        xi: "\u03BE",
        xlArr: "\u27F8",
        xlarr: "\u27F5",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        Xopf: "\u{1D54F}",
        xopf: "\u{1D569}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrArr: "\u27F9",
        xrarr: "\u27F6",
        Xscr: "\u{1D4B3}",
        xscr: "\u{1D4CD}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        Yacute: "\xDD",
        yacute: "\xFD",
        YAcy: "\u042F",
        yacy: "\u044F",
        Ycirc: "\u0176",
        ycirc: "\u0177",
        Ycy: "\u042B",
        ycy: "\u044B",
        yen: "\xA5",
        Yfr: "\u{1D51C}",
        yfr: "\u{1D536}",
        YIcy: "\u0407",
        yicy: "\u0457",
        Yopf: "\u{1D550}",
        yopf: "\u{1D56A}",
        Yscr: "\u{1D4B4}",
        yscr: "\u{1D4CE}",
        YUcy: "\u042E",
        yucy: "\u044E",
        Yuml: "\u0178",
        yuml: "\xFF",
        Zacute: "\u0179",
        zacute: "\u017A",
        Zcaron: "\u017D",
        zcaron: "\u017E",
        Zcy: "\u0417",
        zcy: "\u0437",
        Zdot: "\u017B",
        zdot: "\u017C",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        Zeta: "\u0396",
        zeta: "\u03B6",
        Zfr: "\u2128",
        zfr: "\u{1D537}",
        ZHcy: "\u0416",
        zhcy: "\u0436",
        zigrarr: "\u21DD",
        Zopf: "\u2124",
        zopf: "\u{1D56B}",
        Zscr: "\u{1D4B5}",
        zscr: "\u{1D4CF}",
        zwj: "\u200D",
        zwnj: "\u200C"
      });
      exports.entityMap = exports.HTML_ENTITIES;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/sax.js
  var require_sax = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
      var NAMESPACE = require_conventions().NAMESPACE;
      var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
      var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
      var S_TAG = 0;
      var S_ATTR = 1;
      var S_ATTR_SPACE = 2;
      var S_EQ = 3;
      var S_ATTR_NOQUOT_VALUE = 4;
      var S_ATTR_END = 5;
      var S_TAG_SPACE = 6;
      var S_TAG_CLOSE = 7;
      function ParseError(message, locator) {
        this.message = message;
        this.locator = locator;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ParseError);
      }
      ParseError.prototype = new Error();
      ParseError.prototype.name = ParseError.name;
      function XMLReader() {
      }
      XMLReader.prototype = {
        parse: function(source7, defaultNSMap, entityMap) {
          var domBuilder = this.domBuilder;
          domBuilder.startDocument();
          _copy3(defaultNSMap, defaultNSMap = {});
          parse2(
            source7,
            defaultNSMap,
            entityMap,
            domBuilder,
            this.errorHandler
          );
          domBuilder.endDocument();
        }
      };
      function parse2(source7, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
        function fixedFromCharCode(code) {
          if (code > 65535) {
            code -= 65536;
            var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
            return String.fromCharCode(surrogate1, surrogate2);
          } else {
            return String.fromCharCode(code);
          }
        }
        function entityReplacer(a3) {
          var k2 = a3.slice(1, -1);
          if (Object.hasOwnProperty.call(entityMap, k2)) {
            return entityMap[k2];
          } else if (k2.charAt(0) === "#") {
            return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
          } else {
            errorHandler.error("entity not found:" + a3);
            return a3;
          }
        }
        function appendText(end2) {
          if (end2 > start) {
            var xt = source7.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
            locator && position(start);
            domBuilder.characters(xt, 0, end2 - start);
            start = end2;
          }
        }
        function position(p3, m2) {
          while (p3 >= lineEnd && (m2 = linePattern.exec(source7))) {
            lineStart = m2.index;
            lineEnd = lineStart + m2[0].length;
            locator.lineNumber++;
          }
          locator.columnNumber = p3 - lineStart + 1;
        }
        var lineStart = 0;
        var lineEnd = 0;
        var linePattern = /.*(?:\r\n?|\n)|.*$/g;
        var locator = domBuilder.locator;
        var parseStack = [{ currentNSMap: defaultNSMapCopy }];
        var closeMap = {};
        var start = 0;
        while (true) {
          try {
            var tagStart = source7.indexOf("<", start);
            if (tagStart < 0) {
              if (!source7.substr(start).match(/^\s*$/)) {
                var doc = domBuilder.doc;
                var text = doc.createTextNode(source7.substr(start));
                doc.appendChild(text);
                domBuilder.currentElement = text;
              }
              return;
            }
            if (tagStart > start) {
              appendText(tagStart);
            }
            switch (source7.charAt(tagStart + 1)) {
              case "/":
                var end = source7.indexOf(">", tagStart + 3);
                var tagName = source7.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                var config3 = parseStack.pop();
                if (end < 0) {
                  tagName = source7.substring(tagStart + 2).replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " is not complete:" + config3.tagName);
                  end = tagStart + 1 + tagName.length;
                } else if (tagName.match(/\s</)) {
                  tagName = tagName.replace(/[\s<].*/, "");
                  errorHandler.error("end tag name: " + tagName + " maybe not complete");
                  end = tagStart + 1 + tagName.length;
                }
                var localNSMap = config3.localNSMap;
                var endMatch = config3.tagName == tagName;
                var endIgnoreCaseMach = endMatch || config3.tagName && config3.tagName.toLowerCase() == tagName.toLowerCase();
                if (endIgnoreCaseMach) {
                  domBuilder.endElement(config3.uri, config3.localName, tagName);
                  if (localNSMap) {
                    for (var prefix in localNSMap) {
                      if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                        domBuilder.endPrefixMapping(prefix);
                      }
                    }
                  }
                  if (!endMatch) {
                    errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config3.tagName);
                  }
                } else {
                  parseStack.push(config3);
                }
                end++;
                break;
              case "?":
                locator && position(tagStart);
                end = parseInstruction(source7, tagStart, domBuilder);
                break;
              case "!":
                locator && position(tagStart);
                end = parseDCC(source7, tagStart, domBuilder, errorHandler);
                break;
              default:
                locator && position(tagStart);
                var el = new ElementAttributes();
                var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                var end = parseElementStartPart(source7, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                var len = el.length;
                if (!el.closed && fixSelfClosed(source7, end, el.tagName, closeMap)) {
                  el.closed = true;
                  if (!entityMap.nbsp) {
                    errorHandler.warning("unclosed xml attribute");
                  }
                }
                if (locator && len) {
                  var locator2 = copyLocator(locator, {});
                  for (var i3 = 0; i3 < len; i3++) {
                    var a2 = el[i3];
                    position(a2.offset);
                    a2.locator = copyLocator(locator, {});
                  }
                  domBuilder.locator = locator2;
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                  domBuilder.locator = locator;
                } else {
                  if (appendElement(el, domBuilder, currentNSMap)) {
                    parseStack.push(el);
                  }
                }
                if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                  end = parseHtmlSpecialContent(source7, end, el.tagName, entityReplacer, domBuilder);
                } else {
                  end++;
                }
            }
          } catch (e2) {
            if (e2 instanceof ParseError) {
              throw e2;
            }
            errorHandler.error("element parse error: " + e2);
            end = -1;
          }
          if (end > start) {
            start = end;
          } else {
            appendText(Math.max(tagStart, start) + 1);
          }
        }
      }
      function copyLocator(f2, t2) {
        t2.lineNumber = f2.lineNumber;
        t2.columnNumber = f2.columnNumber;
        return t2;
      }
      function parseElementStartPart(source7, start, el, currentNSMap, entityReplacer, errorHandler) {
        function addAttribute(qname, value2, startIndex) {
          if (el.attributeNames.hasOwnProperty(qname)) {
            errorHandler.fatalError("Attribute " + qname + " redefined");
          }
          el.addValue(
            qname,
            // @see https://www.w3.org/TR/xml/#AVNormalize
            // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
            // - recursive replacement of (DTD) entity references
            // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
            value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
            startIndex
          );
        }
        var attrName;
        var value;
        var p3 = ++start;
        var s2 = S_TAG;
        while (true) {
          var c2 = source7.charAt(p3);
          switch (c2) {
            case "=":
              if (s2 === S_ATTR) {
                attrName = source7.slice(start, p3);
                s2 = S_EQ;
              } else if (s2 === S_ATTR_SPACE) {
                s2 = S_EQ;
              } else {
                throw new Error("attribute equal must after attrName");
              }
              break;
            case "'":
            case '"':
              if (s2 === S_EQ || s2 === S_ATTR) {
                if (s2 === S_ATTR) {
                  errorHandler.warning('attribute value must after "="');
                  attrName = source7.slice(start, p3);
                }
                start = p3 + 1;
                p3 = source7.indexOf(c2, start);
                if (p3 > 0) {
                  value = source7.slice(start, p3);
                  addAttribute(attrName, value, start - 1);
                  s2 = S_ATTR_END;
                } else {
                  throw new Error("attribute value no end '" + c2 + "' match");
                }
              } else if (s2 == S_ATTR_NOQUOT_VALUE) {
                value = source7.slice(start, p3);
                addAttribute(attrName, value, start);
                errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
                start = p3 + 1;
                s2 = S_ATTR_END;
              } else {
                throw new Error('attribute value must after "="');
              }
              break;
            case "/":
              switch (s2) {
                case S_TAG:
                  el.setTagName(source7.slice(start, p3));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  s2 = S_TAG_CLOSE;
                  el.closed = true;
                case S_ATTR_NOQUOT_VALUE:
                case S_ATTR:
                  break;
                case S_ATTR_SPACE:
                  el.closed = true;
                  break;
                default:
                  throw new Error("attribute invalid close char('/')");
              }
              break;
            case "":
              errorHandler.error("unexpected end of input");
              if (s2 == S_TAG) {
                el.setTagName(source7.slice(start, p3));
              }
              return p3;
            case ">":
              switch (s2) {
                case S_TAG:
                  el.setTagName(source7.slice(start, p3));
                case S_ATTR_END:
                case S_TAG_SPACE:
                case S_TAG_CLOSE:
                  break;
                case S_ATTR_NOQUOT_VALUE:
                case S_ATTR:
                  value = source7.slice(start, p3);
                  if (value.slice(-1) === "/") {
                    el.closed = true;
                    value = value.slice(0, -1);
                  }
                case S_ATTR_SPACE:
                  if (s2 === S_ATTR_SPACE) {
                    value = attrName;
                  }
                  if (s2 == S_ATTR_NOQUOT_VALUE) {
                    errorHandler.warning('attribute "' + value + '" missed quot(")!');
                    addAttribute(attrName, value, start);
                  } else {
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                    }
                    addAttribute(value, value, start);
                  }
                  break;
                case S_EQ:
                  throw new Error("attribute value missed!!");
              }
              return p3;
            case "\x80":
              c2 = " ";
            default:
              if (c2 <= " ") {
                switch (s2) {
                  case S_TAG:
                    el.setTagName(source7.slice(start, p3));
                    s2 = S_TAG_SPACE;
                    break;
                  case S_ATTR:
                    attrName = source7.slice(start, p3);
                    s2 = S_ATTR_SPACE;
                    break;
                  case S_ATTR_NOQUOT_VALUE:
                    var value = source7.slice(start, p3);
                    errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                    addAttribute(attrName, value, start);
                  case S_ATTR_END:
                    s2 = S_TAG_SPACE;
                    break;
                }
              } else {
                switch (s2) {
                  case S_ATTR_SPACE:
                    var tagName = el.tagName;
                    if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                      errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                    }
                    addAttribute(attrName, attrName, start);
                    start = p3;
                    s2 = S_ATTR;
                    break;
                  case S_ATTR_END:
                    errorHandler.warning('attribute space is required"' + attrName + '"!!');
                  case S_TAG_SPACE:
                    s2 = S_ATTR;
                    start = p3;
                    break;
                  case S_EQ:
                    s2 = S_ATTR_NOQUOT_VALUE;
                    start = p3;
                    break;
                  case S_TAG_CLOSE:
                    throw new Error("elements closed character '/' and '>' must be connected to");
                }
              }
          }
          p3++;
        }
      }
      function appendElement(el, domBuilder, currentNSMap) {
        var tagName = el.tagName;
        var localNSMap = null;
        var i3 = el.length;
        while (i3--) {
          var a2 = el[i3];
          var qName = a2.qName;
          var value = a2.value;
          var nsp = qName.indexOf(":");
          if (nsp > 0) {
            var prefix = a2.prefix = qName.slice(0, nsp);
            var localName = qName.slice(nsp + 1);
            var nsPrefix = prefix === "xmlns" && localName;
          } else {
            localName = qName;
            prefix = null;
            nsPrefix = qName === "xmlns" && "";
          }
          a2.localName = localName;
          if (nsPrefix !== false) {
            if (localNSMap == null) {
              localNSMap = {};
              _copy3(currentNSMap, currentNSMap = {});
            }
            currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
            a2.uri = NAMESPACE.XMLNS;
            domBuilder.startPrefixMapping(nsPrefix, value);
          }
        }
        var i3 = el.length;
        while (i3--) {
          a2 = el[i3];
          var prefix = a2.prefix;
          if (prefix) {
            if (prefix === "xml") {
              a2.uri = NAMESPACE.XML;
            }
            if (prefix !== "xmlns") {
              a2.uri = currentNSMap[prefix || ""];
            }
          }
        }
        var nsp = tagName.indexOf(":");
        if (nsp > 0) {
          prefix = el.prefix = tagName.slice(0, nsp);
          localName = el.localName = tagName.slice(nsp + 1);
        } else {
          prefix = null;
          localName = el.localName = tagName;
        }
        var ns = el.uri = currentNSMap[prefix || ""];
        domBuilder.startElement(ns, localName, tagName, el);
        if (el.closed) {
          domBuilder.endElement(ns, localName, tagName);
          if (localNSMap) {
            for (prefix in localNSMap) {
              if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                domBuilder.endPrefixMapping(prefix);
              }
            }
          }
        } else {
          el.currentNSMap = currentNSMap;
          el.localNSMap = localNSMap;
          return true;
        }
      }
      function parseHtmlSpecialContent(source7, elStartEnd, tagName, entityReplacer, domBuilder) {
        if (/^(?:script|textarea)$/i.test(tagName)) {
          var elEndStart = source7.indexOf("</" + tagName + ">", elStartEnd);
          var text = source7.substring(elStartEnd + 1, elEndStart);
          if (/[&<]/.test(text)) {
            if (/^script$/i.test(tagName)) {
              domBuilder.characters(text, 0, text.length);
              return elEndStart;
            }
            text = text.replace(/&#?\w+;/g, entityReplacer);
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
        }
        return elStartEnd + 1;
      }
      function fixSelfClosed(source7, elStartEnd, tagName, closeMap) {
        var pos = closeMap[tagName];
        if (pos == null) {
          pos = source7.lastIndexOf("</" + tagName + ">");
          if (pos < elStartEnd) {
            pos = source7.lastIndexOf("</" + tagName);
          }
          closeMap[tagName] = pos;
        }
        return pos < elStartEnd;
      }
      function _copy3(source7, target) {
        for (var n2 in source7) {
          if (Object.prototype.hasOwnProperty.call(source7, n2)) {
            target[n2] = source7[n2];
          }
        }
      }
      function parseDCC(source7, start, domBuilder, errorHandler) {
        var next = source7.charAt(start + 2);
        switch (next) {
          case "-":
            if (source7.charAt(start + 3) === "-") {
              var end = source7.indexOf("-->", start + 4);
              if (end > start) {
                domBuilder.comment(source7, start + 4, end - start - 4);
                return end + 3;
              } else {
                errorHandler.error("Unclosed comment");
                return -1;
              }
            } else {
              return -1;
            }
          default:
            if (source7.substr(start + 3, 6) == "CDATA[") {
              var end = source7.indexOf("]]>", start + 9);
              domBuilder.startCDATA();
              domBuilder.characters(source7, start + 9, end - start - 9);
              domBuilder.endCDATA();
              return end + 3;
            }
            var matchs = split(source7, start);
            var len = matchs.length;
            if (len > 1 && /!doctype/i.test(matchs[0][0])) {
              var name = matchs[1][0];
              var pubid = false;
              var sysid = false;
              if (len > 3) {
                if (/^public$/i.test(matchs[2][0])) {
                  pubid = matchs[3][0];
                  sysid = len > 4 && matchs[4][0];
                } else if (/^system$/i.test(matchs[2][0])) {
                  sysid = matchs[3][0];
                }
              }
              var lastMatch = matchs[len - 1];
              domBuilder.startDTD(name, pubid, sysid);
              domBuilder.endDTD();
              return lastMatch.index + lastMatch[0].length;
            }
        }
        return -1;
      }
      function parseInstruction(source7, start, domBuilder) {
        var end = source7.indexOf("?>", start);
        if (end) {
          var match = source7.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
          if (match) {
            var len = match[0].length;
            domBuilder.processingInstruction(match[1], match[2]);
            return end + 2;
          } else {
            return -1;
          }
        }
        return -1;
      }
      function ElementAttributes() {
        this.attributeNames = {};
      }
      ElementAttributes.prototype = {
        setTagName: function(tagName) {
          if (!tagNamePattern.test(tagName)) {
            throw new Error("invalid tagName:" + tagName);
          }
          this.tagName = tagName;
        },
        addValue: function(qName, value, offset) {
          if (!tagNamePattern.test(qName)) {
            throw new Error("invalid attribute:" + qName);
          }
          this.attributeNames[qName] = this.length;
          this[this.length++] = { qName, value, offset };
        },
        length: 0,
        getLocalName: function(i3) {
          return this[i3].localName;
        },
        getLocator: function(i3) {
          return this[i3].locator;
        },
        getQName: function(i3) {
          return this[i3].qName;
        },
        getURI: function(i3) {
          return this[i3].uri;
        },
        getValue: function(i3) {
          return this[i3].value;
        }
        //	,getIndex:function(uri, localName)){
        //		if(localName){
        //
        //		}else{
        //			var qName = uri
        //		}
        //	},
        //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
        //	getType:function(uri,localName){}
        //	getType:function(i){},
      };
      function split(source7, start) {
        var match;
        var buf = [];
        var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
        reg.lastIndex = start;
        reg.exec(source7);
        while (match = reg.exec(source7)) {
          buf.push(match);
          if (match[1])
            return buf;
        }
      }
      exports.XMLReader = XMLReader;
      exports.ParseError = ParseError;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/dom-parser.js
  var require_dom_parser = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
      var conventions = require_conventions();
      var dom = require_dom();
      var entities = require_entities();
      var sax = require_sax();
      var DOMImplementation = dom.DOMImplementation;
      var NAMESPACE = conventions.NAMESPACE;
      var ParseError = sax.ParseError;
      var XMLReader = sax.XMLReader;
      function normalizeLineEndings(input) {
        return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
      }
      function DOMParser3(options) {
        this.options = options || { locator: {} };
      }
      DOMParser3.prototype.parseFromString = function(source7, mimeType) {
        var options = this.options;
        var sax2 = new XMLReader();
        var domBuilder = options.domBuilder || new DOMHandler();
        var errorHandler = options.errorHandler;
        var locator = options.locator;
        var defaultNSMap = options.xmlns || {};
        var isHTML = /\/x?html?$/.test(mimeType);
        var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
        if (locator) {
          domBuilder.setDocumentLocator(locator);
        }
        sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
        sax2.domBuilder = options.domBuilder || domBuilder;
        if (isHTML) {
          defaultNSMap[""] = NAMESPACE.HTML;
        }
        defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
        var normalize3 = options.normalizeLineEndings || normalizeLineEndings;
        if (source7 && typeof source7 === "string") {
          sax2.parse(
            normalize3(source7),
            defaultNSMap,
            entityMap
          );
        } else {
          sax2.errorHandler.error("invalid doc source");
        }
        return domBuilder.doc;
      };
      function buildErrorHandler(errorImpl, domBuilder, locator) {
        if (!errorImpl) {
          if (domBuilder instanceof DOMHandler) {
            return domBuilder;
          }
          errorImpl = domBuilder;
        }
        var errorHandler = {};
        var isCallback = errorImpl instanceof Function;
        locator = locator || {};
        function build(key) {
          var fn = errorImpl[key];
          if (!fn && isCallback) {
            fn = errorImpl.length == 2 ? function(msg) {
              errorImpl(key, msg);
            } : errorImpl;
          }
          errorHandler[key] = fn && function(msg) {
            fn("[xmldom " + key + "]	" + msg + _locator(locator));
          } || function() {
          };
        }
        build("warning");
        build("error");
        build("fatalError");
        return errorHandler;
      }
      function DOMHandler() {
        this.cdata = false;
      }
      function position(locator, node) {
        node.lineNumber = locator.lineNumber;
        node.columnNumber = locator.columnNumber;
      }
      DOMHandler.prototype = {
        startDocument: function() {
          this.doc = new DOMImplementation().createDocument(null, null, null);
          if (this.locator) {
            this.doc.documentURI = this.locator.systemId;
          }
        },
        startElement: function(namespaceURI, localName, qName, attrs) {
          var doc = this.doc;
          var el = doc.createElementNS(namespaceURI, qName || localName);
          var len = attrs.length;
          appendElement(this, el);
          this.currentElement = el;
          this.locator && position(this.locator, el);
          for (var i3 = 0; i3 < len; i3++) {
            var namespaceURI = attrs.getURI(i3);
            var value = attrs.getValue(i3);
            var qName = attrs.getQName(i3);
            var attr = doc.createAttributeNS(namespaceURI, qName);
            this.locator && position(attrs.getLocator(i3), attr);
            attr.value = attr.nodeValue = value;
            el.setAttributeNode(attr);
          }
        },
        endElement: function(namespaceURI, localName, qName) {
          var current = this.currentElement;
          var tagName = current.tagName;
          this.currentElement = current.parentNode;
        },
        startPrefixMapping: function(prefix, uri) {
        },
        endPrefixMapping: function(prefix) {
        },
        processingInstruction: function(target, data) {
          var ins = this.doc.createProcessingInstruction(target, data);
          this.locator && position(this.locator, ins);
          appendElement(this, ins);
        },
        ignorableWhitespace: function(ch, start, length) {
        },
        characters: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          if (chars) {
            if (this.cdata) {
              var charNode = this.doc.createCDATASection(chars);
            } else {
              var charNode = this.doc.createTextNode(chars);
            }
            if (this.currentElement) {
              this.currentElement.appendChild(charNode);
            } else if (/^\s*$/.test(chars)) {
              this.doc.appendChild(charNode);
            }
            this.locator && position(this.locator, charNode);
          }
        },
        skippedEntity: function(name) {
        },
        endDocument: function() {
          this.doc.normalize();
        },
        setDocumentLocator: function(locator) {
          if (this.locator = locator) {
            locator.lineNumber = 0;
          }
        },
        //LexicalHandler
        comment: function(chars, start, length) {
          chars = _toString.apply(this, arguments);
          var comm = this.doc.createComment(chars);
          this.locator && position(this.locator, comm);
          appendElement(this, comm);
        },
        startCDATA: function() {
          this.cdata = true;
        },
        endCDATA: function() {
          this.cdata = false;
        },
        startDTD: function(name, publicId, systemId) {
          var impl = this.doc.implementation;
          if (impl && impl.createDocumentType) {
            var dt = impl.createDocumentType(name, publicId, systemId);
            this.locator && position(this.locator, dt);
            appendElement(this, dt);
            this.doc.doctype = dt;
          }
        },
        /**
         * @see org.xml.sax.ErrorHandler
         * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
         */
        warning: function(error) {
          console.warn("[xmldom warning]	" + error, _locator(this.locator));
        },
        error: function(error) {
          console.error("[xmldom error]	" + error, _locator(this.locator));
        },
        fatalError: function(error) {
          throw new ParseError(error, this.locator);
        }
      };
      function _locator(l2) {
        if (l2) {
          return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
        }
      }
      function _toString(chars, start, length) {
        if (typeof chars == "string") {
          return chars.substr(start, length);
        } else {
          if (chars.length >= start + length || start) {
            return new java.lang.String(chars, start, length) + "";
          }
          return chars;
        }
      }
      "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
        DOMHandler.prototype[key] = function() {
          return null;
        };
      });
      function appendElement(hander, node) {
        if (!hander.currentElement) {
          hander.doc.appendChild(node);
        } else {
          hander.currentElement.appendChild(node);
        }
      }
      exports.__DOMHandler = DOMHandler;
      exports.normalizeLineEndings = normalizeLineEndings;
      exports.DOMParser = DOMParser3;
    }
  });

  // node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/@xmldom+xmldom@0.8.10/node_modules/@xmldom/xmldom/lib/index.js"(exports) {
      var dom = require_dom();
      exports.DOMImplementation = dom.DOMImplementation;
      exports.XMLSerializer = dom.XMLSerializer;
      exports.DOMParser = require_dom_parser().DOMParser;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs
  var import_xmldom, WebWorkerAdapter;
  var init_WebWorkerAdapter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs"() {
      import_xmldom = __toESM(require_lib(), 1);
      WebWorkerAdapter = {
        createCanvas: (width, height) => new OffscreenCanvas(width ?? 0, height ?? 0),
        getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => globalThis.location.href,
        getFontFaceSet: () => globalThis.fonts,
        fetch: (url, options) => fetch(url, options),
        parseXML: (xml) => {
          const parser = new import_xmldom.DOMParser();
          return parser.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs
  var vertex3;
  var init_defaultFilter_vert = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs"() {
      vertex3 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs
  var fragment3;
  var init_alpha_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs"() {
      fragment3 = "\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs
  var source2;
  var init_alpha_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs"() {
      source2 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
  var _AlphaFilter, AlphaFilter;
  var init_AlphaFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_Filter();
      init_defaultFilter_vert();
      init_alpha_frag();
      init_alpha_wgsl();
      _AlphaFilter = class _AlphaFilter2 extends Filter {
        constructor(options) {
          options = { ..._AlphaFilter2.defaultOptions, ...options };
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: source2,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: source2,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex3,
            fragment: fragment3,
            name: "alpha-filter"
          });
          const { alpha, ...rest } = options;
          const alphaUniforms = new UniformGroup({
            uAlpha: { value: alpha, type: "f32" }
          });
          super({
            ...rest,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              alphaUniforms
            }
          });
        }
        /**
         * Coefficient for alpha multiplication
         * @default 1
         */
        get alpha() {
          return this.resources.alphaUniforms.uniforms.uAlpha;
        }
        set alpha(value) {
          this.resources.alphaUniforms.uniforms.uAlpha = value;
        }
      };
      _AlphaFilter.defaultOptions = {
        /** Amount of alpha from 0 to 1, where 0 is transparent */
        alpha: 1
      };
      AlphaFilter = _AlphaFilter;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/const.mjs
  var GAUSSIAN_VALUES;
  var init_const13 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/const.mjs"() {
      "use strict";
      GAUSSIAN_VALUES = {
        5: [0.153388, 0.221461, 0.250301],
        7: [0.071303, 0.131514, 0.189879, 0.214607],
        9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
        11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
        13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
        15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs
  function generateBlurFragSource(kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    let fragSource = fragTemplate2;
    let blurLoop = "";
    const template = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let value;
    for (let i3 = 0; i3 < kernelSize; i3++) {
      let blur = template.replace("%index%", i3.toString());
      value = i3;
      if (i3 >= halfLength) {
        value = kernelSize - i3 - 1;
      }
      blur = blur.replace("%value%", kernel[value].toString());
      blurLoop += blur;
      blurLoop += "\n";
    }
    fragSource = fragSource.replace("%blur%", blurLoop);
    fragSource = fragSource.replace("%size%", kernelSize.toString());
    return fragSource;
  }
  var fragTemplate2;
  var init_generateBlurFragSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs"() {
      init_const13();
      fragTemplate2 = [
        "in vec2 vBlurTexCoords[%size%];",
        "uniform sampler2D uTexture;",
        "out vec4 finalColor;",
        "void main(void)",
        "{",
        "    finalColor = vec4(0.0);",
        "    %blur%",
        "}"
      ].join("\n");
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs
  function generateBlurVertSource(kernelSize, x2) {
    const halfLength = Math.ceil(kernelSize / 2);
    let vertSource = vertTemplate;
    let blurLoop = "";
    let template;
    if (x2) {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);";
    } else {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    }
    for (let i3 = 0; i3 < kernelSize; i3++) {
      let blur = template.replace("%index%", i3.toString());
      blur = blur.replace("%sampleIndex%", `${i3 - (halfLength - 1)}.0`);
      blurLoop += blur;
      blurLoop += "\n";
    }
    vertSource = vertSource.replace("%blur%", blurLoop);
    vertSource = vertSource.replace("%size%", kernelSize.toString());
    vertSource = vertSource.replace("%dimension%", x2 ? "z" : "w");
    return vertSource;
  }
  var vertTemplate;
  var init_generateBlurVertSource = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs"() {
      "use strict";
      vertTemplate = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs
  function generateBlurGlProgram(horizontal, kernelSize) {
    const vertex5 = generateBlurVertSource(kernelSize, horizontal);
    const fragment7 = generateBlurFragSource(kernelSize);
    return GlProgram.from({
      vertex: vertex5,
      fragment: fragment7,
      name: `blur-${horizontal ? "horizontal" : "vertical"}-pass-filter`
    });
  }
  var init_generateBlurGlProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs"() {
      init_GlProgram();
      init_generateBlurFragSource();
      init_generateBlurVertSource();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs
  var source3;
  var init_blur_template_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs"() {
      source3 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs
  function generateBlurProgram(horizontal, kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    const blurStructSource = [];
    const blurOutSource = [];
    const blurSamplingSource = [];
    for (let i3 = 0; i3 < kernelSize; i3++) {
      blurStructSource[i3] = `@location(${i3}) offset${i3}: vec2<f32>,`;
      if (horizontal) {
        blurOutSource[i3] = `filteredCord + vec2(${i3 - halfLength + 1} * pixelStrength, 0.0),`;
      } else {
        blurOutSource[i3] = `filteredCord + vec2(0.0, ${i3 - halfLength + 1} * pixelStrength),`;
      }
      const kernelIndex = i3 < halfLength ? i3 : kernelSize - i3 - 1;
      const kernelValue = kernel[kernelIndex].toString();
      blurSamplingSource[i3] = `finalColor += textureSample(uTexture, uSampler, offset${i3}) * ${kernelValue};`;
    }
    const blurStruct = blurStructSource.join("\n");
    const blurOut = blurOutSource.join("\n");
    const blurSampling = blurSamplingSource.join("\n");
    const finalSource = source3.replace("%blur-struct%", blurStruct).replace("%blur-vertex-out%", blurOut).replace("%blur-fragment-in%", blurStruct).replace("%blur-sampling%", blurSampling).replace("%dimension%", horizontal ? "z" : "w");
    return GpuProgram.from({
      vertex: {
        source: finalSource,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: finalSource,
        entryPoint: "mainFragment"
      }
    });
  }
  var init_generateBlurProgram = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs"() {
      init_GpuProgram();
      init_const13();
      init_blur_template_wgsl();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs
  var _BlurFilterPass, BlurFilterPass;
  var init_BlurFilterPass = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs"() {
      init_TexturePool();
      init_types2();
      init_Filter();
      init_generateBlurGlProgram();
      init_generateBlurProgram();
      _BlurFilterPass = class _BlurFilterPass2 extends Filter {
        /**
         * @param options
         * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
         * @param options.strength - The strength of the blur filter.
         * @param options.quality - The quality of the blur filter.
         * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
         */
        constructor(options) {
          options = { ..._BlurFilterPass2.defaultOptions, ...options };
          const glProgram3 = generateBlurGlProgram(options.horizontal, options.kernelSize);
          const gpuProgram3 = generateBlurProgram(options.horizontal, options.kernelSize);
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              blurUniforms: {
                uStrength: { value: 0, type: "f32" }
              }
            },
            ...options
          });
          this.horizontal = options.horizontal;
          this._quality = 0;
          this.quality = options.quality;
          this.blur = options.strength;
          this._uniforms = this.resources.blurUniforms.uniforms;
        }
        /**
         * Applies the filter.
         * @param filterManager - The manager.
         * @param input - The input target.
         * @param output - The output target.
         * @param clearMode - How to clear
         */
        apply(filterManager, input, output, clearMode) {
          this._uniforms.uStrength = this.strength / this.passes;
          if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clearMode);
          } else {
            const tempTexture = TexturePool.getSameSizeTexture(input);
            let flip = input;
            let flop = tempTexture;
            this._state.blend = false;
            const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;
            for (let i3 = 0; i3 < this.passes - 1; i3++) {
              filterManager.applyFilter(this, flip, flop, i3 === 0 ? true : shouldClear);
              const temp = flop;
              flop = flip;
              flip = temp;
            }
            this._state.blend = true;
            filterManager.applyFilter(this, flip, output, clearMode);
            TexturePool.returnTexture(tempTexture);
          }
        }
        /**
         * Sets the strength of both the blur.
         * @default 16
         */
        get blur() {
          return this.strength;
        }
        set blur(value) {
          this.padding = 1 + Math.abs(value) * 2;
          this.strength = value;
        }
        /**
         * Sets the quality of the blur by modifying the number of passes. More passes means higher
         * quality blurring but the lower the performance.
         * @default 4
         */
        get quality() {
          return this._quality;
        }
        set quality(value) {
          this._quality = value;
          this.passes = value;
        }
      };
      _BlurFilterPass.defaultOptions = {
        /** The strength of the blur filter. */
        strength: 8,
        /** The quality of the blur filter. */
        quality: 4,
        /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
        kernelSize: 5
      };
      BlurFilterPass = _BlurFilterPass;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs
  var BlurFilter;
  var init_BlurFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs"() {
      init_TexturePool();
      init_types2();
      init_deprecation();
      init_Filter();
      init_BlurFilterPass();
      BlurFilter = class extends Filter {
        constructor(...args) {
          let options = args[0] ?? {};
          if (typeof options === "number") {
            deprecation(v8_0_0, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
            options = { strength: options };
            if (args[1] !== void 0)
              options.quality = args[1];
            if (args[2] !== void 0)
              options.resolution = args[2] || "inherit";
            if (args[3] !== void 0)
              options.kernelSize = args[3];
          }
          options = { ...BlurFilterPass.defaultOptions, ...options };
          const { strength, strengthX, strengthY, quality, ...rest } = options;
          super({
            ...rest,
            compatibleRenderers: RendererType.BOTH,
            resources: {}
          });
          this._repeatEdgePixels = false;
          this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });
          this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });
          this.quality = quality;
          this.strengthX = strengthX ?? strength;
          this.strengthY = strengthY ?? strength;
          this.repeatEdgePixels = false;
        }
        /**
         * Applies the filter.
         * @param filterManager - The manager.
         * @param input - The input target.
         * @param output - The output target.
         * @param clearMode - How to clear
         */
        apply(filterManager, input, output, clearMode) {
          const xStrength = Math.abs(this.blurXFilter.strength);
          const yStrength = Math.abs(this.blurYFilter.strength);
          if (xStrength && yStrength) {
            const tempTexture = TexturePool.getSameSizeTexture(input);
            this.blurXFilter.blendMode = "normal";
            this.blurXFilter.apply(filterManager, input, tempTexture, true);
            this.blurYFilter.blendMode = this.blendMode;
            this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);
            TexturePool.returnTexture(tempTexture);
          } else if (yStrength) {
            this.blurYFilter.blendMode = this.blendMode;
            this.blurYFilter.apply(filterManager, input, output, clearMode);
          } else {
            this.blurXFilter.blendMode = this.blendMode;
            this.blurXFilter.apply(filterManager, input, output, clearMode);
          }
        }
        updatePadding() {
          if (this._repeatEdgePixels) {
            this.padding = 0;
          } else {
            this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
          }
        }
        /**
         * Sets the strength of both the blurX and blurY properties simultaneously
         * @default 8
         */
        get strength() {
          if (this.strengthX !== this.strengthY) {
            throw new Error("BlurFilter's strengthX and strengthY are different");
          }
          return this.strengthX;
        }
        set strength(value) {
          this.blurXFilter.blur = this.blurYFilter.blur = value;
          this.updatePadding();
        }
        /**
         * Sets the number of passes for blur. More passes means higher quality bluring.
         * @default 1
         */
        get quality() {
          return this.blurXFilter.quality;
        }
        set quality(value) {
          this.blurXFilter.quality = this.blurYFilter.quality = value;
        }
        /**
         * Sets the strength of horizontal blur
         * @default 8
         */
        get strengthX() {
          return this.blurXFilter.blur;
        }
        set strengthX(value) {
          this.blurXFilter.blur = value;
          this.updatePadding();
        }
        /**
         * Sets the strength of the vertical blur
         * @default 8
         */
        get strengthY() {
          return this.blurYFilter.blur;
        }
        set strengthY(value) {
          this.blurYFilter.blur = value;
          this.updatePadding();
        }
        /**
         * Sets the strength of both the blurX and blurY properties simultaneously
         * @default 2
         * @deprecated since 8.3.0
         * @see BlurFilter.strength
         */
        get blur() {
          deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
          return this.strength;
        }
        set blur(value) {
          deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
          this.strength = value;
        }
        /**
         * Sets the strength of the blurX property
         * @default 2
         * @deprecated since 8.3.0
         * @see BlurFilter.strengthX
         */
        get blurX() {
          deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
          return this.strengthX;
        }
        set blurX(value) {
          deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
          this.strengthX = value;
        }
        /**
         * Sets the strength of the blurY property
         * @default 2
         * @deprecated since 8.3.0
         * @see BlurFilter.strengthY
         */
        get blurY() {
          deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
          return this.strengthY;
        }
        set blurY(value) {
          deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
          this.strengthY = value;
        }
        /**
         * If set to true the edge of the target will be clamped
         * @default false
         */
        get repeatEdgePixels() {
          return this._repeatEdgePixels;
        }
        set repeatEdgePixels(value) {
          this._repeatEdgePixels = value;
          this.updatePadding();
        }
      };
      BlurFilter.defaultOptions = {
        /** The strength of the blur filter. */
        strength: 8,
        /** The quality of the blur filter. */
        quality: 4,
        /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
        kernelSize: 5
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs
  var fragment4;
  var init_colorMatrixFilter_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs"() {
      fragment4 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs
  var source4;
  var init_colorMatrixFilter_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs"() {
      source4 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs
  var ColorMatrixFilter;
  var init_ColorMatrixFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs"() {
      init_Color();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_Filter();
      init_defaultFilter_vert();
      init_colorMatrixFilter_frag();
      init_colorMatrixFilter_wgsl();
      ColorMatrixFilter = class extends Filter {
        constructor(options = {}) {
          const colorMatrixUniforms = new UniformGroup({
            uColorMatrix: {
              value: [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ],
              type: "f32",
              size: 20
            },
            uAlpha: {
              value: 1,
              type: "f32"
            }
          });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: source4,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: source4,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex3,
            fragment: fragment4,
            name: "color-matrix-filter"
          });
          super({
            ...options,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              colorMatrixUniforms
            }
          });
          this.alpha = 1;
        }
        /**
         * Transforms current matrix and set the new one
         * @param {number[]} matrix - 5x4 matrix
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        _loadMatrix(matrix, multiply = false) {
          let newMatrix = matrix;
          if (multiply) {
            this._multiply(newMatrix, this.matrix, matrix);
            newMatrix = this._colorMatrix(newMatrix);
          }
          this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;
          this.resources.colorMatrixUniforms.update();
        }
        /**
         * Multiplies two mat5's
         * @private
         * @param out - 5x4 matrix the receiving matrix
         * @param a - 5x4 matrix the first operand
         * @param b - 5x4 matrix the second operand
         * @returns {number[]} 5x4 matrix
         */
        _multiply(out2, a2, b2) {
          out2[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
          out2[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
          out2[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
          out2[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
          out2[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
          out2[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
          out2[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
          out2[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
          out2[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
          out2[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
          out2[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
          out2[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
          out2[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
          out2[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
          out2[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
          out2[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
          out2[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
          out2[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
          out2[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
          out2[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
          return out2;
        }
        /**
         * Create a Float32 Array and normalize the offset component to 0-1
         * @param {number[]} matrix - 5x4 matrix
         * @returns {number[]} 5x4 matrix with all values between 0-1
         */
        _colorMatrix(matrix) {
          const m2 = new Float32Array(matrix);
          m2[4] /= 255;
          m2[9] /= 255;
          m2[14] /= 255;
          m2[19] /= 255;
          return m2;
        }
        /**
         * Adjusts brightness
         * @param b - value of the brightness (0-1, where 0 is black)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        brightness(b2, multiply) {
          const matrix = [
            b2,
            0,
            0,
            0,
            0,
            0,
            b2,
            0,
            0,
            0,
            0,
            0,
            b2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Sets each channel on the diagonal of the color matrix.
         * This can be used to achieve a tinting effect on Containers similar to the tint field of some
         * display objects like Sprite, Text, Graphics, and Mesh.
         * @param color - Color of the tint. This is a hex value.
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        tint(color, multiply) {
          const [r2, g2, b2] = Color.shared.setValue(color).toArray();
          const matrix = [
            r2,
            0,
            0,
            0,
            0,
            0,
            g2,
            0,
            0,
            0,
            0,
            0,
            b2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Set the matrices in grey scales
         * @param scale - value of the grey (0-1, where 0 is black)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        greyscale(scale, multiply) {
          const matrix = [
            scale,
            scale,
            scale,
            0,
            0,
            scale,
            scale,
            scale,
            0,
            0,
            scale,
            scale,
            scale,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * for our american friends!
         * @param scale
         * @param multiply
         */
        grayscale(scale, multiply) {
          this.greyscale(scale, multiply);
        }
        /**
         * Set the black and white matrice.
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        blackAndWhite(multiply) {
          const matrix = [
            0.3,
            0.6,
            0.1,
            0,
            0,
            0.3,
            0.6,
            0.1,
            0,
            0,
            0.3,
            0.6,
            0.1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Set the hue property of the color
         * @param rotation - in degrees
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        hue(rotation, multiply) {
          rotation = (rotation || 0) / 180 * Math.PI;
          const cosR = Math.cos(rotation);
          const sinR = Math.sin(rotation);
          const sqrt = Math.sqrt;
          const w2 = 1 / 3;
          const sqrW = sqrt(w2);
          const a00 = cosR + (1 - cosR) * w2;
          const a01 = w2 * (1 - cosR) - sqrW * sinR;
          const a02 = w2 * (1 - cosR) + sqrW * sinR;
          const a10 = w2 * (1 - cosR) + sqrW * sinR;
          const a11 = cosR + w2 * (1 - cosR);
          const a12 = w2 * (1 - cosR) - sqrW * sinR;
          const a20 = w2 * (1 - cosR) - sqrW * sinR;
          const a21 = w2 * (1 - cosR) + sqrW * sinR;
          const a22 = cosR + w2 * (1 - cosR);
          const matrix = [
            a00,
            a01,
            a02,
            0,
            0,
            a10,
            a11,
            a12,
            0,
            0,
            a20,
            a21,
            a22,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Set the contrast matrix, increase the separation between dark and bright
         * Increase contrast : shadows darker and highlights brighter
         * Decrease contrast : bring the shadows up and the highlights down
         * @param amount - value of the contrast (0-1)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        contrast(amount, multiply) {
          const v2 = (amount || 0) + 1;
          const o2 = -0.5 * (v2 - 1);
          const matrix = [
            v2,
            0,
            0,
            0,
            o2,
            0,
            v2,
            0,
            0,
            o2,
            0,
            0,
            v2,
            0,
            o2,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Set the saturation matrix, increase the separation between colors
         * Increase saturation : increase contrast, brightness, and sharpness
         * @param amount - The saturation amount (0-1)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        saturate(amount = 0, multiply) {
          const x2 = amount * 2 / 3 + 1;
          const y2 = (x2 - 1) * -0.5;
          const matrix = [
            x2,
            y2,
            y2,
            0,
            0,
            y2,
            x2,
            y2,
            0,
            0,
            y2,
            y2,
            x2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /** Desaturate image (remove color) Call the saturate function */
        desaturate() {
          this.saturate(-1);
        }
        /**
         * Negative image (inverse of classic rgb matrix)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        negative(multiply) {
          const matrix = [
            -1,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            -1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Sepia image
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        sepia(multiply) {
          const matrix = [
            0.393,
            0.7689999,
            0.18899999,
            0,
            0,
            0.349,
            0.6859999,
            0.16799999,
            0,
            0,
            0.272,
            0.5339999,
            0.13099999,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        technicolor(multiply) {
          const matrix = [
            1.9125277891456083,
            -0.8545344976951645,
            -0.09155508482755585,
            0,
            11.793603434377337,
            -0.3087833385928097,
            1.7658908555458428,
            -0.10601743074722245,
            0,
            -70.35205161461398,
            -0.231103377548616,
            -0.7501899197440212,
            1.847597816108189,
            0,
            30.950940869491138,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Polaroid filter
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        polaroid(multiply) {
          const matrix = [
            1.438,
            -0.062,
            -0.062,
            0,
            0,
            -0.122,
            1.378,
            -0.122,
            0,
            0,
            -0.016,
            -0.016,
            1.483,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Filter who transforms : Red -> Blue and Blue -> Red
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        toBGR(multiply) {
          const matrix = [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        kodachrome(multiply) {
          const matrix = [
            1.1285582396593525,
            -0.3967382283601348,
            -0.03992559172921793,
            0,
            63.72958762196502,
            -0.16404339962244616,
            1.0835251566291304,
            -0.05498805115633132,
            0,
            24.732407896706203,
            -0.16786010706155763,
            -0.5603416277695248,
            1.6014850761964943,
            0,
            35.62982807460946,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Brown delicious browni filter (thanks Dominic Szablewski)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        browni(multiply) {
          const matrix = [
            0.5997023498159715,
            0.34553243048391263,
            -0.2708298674538042,
            0,
            47.43192855600873,
            -0.037703249837783157,
            0.8609577587992641,
            0.15059552388459913,
            0,
            -36.96841498319127,
            0.24113635128153335,
            -0.07441037908422492,
            0.44972182064877153,
            0,
            -7.562075277591283,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Vintage filter (thanks Dominic Szablewski)
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        vintage(multiply) {
          const matrix = [
            0.6279345635605994,
            0.3202183420819367,
            -0.03965408211312453,
            0,
            9.651285835294123,
            0.02578397704808868,
            0.6441188644374771,
            0.03259127616149294,
            0,
            7.462829176470591,
            0.0466055556782719,
            -0.0851232987247891,
            0.5241648018700465,
            0,
            5.159190588235296,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * We don't know exactly what it does, kind of gradient map, but funny to play with!
         * @param desaturation - Tone values.
         * @param toned - Tone values.
         * @param lightColor - Tone values, example: `0xFFE580`
         * @param darkColor - Tone values, example: `0xFFE580`
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        colorTone(desaturation, toned, lightColor, darkColor, multiply) {
          desaturation = desaturation || 0.2;
          toned = toned || 0.15;
          lightColor = lightColor || 16770432;
          darkColor = darkColor || 3375104;
          const temp = Color.shared;
          const [lR, lG, lB] = temp.setValue(lightColor).toArray();
          const [dR, dG, dB] = temp.setValue(darkColor).toArray();
          const matrix = [
            0.3,
            0.59,
            0.11,
            0,
            0,
            lR,
            lG,
            lB,
            desaturation,
            0,
            dR,
            dG,
            dB,
            toned,
            0,
            lR - dR,
            lG - dG,
            lB - dB,
            0,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Night effect
         * @param intensity - The intensity of the night effect.
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        night(intensity, multiply) {
          intensity = intensity || 0.1;
          const matrix = [
            intensity * -2,
            -intensity,
            0,
            0,
            0,
            -intensity,
            0,
            intensity,
            0,
            0,
            0,
            intensity,
            intensity * 2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * Predator effect
         *
         * Erase the current matrix by setting a new independent one
         * @param amount - how much the predator feels his future victim
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        predator(amount, multiply) {
          const matrix = [
            // row 1
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            // row 2
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            // row 3
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            // row 4
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /**
         * LSD effect
         *
         * Multiply the current matrix
         * @param multiply - if true, current matrix and matrix are multiplied. If false,
         *  just set the current matrix with @param matrix
         */
        lsd(multiply) {
          const matrix = [
            2,
            -0.4,
            0.5,
            0,
            0,
            -0.5,
            2,
            -0.4,
            0,
            0,
            -0.4,
            -0.5,
            3,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        /** Erase the current matrix by setting the default one. */
        reset() {
          const matrix = [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, false);
        }
        /**
         * The matrix of the color matrix filter
         * @member {number[]}
         * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
         */
        get matrix() {
          return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
        }
        set matrix(value) {
          this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;
        }
        /**
         * The opacity value to use when mixing the original and resultant colors.
         *
         * When the value is 0, the original color is used without modification.
         * When the value is 1, the result color is used.
         * When in the range (0, 1) the color is interpolated between the original and result by this amount.
         * @default 1
         */
        get alpha() {
          return this.resources.colorMatrixUniforms.uniforms.uAlpha;
        }
        set alpha(value) {
          this.resources.colorMatrixUniforms.uniforms.uAlpha = value;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs
  var fragment5;
  var init_displacement_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs"() {
      fragment5 = "\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs
  var vertex4;
  var init_displacement_vert = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs"() {
      vertex4 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs
  var source5;
  var init_displacement_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs"() {
      source5 = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs
  var DisplacementFilter;
  var init_DisplacementFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs"() {
      init_Matrix();
      init_Point();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_Sprite();
      init_deprecation();
      init_Filter();
      init_displacement_frag();
      init_displacement_vert();
      init_displacement_wgsl();
      DisplacementFilter = class extends Filter {
        constructor(...args) {
          let options = args[0];
          if (options instanceof Sprite) {
            if (args[1]) {
              deprecation(v8_0_0, "DisplacementFilter now uses options object instead of params. {sprite, scale}");
            }
            options = { sprite: options, scale: args[1] };
          }
          const { sprite, scale: scaleOption, ...rest } = options;
          let scale = scaleOption ?? 20;
          if (typeof scale === "number") {
            scale = new Point(scale, scale);
          }
          const filterUniforms = new UniformGroup({
            uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uScale: { value: scale, type: "vec2<f32>" },
            uRotation: { value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>" }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex4,
            fragment: fragment5,
            name: "displacement-filter"
          });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: source5,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: source5,
              entryPoint: "mainFragment"
            }
          });
          const textureSource = sprite.texture.source;
          super({
            ...rest,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              filterUniforms,
              uMapTexture: textureSource,
              uMapSampler: textureSource.style
            }
          });
          this._sprite = options.sprite;
          this._sprite.renderable = false;
        }
        /**
         * Applies the filter.
         * @param filterManager - The manager.
         * @param input - The input target.
         * @param output - The output target.
         * @param clearMode - clearMode.
         */
        apply(filterManager, input, output, clearMode) {
          const uniforms = this.resources.filterUniforms.uniforms;
          filterManager.calculateSpriteMatrix(
            uniforms.uFilterMatrix,
            this._sprite
          );
          const wt = this._sprite.worldTransform;
          const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
          const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
          if (lenX !== 0 && lenY !== 0) {
            uniforms.uRotation[0] = wt.a / lenX;
            uniforms.uRotation[1] = wt.b / lenX;
            uniforms.uRotation[2] = wt.c / lenY;
            uniforms.uRotation[3] = wt.d / lenY;
          }
          this.resources.uMapTexture = this._sprite.texture.source;
          filterManager.applyFilter(this, input, output, clearMode);
        }
        /** scaleX, scaleY for displacements */
        get scale() {
          return this.resources.filterUniforms.uniforms.uScale;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs
  var fragment6;
  var init_noise_frag = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs"() {
      fragment6 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs
  var source6;
  var init_noise_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs"() {
      source6 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2<f32>) -> f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample = textureSample(uTexture, uSampler, uv);\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a > 0.0) {\n      sample.r /= sample.a;\n      sample.g /= sample.a;\n      sample.b /= sample.a;\n    }\n\n    sample.r += diff;\n    sample.g += diff;\n    sample.b += diff;\n\n    // Premultiply alpha again.\n    sample.r *= sample.a;\n    sample.g *= sample.a;\n    sample.b *= sample.a;\n    \n    return sample;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs
  var _NoiseFilter, NoiseFilter;
  var init_NoiseFilter = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_Filter();
      init_defaultFilter_vert();
      init_noise_frag();
      init_noise_wgsl();
      _NoiseFilter = class _NoiseFilter2 extends Filter {
        /**
         * @param options - The options of the noise filter.
         */
        constructor(options = {}) {
          options = { ..._NoiseFilter2.defaultOptions, ...options };
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: source6,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: source6,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex3,
            fragment: fragment6,
            name: "noise-filter"
          });
          const { noise, seed, ...rest } = options;
          super({
            ...rest,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              noiseUniforms: new UniformGroup({
                uNoise: { value: 1, type: "f32" },
                uSeed: { value: 1, type: "f32" }
              })
            }
          });
          this.noise = noise;
          this.seed = seed ?? Math.random();
        }
        /**
         * The amount of noise to apply, this value should be in the range (0, 1].
         * @default 0.5
         */
        get noise() {
          return this.resources.noiseUniforms.uniforms.uNoise;
        }
        set noise(value) {
          this.resources.noiseUniforms.uniforms.uNoise = value;
        }
        /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
        get seed() {
          return this.resources.noiseUniforms.uniforms.uSeed;
        }
        set seed(value) {
          this.resources.noiseUniforms.uniforms.uSeed = value;
        }
      };
      _NoiseFilter.defaultOptions = {
        noise: 0.5
      };
      NoiseFilter = _NoiseFilter;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs
  var hsl;
  var init_hsl_wgsl = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs"() {
      hsl = "fn getLuminosity(c: vec3<f32>) -> f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\n  let d: f32 = lum - getLuminosity(c);\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 = getLuminosity(newColor);\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 = newLum / (newLum - cMin);\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3<f32>) -> f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\n  var result: vec3<f32>;\n  if (cSorted.z > cSorted.x) {\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result = vec3<f32>(0.0, newY, s);\n  } else {\n    result = vec3<f32>(0.0, 0.0, 0.0);\n  }\n  return vec3<f32>(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var result: vec3<f32> = c;\n\n    if (c.r <= c.g && c.r <= c.b) {\n        if (c.g <= c.b) {\n            result = setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g <= c.r && c.g <= c.b) {\n        if (c.r <= c.b) {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r <= c.g) {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs
  function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
    const v2x = x3 - x1;
    const v2y = y3 - y1;
    const v1x = x2 - x1;
    const v1y = y2 - y1;
    const v0x = px - x1;
    const v0y = py - y1;
    const dot00 = v2x * v2x + v2y * v2y;
    const dot01 = v2x * v1x + v2y * v1y;
    const dot02 = v2x * v0x + v2y * v0y;
    const dot11 = v1x * v1x + v1y * v1y;
    const dot12 = v1x * v0x + v1y * v0y;
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return u2 >= 0 && v2 >= 0 && u2 + v2 < 1;
  }
  var init_pointInTriangle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Triangle.mjs
  var Triangle;
  var init_Triangle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/maths/shapes/Triangle.mjs"() {
      init_squaredDistanceToLineSegment();
      init_Rectangle();
      Triangle = class {
        /**
         * @param x - The X coord of the first point.
         * @param y - The Y coord of the first point.
         * @param x2 - The X coord of the second point.
         * @param y2 - The Y coord of the second point.
         * @param x3 - The X coord of the third point.
         * @param y3 - The Y coord of the third point.
         */
        constructor(x2 = 0, y2 = 0, x22 = 0, y22 = 0, x3 = 0, y3 = 0) {
          this.type = "triangle";
          this.x = x2;
          this.y = y2;
          this.x2 = x22;
          this.y2 = y22;
          this.x3 = x3;
          this.y3 = y3;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this triangle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Triangle
         */
        contains(x2, y2) {
          const s2 = (this.x - this.x3) * (y2 - this.y3) - (this.y - this.y3) * (x2 - this.x3);
          const t2 = (this.x2 - this.x) * (y2 - this.y) - (this.y2 - this.y) * (x2 - this.x);
          if (s2 < 0 !== t2 < 0 && s2 !== 0 && t2 !== 0) {
            return false;
          }
          const d2 = (this.x3 - this.x2) * (y2 - this.y2) - (this.y3 - this.y2) * (x2 - this.x2);
          return d2 === 0 || d2 < 0 === s2 + t2 <= 0;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this triangle including the stroke.
         * @param pointX - The X coordinate of the point to test
         * @param pointY - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this triangle
         */
        strokeContains(pointX, pointY, strokeWidth) {
          const halfStrokeWidth = strokeWidth / 2;
          const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;
          const { x: x2, x2: x22, x3, y: y2, y2: y22, y3 } = this;
          if (squaredDistanceToLineSegment(pointX, pointY, x2, y2, x22, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x22, y22, x3, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x3, y3, x2, y2) <= halfStrokeWidthSquared) {
            return true;
          }
          return false;
        }
        /**
         * Creates a clone of this Triangle
         * @returns a copy of the triangle
         */
        clone() {
          const triangle = new Triangle(
            this.x,
            this.y,
            this.x2,
            this.y2,
            this.x3,
            this.y3
          );
          return triangle;
        }
        /**
         * Copies another triangle to this one.
         * @param triangle - The triangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(triangle) {
          this.x = triangle.x;
          this.y = triangle.y;
          this.x2 = triangle.x2;
          this.y2 = triangle.y2;
          this.x3 = triangle.x3;
          this.y3 = triangle.y3;
          return this;
        }
        /**
         * Copies this triangle to another one.
         * @param triangle - The triangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(triangle) {
          triangle.copyFrom(this);
          return triangle;
        }
        /**
         * Returns the framing rectangle of the triangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          const minX = Math.min(this.x, this.x2, this.x3);
          const maxX = Math.max(this.x, this.x2, this.x3);
          const minY = Math.min(this.y, this.y2, this.y3);
          const maxY = Math.max(this.y, this.y2, this.y3);
          out2.x = minX;
          out2.y = minY;
          out2.width = maxX - minX;
          out2.height = maxY - minY;
          return out2;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareBase.mjs
  var _PrepareBase, PrepareBase;
  var init_PrepareBase = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareBase.mjs"() {
      init_Container();
      init_const2();
      init_Ticker();
      _PrepareBase = class _PrepareBase2 {
        /**
         * @param {rendering.Renderer} renderer - A reference to the current renderer
         */
        constructor(renderer) {
          this._tick = () => {
            this.timeout = setTimeout(this._processQueue, 0);
          };
          this._processQueue = () => {
            const { queue } = this;
            let itemsProcessed = 0;
            while (queue.length && itemsProcessed < _PrepareBase2.uploadsPerFrame) {
              const queueItem = queue.shift();
              this.uploadQueueItem(queueItem);
              itemsProcessed++;
            }
            if (queue.length) {
              Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);
            } else {
              this._resolve();
            }
          };
          this.renderer = renderer;
          this.queue = [];
          this.resolves = [];
        }
        /**
         * Return a copy of the queue
         * @returns {PrepareQueueItem[]} The queue
         */
        getQueue() {
          return [...this.queue];
        }
        /**
         * Add a textures or graphics resource to the queue
         * @param {PrepareSourceItem | PrepareSourceItem[]} resource
         */
        add(resource) {
          const resourceArray = Array.isArray(resource) ? resource : [resource];
          for (const resourceItem of resourceArray) {
            if (resourceItem instanceof Container) {
              this._addContainer(resourceItem);
            } else {
              this.resolveQueueItem(resourceItem, this.queue);
            }
          }
          return this;
        }
        /**
         * Recursively add a container and its children to the queue
         * @param {Container} container - The container to add to the queue
         */
        _addContainer(container) {
          this.resolveQueueItem(container, this.queue);
          for (const child of container.children) {
            this._addContainer(child);
          }
        }
        /**
         * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)
         * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource
         */
        upload(resource) {
          if (resource) {
            this.add(resource);
          }
          return new Promise((resolve) => {
            if (this.queue.length) {
              this.resolves.push(resolve);
              this.dedupeQueue();
              Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);
            } else {
              resolve();
            }
          });
        }
        /** eliminate duplicates before processing */
        dedupeQueue() {
          const hash = /* @__PURE__ */ Object.create(null);
          let nextUnique = 0;
          for (let i3 = 0; i3 < this.queue.length; i3++) {
            const current = this.queue[i3];
            if (!hash[current.uid]) {
              hash[current.uid] = true;
              this.queue[nextUnique++] = current;
            }
          }
          this.queue.length = nextUnique;
        }
        /** Call all the resolve callbacks */
        _resolve() {
          const { resolves } = this;
          const array = resolves.slice(0);
          resolves.length = 0;
          for (const resolve of array) {
            resolve();
          }
        }
      };
      _PrepareBase.uploadsPerFrame = 4;
      PrepareBase = _PrepareBase;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs
  var Mesh;
  var init_Mesh = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs"() {
      init_pointInTriangle();
      init_Geometry();
      init_State();
      init_Texture();
      init_deprecation();
      init_ViewContainer();
      init_MeshGeometry();
      Mesh = class extends ViewContainer {
        constructor(...args) {
          let options = args[0];
          if (options instanceof Geometry) {
            deprecation(v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead");
            options = {
              geometry: options,
              shader: args[1]
            };
            if (args[3]) {
              deprecation(v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead");
              options.geometry.topology = args[3];
            }
          }
          const { geometry, shader, texture, roundPixels, state, ...rest } = options;
          super({
            label: "Mesh",
            ...rest
          });
          this.renderPipeId = "mesh";
          this._shader = null;
          this.allowChildren = false;
          this.shader = shader ?? null;
          this.texture = texture ?? shader?.texture ?? Texture.WHITE;
          this.state = state ?? State.for2d();
          this._geometry = geometry;
          this._geometry.on("update", this.onViewUpdate, this);
          this.roundPixels = roundPixels ?? false;
        }
        /** Alias for {@link scene.Mesh#shader}. */
        get material() {
          deprecation(v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
          return this._shader;
        }
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         */
        set shader(value) {
          if (this._shader === value)
            return;
          this._shader = value;
          this.onViewUpdate();
        }
        get shader() {
          return this._shader;
        }
        /**
         * Includes vertex positions, face indices, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         */
        set geometry(value) {
          if (this._geometry === value)
            return;
          this._geometry?.off("update", this.onViewUpdate, this);
          value.on("update", this.onViewUpdate, this);
          this._geometry = value;
          this.onViewUpdate();
        }
        get geometry() {
          return this._geometry;
        }
        /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
        set texture(value) {
          value || (value = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          if (this.shader) {
            this.shader.texture = value;
          }
          this._texture = value;
          this.onViewUpdate();
        }
        get texture() {
          return this._texture;
        }
        get batched() {
          if (this._shader)
            return false;
          if ((this.state.data & 12) !== 0)
            return false;
          if (this._geometry instanceof MeshGeometry) {
            if (this._geometry.batchMode === "auto") {
              return this._geometry.positions.length / 2 <= 100;
            }
            return this._geometry.batchMode === "batch";
          }
          return false;
        }
        /**
         * The local bounds of the mesh.
         * @type {rendering.Bounds}
         */
        get bounds() {
          return this._geometry.bounds;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          bounds.addBounds(this.geometry.bounds);
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const { x: x2, y: y2 } = point;
          if (!this.bounds.containsPoint(x2, y2))
            return false;
          const vertices = this.geometry.getBuffer("aPosition").data;
          const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
          if (this.geometry.getIndex()) {
            const indices = this.geometry.getIndex().data;
            const len = indices.length;
            for (let i3 = 0; i3 + 2 < len; i3 += step) {
              const ind0 = indices[i3] * 2;
              const ind1 = indices[i3 + 1] * 2;
              const ind2 = indices[i3 + 2] * 2;
              if (pointInTriangle(
                x2,
                y2,
                vertices[ind0],
                vertices[ind0 + 1],
                vertices[ind1],
                vertices[ind1 + 1],
                vertices[ind2],
                vertices[ind2 + 1]
              )) {
                return true;
              }
            }
          } else {
            const len = vertices.length / 2;
            for (let i3 = 0; i3 + 2 < len; i3 += step) {
              const ind0 = i3 * 2;
              const ind1 = (i3 + 1) * 2;
              const ind2 = (i3 + 2) * 2;
              if (pointInTriangle(
                x2,
                y2,
                vertices[ind0],
                vertices[ind0 + 1],
                vertices[ind1],
                vertices[ind1 + 1],
                vertices[ind2],
                vertices[ind2 + 1]
              )) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._geometry?.off("update", this.onViewUpdate, this);
          this._texture = null;
          this._geometry = null;
          this._shader = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs
  var AnimatedSprite;
  var init_AnimatedSprite = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs"() {
      init_Texture();
      init_const2();
      init_Ticker();
      init_Sprite();
      AnimatedSprite = class extends Sprite {
        /** @ignore */
        constructor(...args) {
          let options = args[0];
          if (Array.isArray(args[0])) {
            options = {
              textures: args[0],
              autoUpdate: args[1]
            };
          }
          const { textures, autoUpdate, ...rest } = options;
          const [firstFrame] = textures;
          super({
            ...rest,
            texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture
          });
          this._textures = null;
          this._durations = null;
          this._autoUpdate = autoUpdate ?? true;
          this._isConnectedToTicker = false;
          this.animationSpeed = 1;
          this.loop = true;
          this.updateAnchor = false;
          this.onComplete = null;
          this.onFrameChange = null;
          this.onLoop = null;
          this._currentTime = 0;
          this._playing = false;
          this._previousFrame = null;
          this.textures = textures;
        }
        /** Stops the AnimatedSprite. */
        stop() {
          if (!this._playing) {
            return;
          }
          this._playing = false;
          if (this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          }
        }
        /** Plays the AnimatedSprite. */
        play() {
          if (this._playing) {
            return;
          }
          this._playing = true;
          if (this._autoUpdate && !this._isConnectedToTicker) {
            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
            this._isConnectedToTicker = true;
          }
        }
        /**
         * Stops the AnimatedSprite and goes to a specific frame.
         * @param frameNumber - Frame index to stop at.
         */
        gotoAndStop(frameNumber) {
          this.stop();
          this.currentFrame = frameNumber;
        }
        /**
         * Goes to a specific frame and begins playing the AnimatedSprite.
         * @param frameNumber - Frame index to start at.
         */
        gotoAndPlay(frameNumber) {
          this.currentFrame = frameNumber;
          this.play();
        }
        /**
         * Updates the object transform for rendering.
         * @param ticker - the ticker to use to update the object.
         */
        update(ticker) {
          if (!this._playing) {
            return;
          }
          const deltaTime = ticker.deltaTime;
          const elapsed = this.animationSpeed * deltaTime;
          const previousFrame = this.currentFrame;
          if (this._durations !== null) {
            let lag = this._currentTime % 1 * this._durations[this.currentFrame];
            lag += elapsed / 60 * 1e3;
            while (lag < 0) {
              this._currentTime--;
              lag += this._durations[this.currentFrame];
            }
            const sign = Math.sign(this.animationSpeed * deltaTime);
            this._currentTime = Math.floor(this._currentTime);
            while (lag >= this._durations[this.currentFrame]) {
              lag -= this._durations[this.currentFrame] * sign;
              this._currentTime += sign;
            }
            this._currentTime += lag / this._durations[this.currentFrame];
          } else {
            this._currentTime += elapsed;
          }
          if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);
            if (this.onComplete) {
              this.onComplete();
            }
          } else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);
            if (this.onComplete) {
              this.onComplete();
            }
          } else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
              if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                this.onLoop();
              }
            }
            this._updateTexture();
          }
        }
        /** Updates the displayed texture to match the current frame index. */
        _updateTexture() {
          const currentFrame = this.currentFrame;
          if (this._previousFrame === currentFrame) {
            return;
          }
          this._previousFrame = currentFrame;
          this.texture = this._textures[currentFrame];
          if (this.updateAnchor) {
            this.anchor.copyFrom(this.texture.defaultAnchor);
          }
          if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
          }
        }
        /** Stops the AnimatedSprite and destroys it. */
        destroy() {
          this.stop();
          super.destroy();
          this.onComplete = null;
          this.onFrameChange = null;
          this.onLoop = null;
        }
        /**
         * A short hand way of creating an AnimatedSprite from an array of frame ids.
         * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.
         * @returns - The new animated sprite with the specified frames.
         */
        static fromFrames(frames) {
          const textures = [];
          for (let i3 = 0; i3 < frames.length; ++i3) {
            textures.push(Texture.from(frames[i3]));
          }
          return new AnimatedSprite(textures);
        }
        /**
         * A short hand way of creating an AnimatedSprite from an array of image ids.
         * @param images - The array of image urls the AnimatedSprite will use as its texture frames.
         * @returns The new animate sprite with the specified images as frames.
         */
        static fromImages(images) {
          const textures = [];
          for (let i3 = 0; i3 < images.length; ++i3) {
            textures.push(Texture.from(images[i3]));
          }
          return new AnimatedSprite(textures);
        }
        /**
         * The total number of frames in the AnimatedSprite. This is the same as number of textures
         * assigned to the AnimatedSprite.
         * @readonly
         * @default 0
         */
        get totalFrames() {
          return this._textures.length;
        }
        /** The array of textures used for this AnimatedSprite. */
        get textures() {
          return this._textures;
        }
        set textures(value) {
          if (value[0] instanceof Texture) {
            this._textures = value;
            this._durations = null;
          } else {
            this._textures = [];
            this._durations = [];
            for (let i3 = 0; i3 < value.length; i3++) {
              this._textures.push(value[i3].texture);
              this._durations.push(value[i3].time);
            }
          }
          this._previousFrame = null;
          this.gotoAndStop(0);
          this._updateTexture();
        }
        /** The AnimatedSprite's current frame index. */
        get currentFrame() {
          let currentFrame = Math.floor(this._currentTime) % this._textures.length;
          if (currentFrame < 0) {
            currentFrame += this._textures.length;
          }
          return currentFrame;
        }
        set currentFrame(value) {
          if (value < 0 || value > this.totalFrames - 1) {
            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
          }
          const previousFrame = this.currentFrame;
          this._currentTime = value;
          if (previousFrame !== this.currentFrame) {
            this._updateTexture();
          }
        }
        /**
         * Indicates if the AnimatedSprite is currently playing.
         * @readonly
         */
        get playing() {
          return this._playing;
        }
        /** Whether to use Ticker.shared to auto update animation time. */
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
              Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/misc/Transform.mjs
  var Transform;
  var init_Transform = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/misc/Transform.mjs"() {
      init_Matrix();
      init_ObservablePoint();
      Transform = class {
        /**
         * @param options - Options for the transform.
         * @param options.matrix - The matrix to use.
         * @param options.observer - The observer to use.
         */
        constructor({ matrix, observer } = {}) {
          this.dirty = true;
          this._matrix = matrix ?? new Matrix();
          this.observer = observer;
          this.position = new ObservablePoint(this, 0, 0);
          this.scale = new ObservablePoint(this, 1, 1);
          this.pivot = new ObservablePoint(this, 0, 0);
          this.skew = new ObservablePoint(this, 0, 0);
          this._rotation = 0;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
        }
        /**
         * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
         * properties into a single matrix.
         * @readonly
         */
        get matrix() {
          const lt = this._matrix;
          if (!this.dirty)
            return lt;
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this.dirty = false;
          return lt;
        }
        /**
         * Called when a value changes.
         * @param point
         * @internal
         * @private
         */
        _onUpdate(point) {
          this.dirty = true;
          if (point === this.skew) {
            this.updateSkew();
          }
          this.observer?._onUpdate(this);
        }
        /** Called when the skew or the rotation changes. */
        updateSkew() {
          this._cx = Math.cos(this._rotation + this.skew.y);
          this._sx = Math.sin(this._rotation + this.skew.y);
          this._cy = -Math.sin(this._rotation - this.skew.x);
          this._sy = Math.cos(this._rotation - this.skew.x);
          this.dirty = true;
        }
        toString() {
          return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
        }
        /**
         * Decomposes a matrix and sets the transforms properties based on it.
         * @param matrix - The matrix to decompose
         */
        setFromMatrix(matrix) {
          matrix.decompose(this);
          this.dirty = true;
        }
        /** The rotation of the object in radians. */
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this.skew);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
  var _TilingSprite, TilingSprite;
  var init_TilingSprite = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs"() {
      init_Cache();
      init_ObservablePoint();
      init_Texture();
      init_deprecation();
      init_Transform();
      init_ViewContainer();
      _TilingSprite = class _TilingSprite2 extends ViewContainer {
        constructor(...args) {
          let options = args[0] || {};
          if (options instanceof Texture) {
            options = { texture: options };
          }
          if (args.length > 1) {
            deprecation(v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead");
            options.width = args[1];
            options.height = args[2];
          }
          options = { ..._TilingSprite2.defaultOptions, ...options };
          const {
            texture,
            anchor,
            tilePosition,
            tileScale,
            tileRotation,
            width,
            height,
            applyAnchorToTexture,
            roundPixels,
            ...rest
          } = options ?? {};
          super({
            label: "TilingSprite",
            ...rest
          });
          this.renderPipeId = "tilingSprite";
          this.batched = true;
          this.allowChildren = false;
          this._anchor = new ObservablePoint(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          this._applyAnchorToTexture = applyAnchorToTexture;
          this.texture = texture;
          this._width = width ?? texture.width;
          this._height = height ?? texture.height;
          this._tileTransform = new Transform({
            observer: {
              _onUpdate: () => this.onViewUpdate()
            }
          });
          if (anchor)
            this.anchor = anchor;
          this.tilePosition = tilePosition;
          this.tileScale = tileScale;
          this.tileRotation = tileRotation;
          this.roundPixels = roundPixels ?? false;
        }
        /**
         * Creates a new tiling sprite.
         * @param source - The source to create the texture from.
         * @param options - The options for creating the tiling sprite.
         * @returns A new tiling sprite.
         */
        static from(source7, options = {}) {
          if (typeof source7 === "string") {
            return new _TilingSprite2({
              texture: Cache.get(source7),
              ...options
            });
          }
          return new _TilingSprite2({
            texture: source7,
            ...options
          });
        }
        /**
         * Changes frame clamping in corresponding textureMatrix
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         * @default 0.5
         * @member {number}
         */
        get clampMargin() {
          return this._texture.textureMatrix.clampMargin;
        }
        set clampMargin(value) {
          this._texture.textureMatrix.clampMargin = value;
        }
        /**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
         * and passed to the constructor.
         *
         * The default is `(0,0)`, this means the sprite's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * import { TilingSprite } from 'pixi.js';
         *
         * const sprite = new TilingSprite({texture: Texture.WHITE});
         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         */
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        /** The offset of the image that is being tiled. */
        get tilePosition() {
          return this._tileTransform.position;
        }
        set tilePosition(value) {
          this._tileTransform.position.copyFrom(value);
        }
        /** The scaling of the image that is being tiled. */
        get tileScale() {
          return this._tileTransform.scale;
        }
        set tileScale(value) {
          typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
        }
        set tileRotation(value) {
          this._tileTransform.rotation = value;
        }
        /** The rotation of the image that is being tiled. */
        get tileRotation() {
          return this._tileTransform.rotation;
        }
        /** The transform of the image that is being tiled. */
        get tileTransform() {
          return this._tileTransform;
        }
        /**
         * The local bounds of the sprite.
         * @type {rendering.Bounds}
         */
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        set texture(value) {
          value || (value = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          this._texture = value;
          this.onViewUpdate();
        }
        /** The texture that the sprite is using. */
        get texture() {
          return this._texture;
        }
        /** The width of the tiling area. */
        set width(value) {
          this._width = value;
          this.onViewUpdate();
        }
        get width() {
          return this._width;
        }
        set height(value) {
          this._height = value;
          this.onViewUpdate();
        }
        /** The height of the tiling area. */
        get height() {
          return this._height;
        }
        /**
         * Sets the size of the TilingSprite to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value, height) {
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          }
          this._width = value;
          this._height = height ?? value;
          this.onViewUpdate();
        }
        /**
         * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the TilingSprite.
         */
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = this._width;
          out2.height = this._height;
          return out2;
        }
        _updateBounds() {
          const bounds = this._bounds;
          const anchor = this._anchor;
          const width = this._width;
          const height = this._height;
          bounds.maxX = -anchor._x * width;
          bounds.minX = bounds.maxX + width;
          bounds.maxY = -anchor._y * height;
          bounds.minY = bounds.maxY + height;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          const _bounds = this.bounds;
          bounds.addFrame(
            _bounds.minX,
            _bounds.minY,
            _bounds.maxX,
            _bounds.maxY
          );
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const width = this._width;
          const height = this._height;
          const x1 = -width * this._anchor._x;
          let y1 = 0;
          if (point.x >= x1 && point.x <= x1 + width) {
            y1 = -height * this._anchor._y;
            if (point.y >= y1 && point.y <= y1 + height)
              return true;
          }
          return false;
        }
        onViewUpdate() {
          this._boundsDirty = true;
          super.onViewUpdate();
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options = false) {
          super.destroy(options);
          this._anchor = null;
          this._tileTransform = null;
          this._bounds = null;
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
        }
      };
      _TilingSprite.defaultOptions = {
        /** The texture to use for the sprite. */
        texture: Texture.EMPTY,
        /** The anchor point of the sprite */
        anchor: { x: 0, y: 0 },
        /** The offset of the image that is being tiled. */
        tilePosition: { x: 0, y: 0 },
        /** Scaling of the image that is being tiled. */
        tileScale: { x: 1, y: 1 },
        /** The rotation of the image that is being tiled. */
        tileRotation: 0,
        /** TODO */
        applyAnchorToTexture: false
      };
      TilingSprite = _TilingSprite;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/AbstractText.mjs
  function ensureOptions(args, name) {
    let options = args[0] ?? {};
    if (typeof options === "string" || args[1]) {
      deprecation(v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
      options = {
        text: options,
        style: args[1]
      };
    }
    return options;
  }
  var AbstractText;
  var init_AbstractText = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/AbstractText.mjs"() {
      init_ObservablePoint();
      init_deprecation();
      init_ViewContainer();
      AbstractText = class extends ViewContainer {
        constructor(options, styleClass) {
          const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;
          super({
            ...rest
          });
          this.batched = true;
          this._resolution = null;
          this._autoResolution = true;
          this._didTextUpdate = true;
          this._styleClass = styleClass;
          this.text = text ?? "";
          this.style = style;
          this.resolution = resolution ?? null;
          this.allowChildren = false;
          this._anchor = new ObservablePoint(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          if (anchor)
            this.anchor = anchor;
          this.roundPixels = roundPixels ?? false;
          if (width !== void 0)
            this.width = width;
          if (height !== void 0)
            this.height = height;
        }
        /**
         * The anchor sets the origin point of the text.
         * The default is `(0,0)`, this means the text's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * import { Text } from 'pixi.js';
         *
         * const text = new Text('hello world');
         * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         */
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        /** Set the copy for the text object. To split a line you can use '\n'. */
        set text(value) {
          value = value.toString();
          if (this._text === value)
            return;
          this._text = value;
          this.onViewUpdate();
        }
        get text() {
          return this._text;
        }
        /**
         * The resolution / device pixel ratio of the canvas.
         * @default 1
         */
        set resolution(value) {
          this._autoResolution = value === null;
          this._resolution = value;
          this.onViewUpdate();
        }
        get resolution() {
          return this._resolution;
        }
        get style() {
          return this._style;
        }
        /**
         * Set the style of the text.
         *
         * Set up an event listener to listen for changes on the style object and mark the text as dirty.
         *
         * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
         * @type {
         * text.TextStyle |
         * Partial<text.TextStyle> |
         * text.TextStyleOptions |
         * text.HTMLTextStyle |
         * Partial<text.HTMLTextStyle> |
         * text.HTMLTextStyleOptions
         * }
         */
        set style(style) {
          style = style || {};
          this._style?.off("update", this.onViewUpdate, this);
          if (style instanceof this._styleClass) {
            this._style = style;
          } else {
            this._style = new this._styleClass(style);
          }
          this._style.on("update", this.onViewUpdate, this);
          this.onViewUpdate();
        }
        /**
         * The local bounds of the Text.
         * @type {rendering.Bounds}
         */
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
        get width() {
          return Math.abs(this.scale.x) * this.bounds.width;
        }
        set width(value) {
          this._setWidth(value, this.bounds.width);
        }
        /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
        get height() {
          return Math.abs(this.scale.y) * this.bounds.height;
        }
        set height(value) {
          this._setHeight(value, this.bounds.height);
        }
        /**
         * Retrieves the size of the Text as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the Text.
         */
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = Math.abs(this.scale.x) * this.bounds.width;
          out2.height = Math.abs(this.scale.y) * this.bounds.height;
          return out2;
        }
        /**
         * Sets the size of the Text to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value, height) {
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          } else {
            height ?? (height = value);
          }
          value !== void 0 && this._setWidth(value, this.bounds.width);
          height !== void 0 && this._setHeight(height, this.bounds.height);
        }
        /**
         * Adds the bounds of this text to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          const _bounds = this.bounds;
          bounds.addFrame(
            _bounds.minX,
            _bounds.minY,
            _bounds.maxX,
            _bounds.maxY
          );
        }
        /**
         * Checks if the text contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const width = this.bounds.width;
          const height = this.bounds.height;
          const x1 = -width * this.anchor.x;
          let y1 = 0;
          if (point.x >= x1 && point.x <= x1 + width) {
            y1 = -height * this.anchor.y;
            if (point.y >= y1 && point.y <= y1 + height)
              return true;
          }
          return false;
        }
        onViewUpdate() {
          this._boundsDirty = true;
          if (!this.didViewUpdate)
            this._didTextUpdate = true;
          super.onViewUpdate();
        }
        _getKey() {
          return `${this.text}:${this._style.styleKey}:${this._resolution}`;
        }
        /**
         * Destroys this text renderable and optionally its style texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
         * @param {boolean} [options.style=false] - Should it destroy the style of the text
         */
        destroy(options = false) {
          super.destroy(options);
          this.owner = null;
          this._bounds = null;
          this._anchor = null;
          if (typeof options === "boolean" ? options : options?.style) {
            this._style.destroy(options);
          }
          this._style = null;
          this._text = null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/Text.mjs
  var Text;
  var init_Text = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/Text.mjs"() {
      init_AbstractText();
      init_CanvasTextMetrics();
      init_TextStyle();
      Text = class extends AbstractText {
        constructor(...args) {
          const options = ensureOptions(args, "Text");
          super(options, TextStyle);
          this.renderPipeId = "text";
        }
        _updateBounds() {
          const bounds = this._bounds;
          const anchor = this._anchor;
          const canvasMeasurement = CanvasTextMetrics.measureText(
            this._text,
            this._style
          );
          const { width, height } = canvasMeasurement;
          bounds.minX = -anchor._x * width;
          bounds.maxX = bounds.minX + width;
          bounds.minY = -anchor._y * height;
          bounds.maxY = bounds.minY + height;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareQueue.mjs
  var PrepareQueue;
  var init_PrepareQueue = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareQueue.mjs"() {
      init_TextureSource();
      init_Texture();
      init_Container();
      init_Graphics();
      init_GraphicsContext();
      init_Mesh();
      init_Sprite();
      init_AnimatedSprite();
      init_TilingSprite();
      init_Text();
      init_PrepareBase();
      PrepareQueue = class extends PrepareBase {
        /**
         * Resolve the given resource type and return an item for the queue
         * @param source
         * @param queue
         */
        resolveQueueItem(source7, queue) {
          if (source7 instanceof Container) {
            this.resolveContainerQueueItem(source7, queue);
          } else if (source7 instanceof TextureSource || source7 instanceof Texture) {
            queue.push(source7.source);
          } else if (source7 instanceof GraphicsContext) {
            queue.push(source7);
          }
          return null;
        }
        /**
         * Resolve the given container and return an item for the queue
         * @param container
         * @param queue
         */
        resolveContainerQueueItem(container, queue) {
          if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh) {
            queue.push(container.texture.source);
          } else if (container instanceof Text) {
            queue.push(container);
          } else if (container instanceof Graphics) {
            queue.push(container.context);
          } else if (container instanceof AnimatedSprite) {
            container.textures.forEach((textureOrFrame) => {
              if (textureOrFrame.source) {
                queue.push(textureOrFrame.source);
              } else {
                queue.push(textureOrFrame.texture.source);
              }
            });
          }
        }
        /**
         * Resolve the given graphics context and return an item for the queue
         * @param graphicsContext
         */
        resolveGraphicsContextQueueItem(graphicsContext) {
          this.renderer.graphicsContext.getContextRenderData(graphicsContext);
          const { instructions } = graphicsContext;
          for (const instruction of instructions) {
            if (instruction.action === "texture") {
              const { image } = instruction.data;
              return image.source;
            } else if (instruction.action === "fill") {
              const { texture } = instruction.data.style;
              return texture.source;
            }
          }
          return null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs
  var BitmapText;
  var init_BitmapText = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs"() {
      init_warn();
      init_AbstractText();
      init_TextStyle();
      init_BitmapFontManager();
      BitmapText = class extends AbstractText {
        constructor(...args) {
          var _a;
          const options = ensureOptions(args, "BitmapText");
          options.style ?? (options.style = options.style || {});
          (_a = options.style).fill ?? (_a.fill = 16777215);
          super(options, TextStyle);
          this.renderPipeId = "bitmapText";
        }
        _updateBounds() {
          const bounds = this._bounds;
          const anchor = this._anchor;
          const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
          const scale = bitmapMeasurement.scale;
          const offset = bitmapMeasurement.offsetY * scale;
          let width = bitmapMeasurement.width * scale;
          let height = bitmapMeasurement.height * scale;
          const stroke = this._style._stroke;
          if (stroke) {
            width += stroke.width;
            height += stroke.width;
          }
          bounds.minX = -anchor._x * width;
          bounds.maxX = bounds.minX + width;
          bounds.minY = -anchor._y * (height + offset);
          bounds.maxY = bounds.minY + height;
        }
        /**
         * The resolution / device pixel ratio of the canvas.
         * @default 1
         */
        set resolution(value) {
          if (value !== null) {
            warn(
              // eslint-disable-next-line max-len
              "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
            );
          }
        }
        get resolution() {
          return this._resolution;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs
  var HTMLText;
  var init_HTMLText = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs"() {
      init_AbstractText();
      init_HtmlTextStyle();
      init_measureHtmlText();
      HTMLText = class extends AbstractText {
        constructor(...args) {
          const options = ensureOptions(args, "HtmlText");
          super(options, HTMLTextStyle);
          this.renderPipeId = "htmlText";
        }
        _updateBounds() {
          const bounds = this._bounds;
          const anchor = this._anchor;
          const htmlMeasurement = measureHtmlText(this.text, this._style);
          const { width, height } = htmlMeasurement;
          bounds.minX = -anchor._x * width;
          bounds.maxX = bounds.minX + width;
          bounds.minY = -anchor._y * height;
          bounds.maxY = bounds.minY + height;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareUpload.mjs
  var PrepareUpload;
  var init_PrepareUpload = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareUpload.mjs"() {
      init_TextureSource();
      init_GraphicsContext();
      init_Text();
      init_BitmapText();
      init_HTMLText();
      init_PrepareQueue();
      PrepareUpload = class extends PrepareQueue {
        /**
         * Upload the given queue item
         * @param item
         */
        uploadQueueItem(item) {
          if (item instanceof TextureSource) {
            this.uploadTextureSource(item);
          } else if (item instanceof Text) {
            this.uploadText(item);
          } else if (item instanceof HTMLText) {
            this.uploadHTMLText(item);
          } else if (item instanceof BitmapText) {
            this.uploadBitmapText(item);
          } else if (item instanceof GraphicsContext) {
            this.uploadGraphicsContext(item);
          }
        }
        uploadTextureSource(textureSource) {
          this.renderer.texture.initSource(textureSource);
        }
        uploadText(_text) {
          this.renderer.renderPipes.text.initGpuText(_text);
        }
        uploadBitmapText(_text) {
          this.renderer.renderPipes.bitmapText.initGpuText(_text);
        }
        uploadHTMLText(_text) {
          this.renderer.renderPipes.htmlText.initGpuText(_text);
        }
        /**
         * Resolve the given graphics context and return an item for the queue
         * @param graphicsContext
         */
        uploadGraphicsContext(graphicsContext) {
          this.renderer.graphicsContext.getContextRenderData(graphicsContext);
          const { instructions } = graphicsContext;
          for (const instruction of instructions) {
            if (instruction.action === "texture") {
              const { image } = instruction.data;
              this.uploadTextureSource(image.source);
            } else if (instruction.action === "fill") {
              const { texture } = instruction.data.style;
              this.uploadTextureSource(texture.source);
            }
          }
          return null;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareSystem.mjs
  var PrepareSystem;
  var init_PrepareSystem = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/prepare/PrepareSystem.mjs"() {
      init_Extensions();
      init_PrepareUpload();
      PrepareSystem = class extends PrepareUpload {
        /** Destroys the plugin, don't use after this. */
        destroy() {
          clearTimeout(this.timeout);
          this.renderer = null;
          this.queue = null;
          this.resolves = null;
        }
      };
      PrepareSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "prepare"
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs
  function generateGPULayout(maxTextures2) {
    const gpuLayout = [];
    let bindIndex = 0;
    for (let i3 = 0; i3 < maxTextures2; i3++) {
      gpuLayout[bindIndex] = {
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        },
        binding: bindIndex,
        visibility: GPUShaderStage.FRAGMENT
      };
      bindIndex++;
      gpuLayout[bindIndex] = {
        sampler: {
          type: "filtering"
        },
        binding: bindIndex,
        visibility: GPUShaderStage.FRAGMENT
      };
      bindIndex++;
    }
    return gpuLayout;
  }
  var init_generateGPULayout = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs
  function generateLayout(maxTextures2) {
    const layout = {};
    let bindIndex = 0;
    for (let i3 = 0; i3 < maxTextures2; i3++) {
      layout[`textureSource${i3 + 1}`] = bindIndex++;
      layout[`textureSampler${i3 + 1}`] = bindIndex++;
    }
    return layout;
  }
  var init_generateLayout = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs
  function formatShader(shader) {
    const spl = shader.split(/([\n{}])/g).map((a2) => a2.trim()).filter((a2) => a2.length);
    let indent = "";
    const formatted = spl.map((a2) => {
      let indentedLine = indent + a2;
      if (a2 === "{") {
        indent += "    ";
      } else if (a2 === "}") {
        indent = indent.substr(0, indent.length - 4);
        indentedLine = indent + a2;
      }
      return indentedLine;
    }).join("\n");
    return formatted;
  }
  var init_formatShader = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs
  var ScissorMask;
  var init_ScissorMask = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs"() {
      init_addMaskBounds();
      init_addMaskLocalBounds();
      ScissorMask = class {
        constructor(mask) {
          this.priority = 0;
          this.pipe = "scissorMask";
          this.mask = mask;
          this.mask.renderable = false;
          this.mask.measurable = false;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        reset() {
          this.mask.measurable = true;
          this.mask = null;
        }
        destroy() {
          this.reset();
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs
  function migrateFragmentFromV7toV8(fragmentShader) {
    fragmentShader = fragmentShader.replaceAll("texture2D", "texture").replaceAll("gl_FragColor", "finalColor").replaceAll("varying", "in");
    fragmentShader = `
        out vec4 finalColor;
    ${fragmentShader}
    `;
    return fragmentShader;
  }
  var init_migrateFragmentFromV7toV8 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }
  var GLSL_TO_SIZE;
  var init_mapSize = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs"() {
      "use strict";
      GLSL_TO_SIZE = {
        float: 1,
        vec2: 2,
        vec3: 3,
        vec4: 4,
        int: 1,
        ivec2: 2,
        ivec3: 3,
        ivec4: 4,
        uint: 1,
        uvec2: 2,
        uvec3: 3,
        uvec4: 4,
        bool: 1,
        bvec2: 2,
        bvec3: 3,
        bvec4: 4,
        mat2: 4,
        mat3: 9,
        mat4: 16,
        sampler2D: 1
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs
  function GpuReadBuffer(buffer, renderer) {
    const bufferSize = buffer.descriptor.size;
    const device = renderer.gpu.device;
    const stagingBuffer = new Buffer2({
      data: new Float32Array(24e5),
      usage: BufferUsage.MAP_READ | BufferUsage.COPY_DST
    });
    const stagingGPUBuffer = renderer.buffer.createGPUBuffer(stagingBuffer);
    const commandEncoder = device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(
      renderer.buffer.getGPUBuffer(buffer),
      0,
      // Source offset
      stagingGPUBuffer,
      0,
      // Destination offset
      bufferSize
    );
    device.queue.submit([commandEncoder.finish()]);
    void stagingGPUBuffer.mapAsync(
      GPUMapMode.READ,
      0,
      // Offset
      bufferSize
      // Length
    ).then(() => {
      stagingGPUBuffer.getMappedRange(0, bufferSize);
      stagingGPUBuffer.unmap();
    });
  }
  var init_GpuReadBuffer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs"() {
      init_Buffer();
      init_const4();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs
  var DEPRECATED_DRAW_MODES, DRAW_MODES;
  var init_const14 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs"() {
      init_deprecation();
      DEPRECATED_DRAW_MODES = {
        POINTS: "point-list",
        LINES: "line-list",
        LINE_STRIP: "line-strip",
        TRIANGLES: "triangle-list",
        TRIANGLE_STRIP: "triangle-strip"
      };
      DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {
        get(target, prop) {
          deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);
          return target[prop];
        }
      });
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs
  function viewportFromFrame(viewport, source7, frame) {
    frame || (frame = fullFrame);
    const pixelWidth = source7.pixelWidth;
    const pixelHeight = source7.pixelHeight;
    viewport.x = frame.x * pixelWidth | 0;
    viewport.y = frame.y * pixelHeight | 0;
    viewport.width = frame.width * pixelWidth | 0;
    viewport.height = frame.height * pixelHeight | 0;
    return viewport;
  }
  var fullFrame;
  var init_viewportFromFrame = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs"() {
      init_Rectangle();
      fullFrame = new Rectangle(0, 0, 1, 1);
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs
  var MSAA_QUALITY, DEPRECATED_WRAP_MODES, WRAP_MODES, DEPRECATED_SCALE_MODES, SCALE_MODES;
  var init_const15 = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs"() {
      init_deprecation();
      MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
        MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
        MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
        MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
        MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
        return MSAA_QUALITY2;
      })(MSAA_QUALITY || {});
      DEPRECATED_WRAP_MODES = /* @__PURE__ */ ((DEPRECATED_WRAP_MODES2) => {
        DEPRECATED_WRAP_MODES2["CLAMP"] = "clamp-to-edge";
        DEPRECATED_WRAP_MODES2["REPEAT"] = "repeat";
        DEPRECATED_WRAP_MODES2["MIRRORED_REPEAT"] = "mirror-repeat";
        return DEPRECATED_WRAP_MODES2;
      })(DEPRECATED_WRAP_MODES || {});
      WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {
        get(target, prop) {
          deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);
          return target[prop];
        }
      });
      DEPRECATED_SCALE_MODES = /* @__PURE__ */ ((DEPRECATED_SCALE_MODES2) => {
        DEPRECATED_SCALE_MODES2["NEAREST"] = "nearest";
        DEPRECATED_SCALE_MODES2["LINEAR"] = "linear";
        return DEPRECATED_SCALE_MODES2;
      })(DEPRECATED_SCALE_MODES || {});
      SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {
        get(target, prop) {
          deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);
          return target[prop];
        }
      });
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs
  var TextureUvs;
  var init_TextureUvs = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs"() {
      init_groupD8();
      TextureUvs = class {
        constructor() {
          this.x0 = 0;
          this.y0 = 0;
          this.x1 = 1;
          this.y1 = 0;
          this.x2 = 1;
          this.y2 = 1;
          this.x3 = 0;
          this.y3 = 1;
          this.uvsFloat32 = new Float32Array(8);
        }
        /**
         * Sets the texture Uvs based on the given frame information.
         * @protected
         * @param frame - The frame of the texture
         * @param baseFrame - The base frame of the texture
         * @param rotate - Rotation of frame, see {@link groupD8}
         */
        set(frame, baseFrame, rotate) {
          const tw = baseFrame.width;
          const th = baseFrame.height;
          if (rotate) {
            const w2 = frame.width / 2 / tw;
            const h2 = frame.height / 2 / th;
            const cX = frame.x / tw + w2;
            const cY = frame.y / th + h2;
            rotate = groupD8.add(rotate, groupD8.NW);
            this.x0 = cX + w2 * groupD8.uX(rotate);
            this.y0 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            this.x1 = cX + w2 * groupD8.uX(rotate);
            this.y1 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            this.x2 = cX + w2 * groupD8.uX(rotate);
            this.y2 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            this.x3 = cX + w2 * groupD8.uX(rotate);
            this.y3 = cY + h2 * groupD8.uY(rotate);
          } else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;
            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;
            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;
            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
          }
          this.uvsFloat32[0] = this.x0;
          this.uvsFloat32[1] = this.y0;
          this.uvsFloat32[2] = this.x1;
          this.uvsFloat32[3] = this.y1;
          this.uvsFloat32[4] = this.x2;
          this.uvsFloat32[5] = this.y2;
          this.uvsFloat32[6] = this.x3;
          this.uvsFloat32[7] = this.y3;
        }
        toString() {
          return `[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs
  function generateUID() {
    return uidCount++;
  }
  var uidCount;
  var init_generateUID = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs"() {
      "use strict";
      uidCount = 0;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs
  function parseFunctionBody(fn) {
    const fnStr = fn.toString();
    const bodyStart = fnStr.indexOf("{");
    const bodyEnd = fnStr.lastIndexOf("}");
    if (bodyStart === -1 || bodyEnd === -1) {
      throw new Error("getFunctionBody: No body found in function definition");
    }
    return fnStr.slice(bodyStart + 1, bodyEnd).trim();
  }
  var init_parseFunctionBody = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderContainer.mjs
  var RenderContainer;
  var init_RenderContainer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/RenderContainer.mjs"() {
      init_Bounds();
      init_Container();
      RenderContainer = class extends Container {
        /**
         * @param options - The options for the container.
         */
        constructor(options) {
          if (typeof options === "function") {
            options = { render: options };
          }
          const { render: render3, ...rest } = options;
          super({
            label: "RenderContainer",
            ...rest
          });
          this.batched = false;
          this._lastUsed = 0;
          this._lastInstructionTick = -1;
          this.bounds = new Bounds();
          this.canBundle = false;
          this.renderPipeId = "customRender";
          if (render3)
            this.render = render3;
          this.containsPoint = options.containsPoint ?? (() => false);
          this.addBounds = options.addBounds ?? (() => false);
        }
        /**
         * An overridable function that can be used to render the object using the current renderer.
         * @param _renderer - The current renderer
         */
        render(_renderer) {
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs
  function updateLocalTransform(lt, container) {
    const scale = container._scale;
    const pivot = container._pivot;
    const position = container._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    lt.a = container._cx * sx;
    lt.b = container._sx * sx;
    lt.c = container._cy * sy;
    lt.d = container._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c);
    lt.ty = position._y - (px * lt.b + py * lt.d);
  }
  var init_updateLocalTransform = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs
  function updateWorldTransform(local, parent, world) {
    const lta = local.a;
    const ltb = local.b;
    const ltc = local.c;
    const ltd = local.d;
    const lttx = local.tx;
    const ltty = local.ty;
    const pta = parent.a;
    const ptb = parent.b;
    const ptc = parent.c;
    const ptd = parent.d;
    world.a = lta * pta + ltb * ptc;
    world.b = lta * ptb + ltb * ptd;
    world.c = ltc * pta + ltd * ptc;
    world.d = ltc * ptb + ltd * ptd;
    world.tx = lttx * pta + ltty * ptc + parent.tx;
    world.ty = lttx * ptb + ltty * ptd + parent.ty;
  }
  var init_updateWorldTransform = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs
  function buildGeometryFromPath(options) {
    if (options instanceof GraphicsPath) {
      options = {
        path: options,
        textureMatrix: null,
        out: null
      };
    }
    const vertices = [];
    const uvs = [];
    const indices = [];
    const shapePath = options.path.shapePath;
    const textureMatrix = options.textureMatrix;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) => {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = buildMap[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      const uvsOffset = uvs.length / 2;
      if (textureMatrix) {
        if (matrix) {
          textureMatrix.append(matrix.clone().invert());
        }
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
    });
    const out2 = options.out;
    if (out2) {
      out2.positions = new Float32Array(vertices);
      out2.uvs = new Float32Array(uvs);
      out2.indices = new Uint32Array(indices);
      return out2;
    }
    const geometry = new MeshGeometry({
      positions: new Float32Array(vertices),
      uvs: new Float32Array(uvs),
      indices: new Uint32Array(indices)
    });
    return geometry;
  }
  var buildMap;
  var init_buildGeometryFromPath = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs"() {
      init_buildUvs();
      init_transformVertices();
      init_MeshGeometry();
      init_buildCircle();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_GraphicsPath();
      buildMap = {
        rectangle: buildRectangle,
        polygon: buildPolygon,
        triangle: buildTriangle,
        circle: buildCircle,
        ellipse: buildCircle,
        roundedRectangle: buildCircle
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs
  function applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {
    const buffer = geometry.buffers[0];
    const vertices = buffer.data;
    const { verticesX, verticesY } = geometry;
    const sizeX = width / (verticesX - 1);
    const sizeY = height / (verticesY - 1);
    let index = 0;
    const a00 = transformationMatrix[0];
    const a01 = transformationMatrix[1];
    const a02 = transformationMatrix[2];
    const a10 = transformationMatrix[3];
    const a11 = transformationMatrix[4];
    const a12 = transformationMatrix[5];
    const a20 = transformationMatrix[6];
    const a21 = transformationMatrix[7];
    const a22 = transformationMatrix[8];
    for (let i3 = 0; i3 < vertices.length; i3 += 2) {
      const x2 = index % verticesX * sizeX;
      const y2 = (index / verticesX | 0) * sizeY;
      const newX = a00 * x2 + a01 * y2 + a02;
      const newY = a10 * x2 + a11 * y2 + a12;
      const w2 = a20 * x2 + a21 * y2 + a22;
      vertices[i3] = newX / w2;
      vertices[i3 + 1] = newY / w2;
      index++;
    }
    buffer.update();
  }
  var init_applyProjectiveTransformationToPlane = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs
  function computeAdjugate(out2, matrix) {
    const a00 = matrix[0];
    const a01 = matrix[1];
    const a02 = matrix[2];
    const a10 = matrix[3];
    const a11 = matrix[4];
    const a12 = matrix[5];
    const a20 = matrix[6];
    const a21 = matrix[7];
    const a22 = matrix[8];
    out2[0] = a11 * a22 - a12 * a21;
    out2[1] = a02 * a21 - a01 * a22;
    out2[2] = a01 * a12 - a02 * a11;
    out2[3] = a12 * a20 - a10 * a22;
    out2[4] = a00 * a22 - a02 * a20;
    out2[5] = a02 * a10 - a00 * a12;
    out2[6] = a10 * a21 - a11 * a20;
    out2[7] = a01 * a20 - a00 * a21;
    out2[8] = a00 * a11 - a01 * a10;
    return out2;
  }
  function multiplyMatrix3x3(out2, a2, b2) {
    const a00 = a2[0];
    const a01 = a2[1];
    const a02 = a2[2];
    const a10 = a2[3];
    const a11 = a2[4];
    const a12 = a2[5];
    const a20 = a2[6];
    const a21 = a2[7];
    const a22 = a2[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out2[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out2[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out2[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out2[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out2[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out2[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out2[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out2[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out2[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out2;
  }
  function multiplyMatrixAndVector(out2, m2, v2) {
    const x2 = v2[0];
    const y2 = v2[1];
    const z = v2[2];
    out2[0] = m2[0] * x2 + m2[1] * y2 + m2[2] * z;
    out2[1] = m2[3] * x2 + m2[4] * y2 + m2[5] * z;
    out2[2] = m2[6] * x2 + m2[7] * y2 + m2[8] * z;
    return out2;
  }
  function generateBasisToPointsMatrix(out2, x1, y1, x2, y2, x3, y3, x4, y4) {
    const m2 = tempMatrix6;
    m2[0] = x1;
    m2[1] = x2;
    m2[2] = x3;
    m2[3] = y1;
    m2[4] = y2;
    m2[5] = y3;
    m2[6] = 1;
    m2[7] = 1;
    m2[8] = 1;
    const adjugateM = computeAdjugate(
      out2,
      // reusing out as adjugateM is only used once
      m2
    );
    tempVec2[0] = x4;
    tempVec2[1] = y4;
    tempVec2[2] = 1;
    const v2 = multiplyMatrixAndVector(
      tempVec,
      adjugateM,
      tempVec2
    );
    const diagonalMatrix = out2;
    out2[0] = v2[0];
    out2[1] = 0;
    out2[2] = 0;
    out2[3] = 0;
    out2[4] = v2[1];
    out2[5] = 0;
    out2[6] = 0;
    out2[7] = 0;
    out2[8] = v2[2];
    return multiplyMatrix3x3(out2, diagonalMatrix, m2);
  }
  function compute2DProjection(out2, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
    const sourceMatrix = generateBasisToPointsMatrix(
      tempSourceMatrix,
      x1s,
      y1s,
      x2s,
      y2s,
      x3s,
      y3s,
      x4s,
      y4s
    );
    const destinationMatrix = generateBasisToPointsMatrix(
      tempDestinationMatrix,
      x1d,
      y1d,
      x2d,
      y2d,
      x3d,
      y3d,
      x4d,
      y4d
    );
    return multiplyMatrix3x3(
      out2,
      computeAdjugate(sourceMatrix, sourceMatrix),
      destinationMatrix
    );
  }
  var tempMatrix6, tempVec, tempVec2, tempSourceMatrix, tempDestinationMatrix;
  var init_compute2DProjections = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs"() {
      "use strict";
      tempMatrix6 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      tempVec = [0, 0, 0];
      tempVec2 = [0, 0, 0];
      tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs
  var PerspectivePlaneGeometry;
  var init_PerspectivePlaneGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs"() {
      init_PlaneGeometry();
      init_applyProjectiveTransformationToPlane();
      init_compute2DProjections();
      PerspectivePlaneGeometry = class extends PlaneGeometry {
        /**
         * @param options - Options to be applied to MeshPlane
         * @param options.width - The width of the plane
         * @param options.height - The height of the plane
         * @param options.verticesX - The amount of vertices on the x axis
         * @param options.verticesY - The amount of vertices on the y axis
         */
        constructor(options) {
          super(options);
          this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
          const { width, height } = options;
          this.corners = [0, 0, width, 0, width, height, 0, height];
        }
        /**
         * Will set the corners of the quad to the given coordinates
         * Calculating the perspective so it looks correct!
         * @param x0 - x coordinate of the first corner
         * @param y0 - y coordinate of the first corner
         * @param x1 - x coordinate of the second corner
         * @param y1 - y coordinate of the second corner
         * @param x2 - x coordinate of the third corner
         * @param y2 - y coordinate of the third corner
         * @param x3 - x coordinate of the fourth corner
         * @param y3 - y coordinate of the fourth corner
         */
        setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
          const corners = this.corners;
          corners[0] = x0;
          corners[1] = y0;
          corners[2] = x1;
          corners[3] = y1;
          corners[4] = x2;
          corners[5] = y2;
          corners[6] = x3;
          corners[7] = y3;
          this.updateProjection();
        }
        /** Update the projection matrix based on the corners */
        updateProjection() {
          const { width, height } = this;
          const corners = this.corners;
          const projectionMatrix = compute2DProjection(
            this._projectionMatrix,
            0,
            0,
            // top-left source
            corners[0],
            corners[1],
            // top-left dest
            width,
            0,
            // top-right source
            corners[2],
            corners[3],
            // top-right dest
            width,
            height,
            // bottom-right source
            corners[4],
            corners[5],
            // bottom-right dest
            0,
            height,
            // bottom-left source
            corners[6],
            corners[7]
            // bottom-left dest
          );
          applyProjectiveTransformationToPlane(
            width,
            height,
            this,
            projectionMatrix
          );
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs
  var _PerspectiveMesh, PerspectiveMesh;
  var init_PerspectiveMesh = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs"() {
      init_Texture();
      init_definedProps();
      init_Mesh();
      init_PerspectivePlaneGeometry();
      _PerspectiveMesh = class _PerspectiveMesh2 extends Mesh {
        /**
         * @param options - Options to be applied to PerspectiveMesh
         */
        constructor(options) {
          options = { ..._PerspectiveMesh2.defaultOptions, ...options };
          const { texture, verticesX, verticesY, ...rest } = options;
          const planeGeometry = new PerspectivePlaneGeometry(definedProps({
            width: texture.width,
            height: texture.height,
            verticesX,
            verticesY
          }));
          super(definedProps({ ...rest, geometry: planeGeometry }));
          this._texture = texture;
          this.geometry.setCorners(
            options.x0,
            options.y0,
            options.x1,
            options.y1,
            options.x2,
            options.y2,
            options.x3,
            options.y3
          );
        }
        /** Update the geometry when the texture is updated */
        textureUpdated() {
          const geometry = this.geometry;
          if (!geometry)
            return;
          const { width, height } = this.texture;
          if (geometry.width !== width || geometry.height !== height) {
            geometry.width = width;
            geometry.height = height;
            geometry.updateProjection();
          }
        }
        set texture(value) {
          if (this._texture === value)
            return;
          super.texture = value;
          this.textureUpdated();
        }
        /** The texture that the mesh uses */
        get texture() {
          return this._texture;
        }
        /**
         * Set the corners of the quad to the given coordinates
         * The mesh will then calculate the perspective so it looks correct!
         * @param x0 - x coordinate of the first corner
         * @param y0 - y coordinate of the first corner
         * @param x1 - x coordinate of the second corner
         * @param y1 - y coordinate of the second corner
         * @param x2 - x coordinate of the third corner
         * @param y2 - y coordinate of the third corner
         * @param x3 - x coordinate of the fourth corner
         * @param y3 - y coordinate of the fourth corner
         */
        setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
          this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);
        }
      };
      _PerspectiveMesh.defaultOptions = {
        texture: Texture.WHITE,
        verticesX: 10,
        verticesY: 10,
        x0: 0,
        y0: 0,
        x1: 100,
        y1: 0,
        x2: 100,
        y2: 100,
        x3: 0,
        y3: 100
      };
      PerspectiveMesh = _PerspectiveMesh;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs
  var MeshPlane;
  var init_MeshPlane = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs"() {
      init_definedProps();
      init_Mesh();
      init_PlaneGeometry();
      MeshPlane = class extends Mesh {
        /**
         * @param options - Options to be applied to MeshPlane
         */
        constructor(options) {
          const { texture, verticesX, verticesY, ...rest } = options;
          const planeGeometry = new PlaneGeometry(definedProps({
            width: texture.width,
            height: texture.height,
            verticesX,
            verticesY
          }));
          super(definedProps({ ...rest, geometry: planeGeometry, texture }));
          this.texture = texture;
          this.autoResize = true;
        }
        /**
         * Method used for overrides, to do something in case texture frame was changed.
         * Meshes based on plane can override it and change more details based on texture.
         */
        textureUpdated() {
          const geometry = this.geometry;
          const { width, height } = this.texture;
          if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
            geometry.width = width;
            geometry.height = height;
            geometry.build({});
          }
        }
        set texture(value) {
          this._texture?.off("update", this.textureUpdated, this);
          super.texture = value;
          value.on("update", this.textureUpdated, this);
          this.textureUpdated();
        }
        /** The texture of the MeshPlane */
        get texture() {
          return this._texture;
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options) {
          this.texture.off("update", this.textureUpdated, this);
          super.destroy(options);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs
  var _RopeGeometry, RopeGeometry;
  var init_RopeGeometry = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs"() {
      init_MeshGeometry();
      _RopeGeometry = class _RopeGeometry2 extends MeshGeometry {
        /**
         * @param options - Options to be applied to rope geometry
         */
        constructor(options) {
          const { width, points, textureScale } = { ..._RopeGeometry2.defaultOptions, ...options };
          super({
            positions: new Float32Array(points.length * 4),
            uvs: new Float32Array(points.length * 4),
            indices: new Uint32Array((points.length - 1) * 6)
          });
          this.points = points;
          this._width = width;
          this.textureScale = textureScale;
          this._build();
        }
        /**
         * The width (i.e., thickness) of the rope.
         * @readonly
         */
        get width() {
          return this._width;
        }
        /** Refreshes Rope indices and uvs */
        _build() {
          const points = this.points;
          if (!points)
            return;
          const vertexBuffer = this.getBuffer("aPosition");
          const uvBuffer = this.getBuffer("aUV");
          const indexBuffer = this.getIndex();
          if (points.length < 1) {
            return;
          }
          if (vertexBuffer.data.length / 4 !== points.length) {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
          }
          const uvs = uvBuffer.data;
          const indices = indexBuffer.data;
          uvs[0] = 0;
          uvs[1] = 0;
          uvs[2] = 0;
          uvs[3] = 1;
          let amount = 0;
          let prev = points[0];
          const textureWidth = this._width * this.textureScale;
          const total = points.length;
          for (let i3 = 0; i3 < total; i3++) {
            const index = i3 * 4;
            if (this.textureScale > 0) {
              const dx = prev.x - points[i3].x;
              const dy = prev.y - points[i3].y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              prev = points[i3];
              amount += distance / textureWidth;
            } else {
              amount = i3 / (total - 1);
            }
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
          }
          let indexCount = 0;
          for (let i3 = 0; i3 < total - 1; i3++) {
            const index = i3 * 2;
            indices[indexCount++] = index;
            indices[indexCount++] = index + 1;
            indices[indexCount++] = index + 2;
            indices[indexCount++] = index + 2;
            indices[indexCount++] = index + 1;
            indices[indexCount++] = index + 3;
          }
          uvBuffer.update();
          indexBuffer.update();
          this.updateVertices();
        }
        /** refreshes vertices of Rope mesh */
        updateVertices() {
          const points = this.points;
          if (points.length < 1) {
            return;
          }
          let lastPoint = points[0];
          let nextPoint;
          let perpX = 0;
          let perpY = 0;
          const vertices = this.buffers[0].data;
          const total = points.length;
          const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          for (let i3 = 0; i3 < total; i3++) {
            const point = points[i3];
            const index = i3 * 4;
            if (i3 < points.length - 1) {
              nextPoint = points[i3 + 1];
            } else {
              nextPoint = point;
            }
            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;
            let ratio = (1 - i3 / (total - 1)) * 10;
            if (ratio > 1) {
              ratio = 1;
            }
            const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
            if (perpLength < 1e-6) {
              perpX = 0;
              perpY = 0;
            } else {
              perpX /= perpLength;
              perpY /= perpLength;
              perpX *= halfWidth;
              perpY *= halfWidth;
            }
            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;
            lastPoint = point;
          }
          this.buffers[0].update();
        }
        /** Refreshes Rope indices and uvs */
        update() {
          if (this.textureScale > 0) {
            this._build();
          } else {
            this.updateVertices();
          }
        }
      };
      _RopeGeometry.defaultOptions = {
        /** The width (i.e., thickness) of the rope. */
        width: 200,
        /** An array of points that determine the rope. */
        points: [],
        /** Rope texture scale, if zero then the rope texture is stretched. */
        textureScale: 0
      };
      RopeGeometry = _RopeGeometry;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs
  var _MeshRope, MeshRope;
  var init_MeshRope = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs"() {
      init_definedProps();
      init_Mesh();
      init_RopeGeometry();
      _MeshRope = class _MeshRope2 extends Mesh {
        /**
         * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
         * @param options
         * @param options.texture - The texture to use on the rope.
         * @param options.points - An array of {@link math.Point} objects to construct this rope.
         * @param {number} options.textureScale - Optional. Positive values scale rope texture
         * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
         * and downsampling here. If set to zero, texture will be stretched instead.
         */
        constructor(options) {
          const { texture, points, textureScale, ...rest } = { ..._MeshRope2.defaultOptions, ...options };
          const ropeGeometry = new RopeGeometry(definedProps({ width: texture.height, points, textureScale }));
          if (textureScale > 0) {
            texture.source.style.addressMode = "repeat";
          }
          super(definedProps({
            ...rest,
            texture,
            geometry: ropeGeometry
          }));
          this.autoUpdate = true;
          this.onRender = this._render;
        }
        _render() {
          const geometry = this.geometry;
          if (this.autoUpdate || geometry._width !== this.texture.height) {
            geometry._width = this.texture.height;
            geometry.update();
          }
        }
      };
      _MeshRope.defaultOptions = {
        textureScale: 0
      };
      MeshRope = _MeshRope;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs
  var MeshSimple;
  var init_MeshSimple = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs"() {
      init_definedProps();
      init_Mesh();
      init_MeshGeometry();
      MeshSimple = class extends Mesh {
        /**
         * @param options - Options to be used for construction
         */
        constructor(options) {
          const { texture, vertices, uvs, indices, topology, ...rest } = options;
          const geometry = new MeshGeometry(definedProps({
            positions: vertices,
            uvs,
            indices,
            topology
          }));
          super(definedProps({
            ...rest,
            texture,
            geometry
          }));
          this.autoUpdate = true;
          this.onRender = this._render;
        }
        /**
         * Collection of vertices data.
         * @type {Float32Array}
         */
        get vertices() {
          return this.geometry.getBuffer("aPosition").data;
        }
        set vertices(value) {
          this.geometry.getBuffer("aPosition").data = value;
        }
        _render() {
          if (this.autoUpdate) {
            this.geometry.getBuffer("aPosition").update();
          }
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs
  function getTextureDefaultMatrix(texture, out2) {
    const { width, height } = texture.frame;
    out2.scale(1 / width, 1 / height);
    return out2;
  }
  var init_getTextureDefaultMatrix = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs
  var _Particle, Particle;
  var init_Particle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs"() {
      init_Color();
      init_Texture();
      init_assignWithIgnore();
      _Particle = class _Particle2 {
        constructor(options) {
          if (options instanceof Texture) {
            this.texture = options;
            assignWithIgnore(this, _Particle2.defaultOptions, {});
          } else {
            const combined = { ..._Particle2.defaultOptions, ...options };
            assignWithIgnore(this, combined, {});
          }
        }
        /** Gets or sets the alpha value of the particle. */
        get alpha() {
          return this._alpha;
        }
        set alpha(value) {
          this._alpha = Math.min(Math.max(value, 0), 1);
          this._updateColor();
        }
        /** Gets or sets the tint color of the particle. */
        get tint() {
          const bgr = this._tint;
          return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
        }
        set tint(value) {
          if (typeof value === "number") {
            this._tint = value;
          } else {
            this._tint = Color.shared.setValue(value ?? 16777215).toBgrNumber();
          }
          this._updateColor();
        }
        _updateColor() {
          this.color = this._tint + ((this._alpha * 255 | 0) << 24);
        }
      };
      _Particle.defaultOptions = {
        anchorX: 0,
        anchorY: 0,
        x: 0,
        y: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0,
        tint: 16777215,
        alpha: 1
      };
      Particle = _Particle;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs
  var particleData;
  var init_particleData = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs"() {
      "use strict";
      particleData = {
        vertex: {
          attributeName: "aVertex",
          format: "float32x2",
          code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
          dynamic: false
        },
        // positionData
        position: {
          attributeName: "aPosition",
          format: "float32x2",
          code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
          dynamic: true
        },
        // rotationData
        rotation: {
          attributeName: "aRotation",
          format: "float32",
          code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
          dynamic: false
        },
        // uvsData
        uvs: {
          attributeName: "aUV",
          format: "float32x2",
          code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
          dynamic: false
        },
        // tintData
        color: {
          attributeName: "aColor",
          format: "unorm8x4",
          code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
          dynamic: false
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs
  var emptyBounds, _ParticleContainer, ParticleContainer;
  var init_ParticleContainer = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs"() {
      init_ViewContainer();
      init_particleData();
      emptyBounds = {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
      };
      _ParticleContainer = class _ParticleContainer2 extends ViewContainer {
        /**
         * @param options - The options for creating the sprite.
         */
        constructor(options = {}) {
          options = {
            ..._ParticleContainer2.defaultOptions,
            ...options,
            dynamicProperties: {
              ..._ParticleContainer2.defaultOptions.dynamicProperties,
              ...options?.dynamicProperties
            }
          };
          const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;
          super({
            label: "ParticleContainer",
            ...rest
          });
          this.renderPipeId = "particle";
          this.batched = false;
          this._childrenDirty = false;
          this.texture = texture || null;
          this.shader = shader;
          this._properties = {};
          for (const key in particleData) {
            const property = particleData[key];
            const dynamic = dynamicProperties[key];
            this._properties[key] = {
              ...property,
              dynamic
            };
          }
          this.allowChildren = true;
          this.roundPixels = roundPixels ?? false;
          this.particleChildren = particles ?? [];
        }
        /**
         * Adds one or more particles to the container.
         *
         * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`
         * @param {...IParticle} children - The Particle(s) to add to the container
         * @returns {IParticle} - The first child that was added.
         */
        addParticle(...children) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.particleChildren.push(children[i3]);
          }
          this.onViewUpdate();
          return children[0];
        }
        /**
         * Removes one or more particles from the container.
         * @param {...IParticle} children - The Particle(s) to remove
         * @returns {IParticle} The first child that was removed.
         */
        removeParticle(...children) {
          let didRemove = false;
          for (let i3 = 0; i3 < children.length; i3++) {
            const index = this.particleChildren.indexOf(children[i3]);
            if (index > -1) {
              this.particleChildren.splice(index, 1);
              didRemove = true;
            }
          }
          if (didRemove)
            this.onViewUpdate();
          return children[0];
        }
        /**
         * Updates the particle container.
         * Please call this when you modify the particleChildren array.
         * or any static properties of the particles.
         */
        update() {
          this._childrenDirty = true;
        }
        onViewUpdate() {
          this._childrenDirty = true;
          super.onViewUpdate();
        }
        /**
         * ParticleContainer does not calculated bounds as it would slow things down,
         * its up to you to set this via the boundsArea property
         */
        get bounds() {
          return emptyBounds;
        }
        /**
         * ParticleContainer does not calculated bounds as it would slow things down,
         * its up to you to set this via the boundsArea property
         * @param _bounds - The output bounds object.
         */
        addBounds(_bounds) {
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options = false) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            const texture = this.texture ?? this.particleChildren[0]?.texture;
            if (texture) {
              texture.destroy(destroyTextureSource);
            }
          }
          this.texture = null;
          this.shader?.destroy();
        }
        /**
         * Removes all particles from this container that are within the begin and end indexes.
         * @param beginIndex - The beginning position.
         * @param endIndex - The ending position. Default value is size of the container.
         * @returns - List of removed particles
         */
        removeParticles(beginIndex, endIndex) {
          const children = this.particleChildren.splice(beginIndex, endIndex);
          this.onViewUpdate();
          return children;
        }
        /**
         * Removes a particle from the specified index position.
         * @param index - The index to get the particle from
         * @returns The particle that was removed.
         */
        removeParticleAt(index) {
          const child = this.particleChildren.splice(index, 1);
          this.onViewUpdate();
          return child[0];
        }
        /**
         * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
         * If the particle is already in this container, it will be moved to the specified index.
         * @param {Container} child - The particle to add.
         * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
         * @returns {Container} The particle that was added.
         */
        addParticleAt(child, index) {
          this.particleChildren.splice(index, 0, child);
          this.onViewUpdate();
          return child;
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.
         * @param {...any} _children
         * @throws {Error} Always throws an error as this method is not available.
         */
        addChild(..._children) {
          throw new Error(
            "ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.
         * @param {...any} _children
         * @throws {Error} Always throws an error as this method is not available.
         */
        removeChild(..._children) {
          throw new Error(
            "ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.
         * @param {number} [_beginIndex]
         * @param {number} [_endIndex]
         * @throws {Error} Always throws an error as this method is not available.
         */
        removeChildren(_beginIndex, _endIndex) {
          throw new Error(
            "ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.
         * @param {number} _index
         * @throws {Error} Always throws an error as this method is not available.
         */
        removeChildAt(_index) {
          throw new Error(
            "ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.
         * @param {number} _index
         * @throws {Error} Always throws an error as this method is not available.
         */
        getChildAt(_index) {
          throw new Error(
            "ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.
         * @param {ContainerChild} _child
         * @param {number} _index
         * @throws {Error} Always throws an error as this method is not available.
         */
        setChildIndex(_child, _index) {
          throw new Error(
            "ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.
         * @param {ContainerChild} _child
         * @throws {Error} Always throws an error as this method is not available.
         */
        getChildIndex(_child) {
          throw new Error(
            "ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.
         * @param {ContainerChild} _child
         * @param {number} _index
         * @throws {Error} Always throws an error as this method is not available.
         */
        addChildAt(_child, _index) {
          throw new Error(
            "ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.
         * @param {ContainerChild} _child
         * @param {ContainerChild} _child2
         */
        swapChildren(_child, _child2) {
          throw new Error(
            "ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()"
          );
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error.
         * @param _child - The child to reparent
         * @throws {Error} Always throws an error as this method is not available.
         */
        reparentChild(..._child) {
          throw new Error("ParticleContainer.reparentChild() is not available with the particle container");
        }
        /**
         * This method is not available in ParticleContainer.
         *
         * Calling this method will throw an error.
         * @param _child - The child to reparent
         * @param _index - The index to reparent the child to
         * @throws {Error} Always throws an error as this method is not available.
         */
        reparentChildAt(_child, _index) {
          throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container");
        }
      };
      _ParticleContainer.defaultOptions = {
        dynamicProperties: {
          vertex: false,
          // Indicates if vertex positions are dynamic.
          position: true,
          // Indicates if particle positions are dynamic.
          rotation: false,
          // Indicates if particle rotations are dynamic.
          uvs: false,
          // Indicates if UV coordinates are dynamic.
          color: false
          // Indicates if particle colors are dynamic.
        },
        roundPixels: false
        // Indicates if pixels should be rounded for rendering.
      };
      ParticleContainer = _ParticleContainer;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs
  var _NineSliceSprite, NineSliceSprite, NineSlicePlane;
  var init_NineSliceSprite = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs"() {
      init_Texture();
      init_deprecation();
      init_ViewContainer();
      init_NineSliceGeometry();
      _NineSliceSprite = class _NineSliceSprite2 extends ViewContainer {
        /**
         * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use
         * @param options.texture - The texture to use on the NineSliceSprite.
         * @param options.leftWidth - Width of the left vertical bar (A)
         * @param options.topHeight - Height of the top horizontal bar (C)
         * @param options.rightWidth - Width of the right vertical bar (B)
         * @param options.bottomHeight - Height of the bottom horizontal bar (D)
         * @param options.width - Width of the NineSliceSprite,
         * setting this will actually modify the vertices and not the UV's of this plane.
         * @param options.height - Height of the NineSliceSprite,
         * setting this will actually modify the vertices and not UV's of this plane.
         */
        constructor(options) {
          if (options instanceof Texture) {
            options = { texture: options };
          }
          const {
            width,
            height,
            leftWidth,
            rightWidth,
            topHeight,
            bottomHeight,
            texture,
            roundPixels,
            ...rest
          } = options;
          super({
            label: "NineSliceSprite",
            ...rest
          });
          this.renderPipeId = "nineSliceSprite";
          this.batched = true;
          this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? NineSliceGeometry.defaultOptions.leftWidth;
          this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? NineSliceGeometry.defaultOptions.topHeight;
          this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? NineSliceGeometry.defaultOptions.rightWidth;
          this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? NineSliceGeometry.defaultOptions.bottomHeight;
          this.bounds.maxX = this._width = width ?? texture.width ?? NineSliceGeometry.defaultOptions.width;
          this.bounds.maxY = this._height = height ?? texture.height ?? NineSliceGeometry.defaultOptions.height;
          this.allowChildren = false;
          this.texture = texture ?? _NineSliceSprite2.defaultOptions.texture;
          this.roundPixels = roundPixels ?? false;
        }
        /** The local bounds of the view. */
        get bounds() {
          return this._bounds;
        }
        /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
        get width() {
          return this._width;
        }
        set width(value) {
          this.bounds.maxX = this._width = value;
          this.onViewUpdate();
        }
        /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
        get height() {
          return this._height;
        }
        set height(value) {
          this.bounds.maxY = this._height = value;
          this.onViewUpdate();
        }
        /**
         * Sets the size of the NiceSliceSprite to the specified width and height.
         * setting this will actually modify the vertices and UV's of this plane
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value, height) {
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          }
          this.bounds.maxX = this._width = value;
          this.bounds.maxY = this._height = height ?? value;
          this.onViewUpdate();
        }
        /**
         * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the NineSliceSprite.
         */
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = this._width;
          out2.height = this._height;
          return out2;
        }
        /** The width of the left column (a) of the NineSliceSprite. */
        get leftWidth() {
          return this._leftWidth;
        }
        set leftWidth(value) {
          this._leftWidth = value;
          this.onViewUpdate();
        }
        /** The width of the right column (b) of the NineSliceSprite. */
        get topHeight() {
          return this._topHeight;
        }
        set topHeight(value) {
          this._topHeight = value;
          this.onViewUpdate();
        }
        /** The width of the right column (b) of the NineSliceSprite. */
        get rightWidth() {
          return this._rightWidth;
        }
        set rightWidth(value) {
          this._rightWidth = value;
          this.onViewUpdate();
        }
        /** The width of the right column (b) of the NineSliceSprite. */
        get bottomHeight() {
          return this._bottomHeight;
        }
        set bottomHeight(value) {
          this._bottomHeight = value;
          this.onViewUpdate();
        }
        /** The texture that the NineSliceSprite is using. */
        get texture() {
          return this._texture;
        }
        set texture(value) {
          value || (value = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          this._texture = value;
          this.onViewUpdate();
        }
        /** The original width of the texture */
        get originalWidth() {
          return this._texture.width;
        }
        /** The original height of the texture */
        get originalHeight() {
          return this._texture.height;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          const _bounds = this.bounds;
          bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
        }
      };
      _NineSliceSprite.defaultOptions = {
        /** @default Texture.EMPTY */
        texture: Texture.EMPTY
      };
      NineSliceSprite = _NineSliceSprite;
      NineSlicePlane = class extends NineSliceSprite {
        constructor(...args) {
          let options = args[0];
          if (options instanceof Texture) {
            deprecation(v8_0_0, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
            options = {
              texture: options,
              leftWidth: args[1],
              topHeight: args[2],
              rightWidth: args[3],
              bottomHeight: args[4]
            };
          }
          deprecation(v8_0_0, "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
          super(options);
        }
      };
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs
  function ensureTextStyle(renderMode, style) {
    if (style instanceof TextStyle || style instanceof HTMLTextStyle) {
      return style;
    }
    return renderMode === "html" ? new HTMLTextStyle(style) : new TextStyle(style);
  }
  var init_ensureTextStyle = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs"() {
      init_HtmlTextStyle();
      init_TextStyle();
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs
  async function logDebugTexture(texture, renderer, size = 200) {
    const base64 = await renderer.extract.base64(texture);
    await renderer.encoder.commandFinished;
    const width = size;
    console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);
    const style = [
      "font-size: 1px;",
      `padding: ${width}px ${300}px;`,
      `background: url(${base64}) no-repeat;`,
      "background-size: contain;"
    ].join(" ");
    console.log("%c ", style);
  }
  var init_logDebugTexture = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/logScene.mjs
  function logScene(container, depth = 0, data = { color: "#000000" }) {
    if (container.renderGroup) {
      data.color = colors[colorTick++];
    }
    let spaces = "";
    for (let i3 = 0; i3 < depth; i3++) {
      spaces += "    ";
    }
    let label = container.label;
    if (!label && container instanceof Sprite) {
      label = `sprite:${container.texture.label}`;
    }
    let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;
    if (container.renderGroup) {
      output += " (RenderGroup)";
    }
    if (container.filters) {
      output += "(*filters)";
    }
    console.log(output, `color:${data.color}; font-weight:bold;`);
    depth++;
    for (let i3 = 0; i3 < container.children.length; i3++) {
      const child = container.children[i3];
      logScene(child, depth, { ...data });
    }
  }
  function logRenderGroupScene(renderGroup, depth = 0, data = { index: 0, color: "#000000" }) {
    let spaces = "";
    for (let i3 = 0; i3 < depth; i3++) {
      spaces += "    ";
    }
    const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;
    console.log(output, `color:${data.color}; font-weight:bold;`);
    depth++;
    for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
      const child = renderGroup.renderGroupChildren[i3];
      logRenderGroupScene(child, depth, { ...data, index: i3 });
    }
  }
  var colors, colorTick;
  var init_logScene = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/utils/logging/logScene.mjs"() {
      init_Sprite();
      colors = [
        "#000080",
        // Navy Blue
        "#228B22",
        // Forest Green
        "#8B0000",
        // Dark Red
        "#4169E1",
        // Royal Blue
        "#008080",
        // Teal
        "#800000",
        // Maroon
        "#9400D3",
        // Dark Violet
        "#FF8C00",
        // Dark Orange
        "#556B2F",
        // Olive Green
        "#8B008B"
        // Dark Magenta
      ];
      colorTick = 0;
    }
  });

  // node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    AbstractBitmapFont: () => AbstractBitmapFont,
    AbstractRenderer: () => AbstractRenderer,
    AbstractText: () => AbstractText,
    AccessibilitySystem: () => AccessibilitySystem,
    AlphaFilter: () => AlphaFilter,
    AlphaMask: () => AlphaMask,
    AlphaMaskPipe: () => AlphaMaskPipe,
    AnimatedSprite: () => AnimatedSprite,
    Application: () => Application,
    ApplicationInitHook: () => ApplicationInitHook,
    Assets: () => Assets,
    AssetsClass: () => AssetsClass,
    BLEND_TO_NPM: () => BLEND_TO_NPM,
    BUFFER_TYPE: () => BUFFER_TYPE,
    BackgroundLoader: () => BackgroundLoader,
    BackgroundSystem: () => BackgroundSystem,
    Batch: () => Batch,
    BatchGeometry: () => BatchGeometry,
    BatchTextureArray: () => BatchTextureArray,
    BatchableGraphics: () => BatchableGraphics,
    BatchableMesh: () => BatchableMesh,
    BatchableSprite: () => BatchableSprite,
    Batcher: () => Batcher,
    BatcherPipe: () => BatcherPipe,
    BigPool: () => BigPool,
    BindGroup: () => BindGroup,
    BindGroupSystem: () => BindGroupSystem,
    BitmapFont: () => BitmapFont,
    BitmapFontManager: () => BitmapFontManager,
    BitmapText: () => BitmapText,
    BitmapTextPipe: () => BitmapTextPipe,
    BlendModeFilter: () => BlendModeFilter,
    BlendModePipe: () => BlendModePipe,
    BlurFilter: () => BlurFilter,
    BlurFilterPass: () => BlurFilterPass,
    Bounds: () => Bounds,
    BrowserAdapter: () => BrowserAdapter,
    Buffer: () => Buffer2,
    BufferImageSource: () => BufferImageSource,
    BufferResource: () => BufferResource,
    BufferUsage: () => BufferUsage,
    CLEAR: () => CLEAR,
    Cache: () => Cache,
    CanvasPool: () => CanvasPool,
    CanvasPoolClass: () => CanvasPoolClass,
    CanvasSource: () => CanvasSource,
    CanvasTextMetrics: () => CanvasTextMetrics,
    CanvasTextPipe: () => CanvasTextPipe,
    CanvasTextSystem: () => CanvasTextSystem,
    Circle: () => Circle,
    Color: () => Color,
    ColorBlend: () => ColorBlend,
    ColorBurnBlend: () => ColorBurnBlend,
    ColorDodgeBlend: () => ColorDodgeBlend,
    ColorMask: () => ColorMask,
    ColorMaskPipe: () => ColorMaskPipe,
    ColorMatrixFilter: () => ColorMatrixFilter,
    CompressedSource: () => CompressedSource,
    Container: () => Container,
    Culler: () => Culler,
    CullerPlugin: () => CullerPlugin,
    CustomRenderPipe: () => CustomRenderPipe,
    D3D10_RESOURCE_DIMENSION: () => D3D10_RESOURCE_DIMENSION,
    D3DFMT: () => D3DFMT,
    DATA_URI: () => DATA_URI,
    DDS: () => DDS,
    DEG_TO_RAD: () => DEG_TO_RAD,
    DEPRECATED_SCALE_MODES: () => DEPRECATED_SCALE_MODES,
    DEPRECATED_WRAP_MODES: () => DEPRECATED_WRAP_MODES,
    DOMAdapter: () => DOMAdapter,
    DRAW_MODES: () => DRAW_MODES,
    DXGI_FORMAT: () => DXGI_FORMAT,
    DXGI_TO_TEXTURE_FORMAT: () => DXGI_TO_TEXTURE_FORMAT,
    DarkenBlend: () => DarkenBlend,
    DefaultBatcher: () => DefaultBatcher,
    DefaultShader: () => DefaultShader,
    DifferenceBlend: () => DifferenceBlend,
    DisplacementFilter: () => DisplacementFilter,
    DivideBlend: () => DivideBlend,
    DynamicBitmapFont: () => DynamicBitmapFont,
    Ellipse: () => Ellipse,
    EventBoundary: () => EventBoundary,
    EventEmitter: () => eventemitter3_default,
    EventSystem: () => EventSystem,
    EventsTicker: () => EventsTicker,
    ExclusionBlend: () => ExclusionBlend,
    ExtensionType: () => ExtensionType,
    ExtractSystem: () => ExtractSystem,
    FOURCC_TO_TEXTURE_FORMAT: () => FOURCC_TO_TEXTURE_FORMAT,
    FederatedContainer: () => FederatedContainer,
    FederatedEvent: () => FederatedEvent,
    FederatedMouseEvent: () => FederatedMouseEvent,
    FederatedPointerEvent: () => FederatedPointerEvent,
    FederatedWheelEvent: () => FederatedWheelEvent,
    FillGradient: () => FillGradient,
    FillPattern: () => FillPattern,
    Filter: () => Filter,
    FilterEffect: () => FilterEffect,
    FilterPipe: () => FilterPipe,
    FilterSystem: () => FilterSystem,
    FontStylePromiseCache: () => FontStylePromiseCache,
    GAUSSIAN_VALUES: () => GAUSSIAN_VALUES,
    GL_FORMATS: () => GL_FORMATS,
    GL_INTERNAL_FORMAT: () => GL_INTERNAL_FORMAT,
    GL_TARGETS: () => GL_TARGETS,
    GL_TYPES: () => GL_TYPES,
    GL_WRAP_MODES: () => GL_WRAP_MODES,
    GenerateTextureSystem: () => GenerateTextureSystem,
    Geometry: () => Geometry,
    GlBackBufferSystem: () => GlBackBufferSystem,
    GlBatchAdaptor: () => GlBatchAdaptor,
    GlBuffer: () => GlBuffer,
    GlBufferSystem: () => GlBufferSystem,
    GlColorMaskSystem: () => GlColorMaskSystem,
    GlContextSystem: () => GlContextSystem,
    GlEncoderSystem: () => GlEncoderSystem,
    GlGeometrySystem: () => GlGeometrySystem,
    GlGraphicsAdaptor: () => GlGraphicsAdaptor,
    GlMeshAdaptor: () => GlMeshAdaptor,
    GlParticleContainerAdaptor: () => GlParticleContainerAdaptor,
    GlParticleContainerPipe: () => GlParticleContainerPipe,
    GlProgram: () => GlProgram,
    GlProgramData: () => GlProgramData,
    GlRenderTarget: () => GlRenderTarget,
    GlRenderTargetAdaptor: () => GlRenderTargetAdaptor,
    GlRenderTargetSystem: () => GlRenderTargetSystem,
    GlShaderSystem: () => GlShaderSystem,
    GlStateSystem: () => GlStateSystem,
    GlStencilSystem: () => GlStencilSystem,
    GlTexture: () => GlTexture,
    GlTextureSystem: () => GlTextureSystem,
    GlUboSystem: () => GlUboSystem,
    GlUniformGroupSystem: () => GlUniformGroupSystem,
    GlobalUniformSystem: () => GlobalUniformSystem,
    GpuBatchAdaptor: () => GpuBatchAdaptor,
    GpuBlendModesToPixi: () => GpuBlendModesToPixi,
    GpuBufferSystem: () => GpuBufferSystem,
    GpuColorMaskSystem: () => GpuColorMaskSystem,
    GpuDeviceSystem: () => GpuDeviceSystem,
    GpuEncoderSystem: () => GpuEncoderSystem,
    GpuGraphicsAdaptor: () => GpuGraphicsAdaptor,
    GpuGraphicsContext: () => GpuGraphicsContext,
    GpuMeshAdapter: () => GpuMeshAdapter,
    GpuMipmapGenerator: () => GpuMipmapGenerator,
    GpuParticleContainerAdaptor: () => GpuParticleContainerAdaptor,
    GpuParticleContainerPipe: () => GpuParticleContainerPipe,
    GpuProgram: () => GpuProgram,
    GpuReadBuffer: () => GpuReadBuffer,
    GpuRenderTarget: () => GpuRenderTarget,
    GpuRenderTargetAdaptor: () => GpuRenderTargetAdaptor,
    GpuRenderTargetSystem: () => GpuRenderTargetSystem,
    GpuShaderSystem: () => GpuShaderSystem,
    GpuStateSystem: () => GpuStateSystem,
    GpuStencilModesToPixi: () => GpuStencilModesToPixi,
    GpuStencilSystem: () => GpuStencilSystem,
    GpuTextureSystem: () => GpuTextureSystem,
    GpuUboSystem: () => GpuUboSystem,
    GpuUniformBatchPipe: () => GpuUniformBatchPipe,
    Graphics: () => Graphics,
    GraphicsContext: () => GraphicsContext,
    GraphicsContextRenderData: () => GraphicsContextRenderData,
    GraphicsContextSystem: () => GraphicsContextSystem,
    GraphicsPath: () => GraphicsPath,
    GraphicsPipe: () => GraphicsPipe,
    HTMLText: () => HTMLText,
    HTMLTextPipe: () => HTMLTextPipe,
    HTMLTextRenderData: () => HTMLTextRenderData,
    HTMLTextStyle: () => HTMLTextStyle,
    HTMLTextSystem: () => HTMLTextSystem,
    HardLightBlend: () => HardLightBlend,
    HardMixBlend: () => HardMixBlend,
    HelloSystem: () => HelloSystem,
    IGLUniformData: () => IGLUniformData,
    ImageSource: () => ImageSource,
    InstructionSet: () => InstructionSet,
    KTX: () => KTX,
    LightenBlend: () => LightenBlend,
    LinearBurnBlend: () => LinearBurnBlend,
    LinearDodgeBlend: () => LinearDodgeBlend,
    LinearLightBlend: () => LinearLightBlend,
    Loader: () => Loader,
    LoaderParserPriority: () => LoaderParserPriority,
    LuminosityBlend: () => LuminosityBlend,
    MSAA_QUALITY: () => MSAA_QUALITY,
    MaskEffectManager: () => MaskEffectManager,
    MaskEffectManagerClass: () => MaskEffectManagerClass,
    MaskFilter: () => MaskFilter,
    Matrix: () => Matrix,
    Mesh: () => Mesh,
    MeshGeometry: () => MeshGeometry,
    MeshPipe: () => MeshPipe,
    MeshPlane: () => MeshPlane,
    MeshRope: () => MeshRope,
    MeshSimple: () => MeshSimple,
    NOOP: () => NOOP,
    NegationBlend: () => NegationBlend,
    NineSliceGeometry: () => NineSliceGeometry,
    NineSlicePlane: () => NineSlicePlane,
    NineSliceSprite: () => NineSliceSprite,
    NineSliceSpritePipe: () => NineSliceSpritePipe,
    NoiseFilter: () => NoiseFilter,
    ObservablePoint: () => ObservablePoint,
    OverlayBlend: () => OverlayBlend,
    PI_2: () => PI_2,
    Particle: () => Particle,
    ParticleBuffer: () => ParticleBuffer,
    ParticleContainer: () => ParticleContainer,
    ParticleContainerPipe: () => ParticleContainerPipe,
    ParticleShader: () => ParticleShader,
    PerspectiveMesh: () => PerspectiveMesh,
    PerspectivePlaneGeometry: () => PerspectivePlaneGeometry,
    PinLightBlend: () => PinLightBlend,
    PipelineSystem: () => PipelineSystem,
    PlaneGeometry: () => PlaneGeometry,
    Point: () => Point,
    Polygon: () => Polygon,
    Pool: () => Pool,
    PoolGroupClass: () => PoolGroupClass,
    PrepareBase: () => PrepareBase,
    PrepareQueue: () => PrepareQueue,
    PrepareSystem: () => PrepareSystem,
    PrepareUpload: () => PrepareUpload,
    QuadGeometry: () => QuadGeometry,
    RAD_TO_DEG: () => RAD_TO_DEG,
    Rectangle: () => Rectangle,
    RenderContainer: () => RenderContainer,
    RenderGroup: () => RenderGroup,
    RenderGroupPipe: () => RenderGroupPipe,
    RenderGroupSystem: () => RenderGroupSystem,
    RenderTarget: () => RenderTarget,
    RenderTargetSystem: () => RenderTargetSystem,
    RenderTexture: () => RenderTexture,
    RenderableGCSystem: () => RenderableGCSystem,
    RendererInitHook: () => RendererInitHook,
    RendererType: () => RendererType,
    ResizePlugin: () => ResizePlugin,
    Resolver: () => Resolver,
    RopeGeometry: () => RopeGeometry,
    RoundedRectangle: () => RoundedRectangle,
    SCALE_MODES: () => SCALE_MODES,
    STENCIL_MODES: () => STENCIL_MODES,
    SVGParser: () => SVGParser,
    SVGToGraphicsPath: () => SVGToGraphicsPath,
    SaturationBlend: () => SaturationBlend,
    SchedulerSystem: () => SchedulerSystem,
    ScissorMask: () => ScissorMask,
    SdfShader: () => SdfShader,
    Shader: () => Shader,
    ShaderStage: () => ShaderStage,
    ShapePath: () => ShapePath,
    SharedRenderPipes: () => SharedRenderPipes,
    SharedSystems: () => SharedSystems,
    SoftLightBlend: () => SoftLightBlend,
    Sprite: () => Sprite,
    SpritePipe: () => SpritePipe,
    Spritesheet: () => Spritesheet,
    State: () => State,
    StencilMask: () => StencilMask,
    StencilMaskPipe: () => StencilMaskPipe,
    SubtractBlend: () => SubtractBlend,
    SystemRunner: () => SystemRunner,
    TEXTURE_FORMAT_BLOCK_SIZE: () => TEXTURE_FORMAT_BLOCK_SIZE,
    Text: () => Text,
    TextStyle: () => TextStyle,
    Texture: () => Texture,
    TextureGCSystem: () => TextureGCSystem,
    TextureMatrix: () => TextureMatrix,
    TexturePool: () => TexturePool,
    TexturePoolClass: () => TexturePoolClass,
    TextureSource: () => TextureSource,
    TextureStyle: () => TextureStyle,
    TextureUvs: () => TextureUvs,
    Ticker: () => Ticker,
    TickerListener: () => TickerListener,
    TickerPlugin: () => TickerPlugin,
    TilingSprite: () => TilingSprite,
    TilingSpritePipe: () => TilingSpritePipe,
    TilingSpriteShader: () => TilingSpriteShader,
    Transform: () => Transform,
    Triangle: () => Triangle,
    UNIFORM_TO_ARRAY_SETTERS: () => UNIFORM_TO_ARRAY_SETTERS,
    UNIFORM_TO_SINGLE_SETTERS: () => UNIFORM_TO_SINGLE_SETTERS,
    UNIFORM_TYPES_MAP: () => UNIFORM_TYPES_MAP,
    UNIFORM_TYPES_VALUES: () => UNIFORM_TYPES_VALUES,
    UPDATE_BLEND: () => UPDATE_BLEND,
    UPDATE_COLOR: () => UPDATE_COLOR,
    UPDATE_PRIORITY: () => UPDATE_PRIORITY,
    UPDATE_TRANSFORM: () => UPDATE_TRANSFORM,
    UPDATE_VISIBLE: () => UPDATE_VISIBLE,
    UboBatch: () => UboBatch,
    UboSystem: () => UboSystem,
    UniformGroup: () => UniformGroup,
    VERSION: () => VERSION,
    VideoSource: () => VideoSource,
    ViewContainer: () => ViewContainer,
    ViewSystem: () => ViewSystem,
    ViewableBuffer: () => ViewableBuffer,
    VividLightBlend: () => VividLightBlend,
    WGSL_ALIGN_SIZE_DATA: () => WGSL_ALIGN_SIZE_DATA,
    WGSL_TO_STD40_SIZE: () => WGSL_TO_STD40_SIZE,
    WRAP_MODES: () => WRAP_MODES,
    WebGLRenderer: () => WebGLRenderer,
    WebGPURenderer: () => WebGPURenderer,
    WebWorkerAdapter: () => WebWorkerAdapter,
    WorkerManager: () => WorkerManager,
    _getGlobalBounds: () => _getGlobalBounds,
    _getGlobalBoundsRecursive: () => _getGlobalBoundsRecursive,
    accessibilityTarget: () => accessibilityTarget,
    addBits: () => addBits,
    addMaskBounds: () => addMaskBounds,
    addMaskLocalBounds: () => addMaskLocalBounds,
    addProgramDefines: () => addProgramDefines,
    alphaFrag: () => fragment3,
    alphaWgsl: () => source2,
    applyMatrix: () => applyMatrix,
    applyProjectiveTransformationToPlane: () => applyProjectiveTransformationToPlane,
    applyStyleParams: () => applyStyleParams,
    assignWithIgnore: () => assignWithIgnore,
    autoDetectEnvironment: () => autoDetectEnvironment,
    autoDetectRenderer: () => autoDetectRenderer,
    autoDetectSource: () => autoDetectSource,
    basisTranscoderUrls: () => basisTranscoderUrls,
    bitmapFontCachePlugin: () => bitmapFontCachePlugin,
    bitmapFontTextParser: () => bitmapFontTextParser,
    bitmapFontXMLParser: () => bitmapFontXMLParser,
    bitmapFontXMLStringParser: () => bitmapFontXMLStringParser,
    blendTemplateFrag: () => blendTemplateFrag,
    blendTemplateVert: () => blendTemplateVert,
    blendTemplateWgsl: () => blendTemplate,
    blockDataMap: () => blockDataMap,
    blurTemplateWgsl: () => source3,
    boundsPool: () => boundsPool,
    browserExt: () => browserExt,
    buildAdaptiveBezier: () => buildAdaptiveBezier,
    buildAdaptiveQuadratic: () => buildAdaptiveQuadratic,
    buildArc: () => buildArc,
    buildArcTo: () => buildArcTo,
    buildArcToSvg: () => buildArcToSvg,
    buildCircle: () => buildCircle,
    buildContextBatches: () => buildContextBatches,
    buildEllipse: () => buildEllipse,
    buildGeometryFromPath: () => buildGeometryFromPath,
    buildInstructions: () => buildInstructions,
    buildLine: () => buildLine,
    buildPolygon: () => buildPolygon,
    buildRectangle: () => buildRectangle,
    buildRoundedRectangle: () => buildRoundedRectangle,
    buildSimpleUvs: () => buildSimpleUvs,
    buildTriangle: () => buildTriangle,
    buildUvs: () => buildUvs,
    cacheTextureArray: () => cacheTextureArray,
    calculateProjection: () => calculateProjection,
    checkChildrenDidChange: () => checkChildrenDidChange,
    checkDataUrl: () => checkDataUrl,
    checkExtension: () => checkExtension,
    checkMaxIfStatementsInShader: () => checkMaxIfStatementsInShader,
    childrenHelperMixin: () => childrenHelperMixin,
    cleanArray: () => cleanArray,
    cleanHash: () => cleanHash,
    clearList: () => clearList,
    closePointEps: () => closePointEps,
    collectAllRenderables: () => collectAllRenderables,
    collectRenderGroups: () => collectRenderGroups,
    color32BitToUniform: () => color32BitToUniform,
    colorBit: () => colorBit,
    colorBitGl: () => colorBitGl,
    colorMatrixFilterFrag: () => fragment4,
    colorMatrixFilterWgsl: () => source4,
    colorToUniform: () => colorToUniform,
    compareModeToGlCompare: () => compareModeToGlCompare,
    compileHighShader: () => compileHighShader,
    compileHighShaderGl: () => compileHighShaderGl,
    compileHighShaderGlProgram: () => compileHighShaderGlProgram,
    compileHighShaderGpuProgram: () => compileHighShaderGpuProgram,
    compileHooks: () => compileHooks,
    compileInputs: () => compileInputs,
    compileOutputs: () => compileOutputs,
    compileShader: () => compileShader,
    compute2DProjection: () => compute2DProjection,
    convertFormatIfRequired: () => convertFormatIfRequired,
    convertToList: () => convertToList,
    copySearchParams: () => copySearchParams,
    createIdFromString: () => createIdFromString,
    createIndicesForQuads: () => createIndicesForQuads,
    createLevelBuffers: () => createLevelBuffers,
    createLevelBuffersFromKTX: () => createLevelBuffersFromKTX,
    createStringVariations: () => createStringVariations,
    createTexture: () => createTexture,
    createUboElementsSTD40: () => createUboElementsSTD40,
    createUboElementsWGSL: () => createUboElementsWGSL,
    createUboSyncFunction: () => createUboSyncFunction,
    createUboSyncFunctionSTD40: () => createUboSyncFunctionSTD40,
    createUboSyncFunctionWGSL: () => createUboSyncFunctionWGSL,
    crossOrigin: () => crossOrigin,
    cullingMixin: () => cullingMixin,
    curveEps: () => curveEps,
    defaultFilterVert: () => vertex3,
    defaultValue: () => defaultValue,
    definedProps: () => definedProps,
    deprecation: () => deprecation,
    detectAvif: () => detectAvif,
    detectBasis: () => detectBasis,
    detectCompressed: () => detectCompressed,
    detectDefaults: () => detectDefaults,
    detectMp4: () => detectMp4,
    detectOgv: () => detectOgv,
    detectVideoAlphaMode: () => detectVideoAlphaMode,
    detectWebm: () => detectWebm,
    detectWebp: () => detectWebp,
    determineCrossOrigin: () => determineCrossOrigin,
    displacementFrag: () => fragment5,
    displacementVert: () => vertex4,
    displacementWgsl: () => source5,
    earcut: () => import_earcut2.default,
    effectsMixin: () => effectsMixin,
    ensureAttributes: () => ensureAttributes,
    ensureIsBuffer: () => ensureIsBuffer,
    ensureOptions: () => ensureOptions,
    ensurePrecision: () => ensurePrecision,
    ensureTextStyle: () => ensureTextStyle,
    executeInstructions: () => executeInstructions,
    extensions: () => extensions,
    extractAttributesFromGlProgram: () => extractAttributesFromGlProgram,
    extractAttributesFromGpuProgram: () => extractAttributesFromGpuProgram,
    extractFontFamilies: () => extractFontFamilies,
    extractStructAndGroups: () => extractStructAndGroups,
    fastCopy: () => fastCopy,
    findHooksRx: () => findHooksRx,
    findMixin: () => findMixin,
    fontStringFromTextStyle: () => fontStringFromTextStyle,
    formatShader: () => formatShader,
    fragmentGPUTemplate: () => fragmentGPUTemplate,
    fragmentGlTemplate: () => fragmentGlTemplate,
    generateArraySyncSTD40: () => generateArraySyncSTD40,
    generateArraySyncWGSL: () => generateArraySyncWGSL,
    generateBlurFragSource: () => generateBlurFragSource,
    generateBlurGlProgram: () => generateBlurGlProgram,
    generateBlurProgram: () => generateBlurProgram,
    generateBlurVertSource: () => generateBlurVertSource,
    generateGPULayout: () => generateGPULayout,
    generateGpuLayoutGroups: () => generateGpuLayoutGroups,
    generateLayout: () => generateLayout,
    generateLayoutHash: () => generateLayoutHash,
    generateParticleUpdateFunction: () => generateParticleUpdateFunction,
    generateProgram: () => generateProgram,
    generateShaderSyncCode: () => generateShaderSyncCode,
    generateTextStyleKey: () => generateTextStyleKey,
    generateTextureBatchBit: () => generateTextureBatchBit,
    generateTextureBatchBitGl: () => generateTextureBatchBitGl,
    generateUID: () => generateUID,
    generateUniformsSync: () => generateUniformsSync,
    getAdjustedBlendModeBlend: () => getAdjustedBlendModeBlend,
    getAttributeInfoFromFormat: () => getAttributeInfoFromFormat,
    getBatchSamplersUniformGroup: () => getBatchSamplersUniformGroup,
    getBitmapTextLayout: () => getBitmapTextLayout,
    getCanvasBoundingBox: () => getCanvasBoundingBox,
    getCanvasFillStyle: () => getCanvasFillStyle,
    getCanvasTexture: () => getCanvasTexture,
    getDefaultUniformValue: () => getDefaultUniformValue,
    getFastGlobalBounds: () => getFastGlobalBounds,
    getFontCss: () => getFontCss,
    getFontFamilyName: () => getFontFamilyName,
    getGeometryBounds: () => getGeometryBounds,
    getGlTypeFromFormat: () => getGlTypeFromFormat,
    getGlobalBounds: () => getGlobalBounds,
    getGlobalRenderableBounds: () => getGlobalRenderableBounds,
    getLocalBounds: () => getLocalBounds,
    getMatrixRelativeToParent: () => getMatrixRelativeToParent,
    getMaxFragmentPrecision: () => getMaxFragmentPrecision,
    getMaxTexturesPerBatch: () => getMaxTexturesPerBatch,
    getOrientationOfPoints: () => getOrientationOfPoints,
    getParent: () => getParent,
    getPo2TextureFromSource: () => getPo2TextureFromSource,
    getResolutionOfUrl: () => getResolutionOfUrl,
    getSVGUrl: () => getSVGUrl,
    getSupportedCompressedTextureFormats: () => getSupportedCompressedTextureFormats,
    getSupportedGPUCompressedTextureFormats: () => getSupportedGPUCompressedTextureFormats,
    getSupportedGlCompressedTextureFormats: () => getSupportedGlCompressedTextureFormats,
    getSupportedTextureFormats: () => getSupportedTextureFormats,
    getTemporaryCanvasFromImage: () => getTemporaryCanvasFromImage,
    getTestContext: () => getTestContext,
    getTextureBatchBindGroup: () => getTextureBatchBindGroup,
    getTextureDefaultMatrix: () => getTextureDefaultMatrix,
    getTextureFormatFromKTXTexture: () => getTextureFormatFromKTXTexture,
    getUboData: () => getUboData,
    getUniformData: () => getUniformData,
    getUrlExtension: () => getUrlExtension,
    glFormatToGPUFormat: () => glFormatToGPUFormat,
    glUploadBufferImageResource: () => glUploadBufferImageResource,
    glUploadCompressedTextureResource: () => glUploadCompressedTextureResource,
    glUploadImageResource: () => glUploadImageResource,
    glUploadVideoResource: () => glUploadVideoResource,
    globalUniformsBit: () => globalUniformsBit,
    globalUniformsBitGl: () => globalUniformsBitGl,
    globalUniformsUBOBitGl: () => globalUniformsUBOBitGl,
    gpuFormatToBasisTranscoderFormat: () => gpuFormatToBasisTranscoderFormat,
    gpuFormatToKTXBasisTranscoderFormat: () => gpuFormatToKTXBasisTranscoderFormat,
    gpuUploadBufferImageResource: () => gpuUploadBufferImageResource,
    gpuUploadCompressedTextureResource: () => gpuUploadCompressedTextureResource,
    gpuUploadImageResource: () => gpuUploadImageResource,
    gpuUploadVideoResource: () => gpuUploadVideoResource,
    groupD8: () => groupD8,
    hasCachedCanvasTexture: () => hasCachedCanvasTexture,
    hslWgsl: () => hsl,
    hslgl: () => hslgl,
    hslgpu: () => hslgpu,
    injectBits: () => injectBits,
    insertVersion: () => insertVersion,
    isMobile: () => isMobile2,
    isPow2: () => isPow2,
    isRenderingToScreen: () => isRenderingToScreen,
    isSafari: () => isSafari,
    isSingleItem: () => isSingleItem,
    isWebGLSupported: () => isWebGLSupported,
    isWebGPUSupported: () => isWebGPUSupported,
    ktxTranscoderUrls: () => ktxTranscoderUrls,
    loadBasis: () => loadBasis,
    loadBasisOnWorker: () => loadBasisOnWorker,
    loadBitmapFont: () => loadBitmapFont,
    loadDDS: () => loadDDS,
    loadEnvironmentExtensions: () => loadEnvironmentExtensions,
    loadFontAsBase64: () => loadFontAsBase64,
    loadFontCSS: () => loadFontCSS,
    loadImageBitmap: () => loadImageBitmap,
    loadJson: () => loadJson,
    loadKTX: () => loadKTX,
    loadKTX2: () => loadKTX2,
    loadKTX2onWorker: () => loadKTX2onWorker,
    loadSVGImage: () => loadSVGImage,
    loadSvg: () => loadSvg,
    loadTextures: () => loadTextures,
    loadTxt: () => loadTxt,
    loadVideoTextures: () => loadVideoTextures,
    loadWebFont: () => loadWebFont,
    localUniformBit: () => localUniformBit,
    localUniformBitGl: () => localUniformBitGl,
    localUniformBitGroup2: () => localUniformBitGroup2,
    localUniformMSDFBit: () => localUniformMSDFBit,
    localUniformMSDFBitGl: () => localUniformMSDFBitGl,
    log2: () => log2,
    logDebugTexture: () => logDebugTexture,
    logProgramError: () => logProgramError,
    logRenderGroupScene: () => logRenderGroupScene,
    logScene: () => logScene,
    mSDFBit: () => mSDFBit,
    mSDFBitGl: () => mSDFBitGl,
    mapFormatToGlFormat: () => mapFormatToGlFormat,
    mapFormatToGlInternalFormat: () => mapFormatToGlInternalFormat,
    mapFormatToGlType: () => mapFormatToGlType,
    mapGlToVertexFormat: () => mapGlToVertexFormat,
    mapSize: () => mapSize,
    mapType: () => mapType,
    mapWebGLBlendModesToPixi: () => mapWebGLBlendModesToPixi,
    maskFrag: () => fragment2,
    maskVert: () => vertex2,
    maskWgsl: () => source,
    matrixPool: () => matrixPool,
    measureHtmlText: () => measureHtmlText,
    measureMixin: () => measureMixin,
    migrateFragmentFromV7toV8: () => migrateFragmentFromV7toV8,
    mipmapScaleModeToGlFilter: () => mipmapScaleModeToGlFilter,
    mixColors: () => mixColors,
    mixHexColors: () => mixHexColors,
    mixStandardAnd32BitColors: () => mixStandardAnd32BitColors,
    multiplyHexColors: () => multiplyHexColors,
    nextPow2: () => nextPow2,
    noiseFrag: () => fragment6,
    noiseWgsl: () => source6,
    nonCompressedFormats: () => nonCompressedFormats,
    normalizeExtensionPriority: () => normalizeExtensionPriority,
    nssvg: () => nssvg,
    nsxhtml: () => nsxhtml,
    onRenderMixin: () => onRenderMixin,
    parseDDS: () => parseDDS,
    parseFunctionBody: () => parseFunctionBody,
    parseKTX: () => parseKTX,
    particleData: () => particleData,
    particlesFrag: () => fragment,
    particlesVert: () => vertex,
    particlesWgsl: () => wgsl,
    path: () => path,
    pointInTriangle: () => pointInTriangle,
    preloadVideo: () => preloadVideo,
    removeItems: () => removeItems,
    removeStructAndGroupDuplicates: () => removeStructAndGroupDuplicates,
    resetUids: () => resetUids,
    resolveCharacters: () => resolveCharacters,
    resolveCompressedTextureUrl: () => resolveCompressedTextureUrl,
    resolveJsonUrl: () => resolveJsonUrl,
    resolveTextureUrl: () => resolveTextureUrl,
    resourceToTexture: () => resourceToTexture,
    roundPixelsBit: () => roundPixelsBit,
    roundPixelsBitGl: () => roundPixelsBitGl,
    roundedShapeArc: () => roundedShapeArc,
    roundedShapeQuadraticCurve: () => roundedShapeQuadraticCurve,
    sayHello: () => sayHello,
    scaleModeToGlFilter: () => scaleModeToGlFilter,
    setBasisTranscoderPath: () => setBasisTranscoderPath,
    setKTXTranscoderPath: () => setKTXTranscoderPath,
    setPositions: () => setPositions,
    setProgramName: () => setProgramName,
    setUvs: () => setUvs,
    shapeBuilders: () => shapeBuilders,
    sortMixin: () => sortMixin,
    spritesheetAsset: () => spritesheetAsset,
    squaredDistanceToLineSegment: () => squaredDistanceToLineSegment,
    stripVersion: () => stripVersion,
    testImageFormat: () => testImageFormat,
    testVideoFormat: () => testVideoFormat,
    textStyleToCSS: () => textStyleToCSS,
    textureBit: () => textureBit,
    textureBitGl: () => textureBitGl,
    textureFrom: () => textureFrom,
    tilingBit: () => tilingBit,
    tilingBitGl: () => tilingBitGl,
    toFillStyle: () => toFillStyle,
    toLocalGlobalMixin: () => toLocalGlobalMixin,
    toStrokeStyle: () => toStrokeStyle,
    transformVertices: () => transformVertices,
    triangulateWithHoles: () => triangulateWithHoles,
    uboSyncFunctionsSTD40: () => uboSyncFunctionsSTD40,
    uboSyncFunctionsWGSL: () => uboSyncFunctionsWGSL,
    uid: () => uid,
    uniformParsers: () => uniformParsers,
    unpremultiplyAlpha: () => unpremultiplyAlpha2,
    unsafeEvalSupported: () => unsafeEvalSupported,
    updateLocalTransform: () => updateLocalTransform,
    updateQuadBounds: () => updateQuadBounds,
    updateRenderGroupTransform: () => updateRenderGroupTransform,
    updateRenderGroupTransforms: () => updateRenderGroupTransforms,
    updateTransformAndChildren: () => updateTransformAndChildren,
    updateTransformBackwards: () => updateTransformBackwards,
    updateWorldTransform: () => updateWorldTransform,
    v8_0_0: () => v8_0_0,
    v8_3_4: () => v8_3_4,
    validFormats: () => validFormats,
    validateRenderables: () => validateRenderables,
    vertexGPUTemplate: () => vertexGPUTemplate,
    vertexGlTemplate: () => vertexGlTemplate,
    viewportFromFrame: () => viewportFromFrame,
    vkFormatToGPUFormat: () => vkFormatToGPUFormat,
    warn: () => warn,
    webworkerExt: () => webworkerExt,
    wrapModeToGlAddress: () => wrapModeToGlAddress
  });
  var import_earcut2;
  var init_lib = __esm({
    "node_modules/.pnpm/pixi.js@8.5.2/node_modules/pixi.js/lib/index.mjs"() {
      init_browserExt();
      init_webworkerExt();
      init_Extensions();
      init_Extensions();
      init_init5();
      init_init4();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      init_ColorBlend();
      init_ColorBurnBlend();
      init_ColorDodgeBlend();
      init_DarkenBlend();
      init_DifferenceBlend();
      init_DivideBlend();
      init_ExclusionBlend();
      init_HardLightBlend();
      init_HardMixBlend();
      init_LightenBlend();
      init_LinearBurnBlend();
      init_LinearDodgeBlend();
      init_LinearLightBlend();
      init_LuminosityBlend();
      init_NegationBlend();
      init_OverlayBlend();
      init_PinLightBlend();
      init_SaturationBlend();
      init_SoftLightBlend();
      init_SubtractBlend();
      init_VividLightBlend();
      init_Application();
      init_ResizePlugin();
      init_TickerPlugin();
      init_Assets();
      init_BackgroundLoader();
      init_Cache();
      init_cacheTextureArray();
      init_detectAvif();
      init_detectDefaults();
      init_detectMp4();
      init_detectOgv();
      init_detectWebm();
      init_detectWebp();
      init_testImageFormat();
      init_testVideoFormat();
      init_Loader();
      init_LoaderParser();
      init_loadJson();
      init_loadTxt();
      init_loadWebFont();
      init_loadSVG();
      init_loadTextures();
      init_loadVideoTextures();
      init_createTexture();
      init_WorkerManager();
      init_resolveJsonUrl();
      init_resolveTextureUrl();
      init_Resolver();
      init_checkDataUrl();
      init_checkExtension();
      init_convertToList();
      init_copySearchParams();
      init_createStringVariations();
      init_isSingleItem();
      init_Color();
      init_detectBasis();
      init_loadBasis();
      init_createLevelBuffers();
      init_gpuFormatToBasisTranscoderFormat();
      init_setBasisTranscoderPath();
      init_loadBasisOnWorker();
      init_const11();
      init_loadDDS();
      init_parseDDS();
      init_loadKTX();
      init_parseKTX();
      init_const12();
      init_loadKTX2();
      init_convertFormatIfRequired();
      init_createLevelBuffersFromKTX();
      init_getTextureFormatFromKTXTexture();
      init_glFormatToGPUFormat();
      init_gpuFormatToKTXBasisTranscoderFormat();
      init_setKTXTranscoderPath();
      init_vkFormatToGPUFormat();
      init_loadKTX2onWorker();
      init_detectCompressed();
      init_resolveCompressedTextureUrl();
      init_Culler();
      init_CullerPlugin();
      init_cullingMixin();
      init_adapter();
      init_autoDetectEnvironment();
      init_BrowserAdapter();
      init_WebWorkerAdapter();
      init_EventBoundary();
      init_EventSystem();
      init_EventTicker();
      init_FederatedEvent();
      init_FederatedEventTarget();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      init_blend_template_frag();
      init_blend_template_vert();
      init_blend_template_wgsl();
      init_hsl_wgsl();
      init_alpha_frag();
      init_alpha_wgsl();
      init_blur_template_wgsl();
      init_colorMatrixFilter_frag();
      init_colorMatrixFilter_wgsl();
      init_defaultFilter_vert();
      init_displacement_frag();
      init_displacement_vert();
      init_displacement_wgsl();
      init_noise_frag();
      init_noise_wgsl();
      init_mask_frag();
      init_mask_vert();
      init_mask_wgsl();
      init_BlendModeFilter();
      init_GLhls();
      init_GPUhls();
      init_AlphaFilter();
      init_BlurFilter();
      init_BlurFilterPass();
      init_const13();
      init_generateBlurFragSource();
      init_generateBlurGlProgram();
      init_generateBlurVertSource();
      init_generateBlurProgram();
      init_ColorMatrixFilter();
      init_DisplacementFilter();
      init_NoiseFilter();
      init_Filter();
      init_FilterEffect();
      init_FilterPipe();
      init_FilterSystem();
      init_MaskFilter();
      init_groupD8();
      init_Matrix();
      init_const();
      init_pow2();
      init_squaredDistanceToLineSegment();
      init_ObservablePoint();
      init_Point();
      init_pointInTriangle();
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_Triangle();
      init_PrepareBase();
      init_PrepareQueue();
      init_PrepareSystem();
      init_PrepareUpload();
      init_GlBatchAdaptor();
      init_checkMaxIfStatementsInShader();
      init_maxRecommendedTextures();
      init_generateGPULayout();
      init_generateLayout();
      init_getTextureBatchBindGroup();
      init_GpuBatchAdaptor();
      init_Batcher();
      init_BatcherPipe();
      init_BatchGeometry();
      init_BatchTextureArray();
      init_DefaultBatcher();
      init_DefaultShader();
      init_compileHighShaderToProgram();
      init_compileHighShader();
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_formatShader();
      init_injectBits();
      init_defaultProgramTemplate();
      init_colorBit();
      init_generateTextureBatchBit();
      init_globalUniformsBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_AlphaMask();
      init_AlphaMaskPipe();
      init_ColorMask();
      init_ColorMaskPipe();
      init_MaskEffectManager();
      init_ScissorMask();
      init_StencilMask();
      init_StencilMaskPipe();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      init_autoDetectRenderer();
      init_const9();
      init_GlBuffer();
      init_GlBufferSystem();
      init_const7();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_getGlTypeFromFormat();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlRenderTarget();
      init_GlStencilSystem();
      init_GlUboSystem();
      init_GlRenderTargetAdaptor();
      init_GlRenderTargetSystem();
      init_GenerateShaderSyncCode();
      init_getBatchSamplersUniformGroup();
      init_GlProgram();
      init_GlProgramData();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_migrateFragmentFromV7toV8();
      init_compileShader();
      init_defaultValue();
      init_ensureAttributes();
      init_extractAttributesFromGlProgram();
      init_generateProgram();
      init_getMaxFragmentPrecision();
      init_getTestContext();
      init_getUboData();
      init_getUniformData();
      init_logProgramError();
      init_mapSize();
      init_mapType();
      init_addProgramDefines();
      init_ensurePrecision();
      init_insertVersion();
      init_setProgramName();
      init_stripVersion();
      init_createUboElementsSTD40();
      init_createUboSyncSTD40();
      init_generateArraySyncSTD40();
      init_generateUniformsSync();
      init_generateUniformsSyncTypes();
      init_GlStateSystem();
      init_mapWebGLBlendModesToPixi();
      init_const10();
      init_GlTexture();
      init_GlTextureSystem();
      init_glUploadBufferImageResource();
      init_glUploadCompressedTextureResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_getSupportedGlCompressedTextureFormats();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      init_pixiToGlMaps();
      init_unpremultiplyAlpha();
      init_WebGLRenderer();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuReadBuffer();
      init_UboBatch();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuStencilSystem();
      init_GpuUboSystem();
      init_GpuUniformBatchPipe();
      init_PipelineSystem();
      init_calculateProjection();
      init_GpuRenderTarget();
      init_GpuRenderTargetAdaptor();
      init_GpuRenderTargetSystem();
      init_BindGroup();
      init_GpuProgram();
      init_GpuShaderSystem();
      init_createUboElementsWGSL();
      init_createUboSyncFunctionWGSL();
      init_extractAttributesFromGpuProgram();
      init_extractStructAndGroups();
      init_generateArraySyncWGSL();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      init_GpuBlendModesToPixi();
      init_GpuStateSystem();
      init_GpuStencilModesToPixi();
      init_GpuTextureSystem();
      init_gpuUploadBufferImageResource();
      init_gpuUploadCompressedTextureResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_getSupportedGPUCompressedTextureFormats();
      init_GpuMipmapGenerator();
      init_WebGPURenderer();
      init_BackgroundSystem();
      init_BlendModePipe();
      init_Buffer();
      init_BufferResource();
      init_const4();
      init_fastCopy();
      init_ExtractSystem();
      init_GenerateTextureSystem();
      init_const14();
      init_Geometry();
      init_buildUvs();
      init_ensureIsBuffer();
      init_getAttributeInfoFromFormat();
      init_getGeometryBounds();
      init_transformVertices();
      init_InstructionSet();
      init_GlobalUniformSystem();
      init_isRenderingToScreen();
      init_RenderTarget();
      init_RenderTargetSystem();
      init_viewportFromFrame();
      init_SchedulerSystem();
      init_const5();
      init_Shader();
      init_types();
      init_UboSystem();
      init_UniformGroup();
      init_createUboSyncFunction();
      init_getDefaultUniformValue();
      init_uboSyncFunctions();
      init_uniformParsers();
      init_HelloSystem();
      init_const3();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_AbstractRenderer();
      init_SharedSystems();
      init_SystemRunner();
      init_CanvasPool();
      init_const15();
      init_RenderableGCSystem();
      init_RenderTexture();
      init_BufferImageSource();
      init_CanvasSource();
      init_CompressedSource();
      init_ImageSource();
      init_TextureSource();
      init_VideoSource();
      init_Texture();
      init_TextureGCSystem();
      init_TextureMatrix();
      init_TexturePool();
      init_TextureStyle();
      init_TextureUvs();
      init_generateUID();
      init_getCanvasTexture();
      init_getSupportedCompressedTextureFormats();
      init_getSupportedTextureFormats();
      init_textureFrom();
      init_createIdFromString();
      init_parseFunctionBody();
      init_ViewSystem();
      init_types2();
      init_particles_frag();
      init_particles_vert();
      init_particles_wgsl();
      init_Bounds();
      init_getFastGlobalBounds();
      init_getGlobalBounds();
      init_getLocalBounds();
      init_getRenderableBounds();
      init_matrixAndBoundsPool();
      init_childrenHelperMixin();
      init_effectsMixin();
      init_findMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_Container();
      init_CustomRenderPipe();
      init_RenderContainer();
      init_RenderGroup();
      init_RenderGroupPipe();
      init_RenderGroupSystem();
      init_assignWithIgnore();
      init_buildInstructions();
      init_checkChildrenDidChange();
      init_clearList();
      init_collectRenderGroups();
      init_definedProps();
      init_executeInstructions();
      init_mixColors();
      init_mixHexColors();
      init_multiplyHexColors();
      init_updateLocalTransform();
      init_updateRenderGroupTransforms();
      init_updateWorldTransform();
      init_validateRenderables();
      init_GlGraphicsAdaptor();
      init_colorToUniform();
      init_GpuGraphicsAdaptor();
      init_BatchableGraphics();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      init_buildCircle();
      init_buildLine();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_const6();
      init_FillGradient();
      init_FillPattern();
      init_Graphics();
      init_GraphicsContext();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      init_GraphicsPath();
      init_roundShape();
      init_ShapePath();
      init_SVGParser();
      init_SVGToGraphicsPath();
      init_buildContextBatches();
      init_buildGeometryFromPath();
      init_convertFillInputToFillStyle();
      init_getOrientationOfPoints();
      init_triangulateWithHoles();
      init_PerspectiveMesh();
      init_PerspectivePlaneGeometry();
      init_applyProjectiveTransformationToPlane();
      init_compute2DProjections();
      init_MeshPlane();
      init_PlaneGeometry();
      init_MeshRope();
      init_MeshSimple();
      init_RopeGeometry();
      init_GlMeshAdaptor();
      init_GpuMeshAdapter();
      init_BatchableMesh();
      init_getTextureDefaultMatrix();
      init_Mesh();
      init_MeshGeometry();
      init_MeshPipe();
      init_GlParticleContainerAdaptor();
      init_GpuParticleContainerAdaptor();
      init_GlParticleContainerPipe();
      init_GpuParticleContainerPipe();
      init_Particle();
      init_ParticleBuffer();
      init_ParticleContainer();
      init_ParticleContainerPipe();
      init_particleData();
      init_ParticleShader();
      init_createIndicesForQuads();
      init_generateParticleUpdateFunction();
      init_AnimatedSprite();
      init_NineSliceGeometry();
      init_NineSliceSprite();
      init_NineSliceSpritePipe();
      init_tilingBit();
      init_TilingSpriteShader();
      init_TilingSprite();
      init_TilingSpritePipe();
      init_applyMatrix();
      init_QuadGeometry();
      init_setPositions();
      init_setUvs();
      init_BatchableSprite();
      init_Sprite();
      init_SpritePipe();
      init_AbstractBitmapFont();
      init_bitmapFontTextParser();
      init_bitmapFontXMLParser();
      init_bitmapFontXMLStringParser();
      init_loadBitmapFont();
      init_BitmapFont();
      init_BitmapFontManager();
      init_BitmapText();
      init_BitmapTextPipe();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters();
      init_HTMLText();
      init_HTMLTextPipe();
      init_HTMLTextRenderData();
      init_HtmlTextStyle();
      init_HTMLTextSystem();
      init_extractFontFamilies();
      init_getFontCss();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadFontAsBase64();
      init_loadFontCSS();
      init_loadSVGImage();
      init_measureHtmlText();
      init_textStyleToCSS();
      init_AbstractText();
      init_CanvasTextMetrics();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_SdfShader();
      init_localUniformMSDFBit();
      init_mSDFBit();
      init_Text();
      init_TextStyle();
      init_ensureTextStyle();
      init_generateTextStyleKey();
      init_getPo2TextureFromSource();
      init_ViewContainer();
      init_Spritesheet();
      init_spritesheetAsset();
      init_const2();
      init_Ticker();
      init_TickerListener();
      init_detectVideoAlphaMode();
      init_isMobile2();
      init_isSafari();
      init_isWebGLSupported();
      init_isWebGPUSupported();
      init_unsafeEvalSupported();
      init_getCanvasBoundingBox();
      init_const8();
      init_eventemitter3();
      init_clean();
      init_removeItems();
      init_uid();
      init_updateQuadBounds();
      init_ViewableBuffer();
      init_globalHooks();
      init_deprecation();
      init_logDebugTexture();
      init_logScene();
      init_warn();
      init_NOOP();
      init_Transform();
      init_getResolutionOfUrl();
      init_path();
      init_Pool();
      init_PoolGroup();
      init_sayHello();
      import_earcut2 = __toESM(require_earcut(), 1);
      extensions.add(browserExt, webworkerExt);
    }
  });

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config, _defaults, _suppressOverwrites, _reverting, _context, _bigNum, _tinyNum, _2PI, _HALF_PI, _gsID, _sqrt, _cos, _sin, _isString, _isFunction, _isNumber, _isUndefined, _isObject, _isNotFalse, _windowExists, _isFuncOrString, _isTypedArray, _isArray, _strictNumExp, _numExp, _numWithUnitExp, _complexStringNumExp, _relExp, _delimitedValueExp, _unitExp, _globalTimeline, _win, _coreInitted, _doc, _globals, _installScope, _coreReady, _install, _missingPlugin, _warn, _addGlobal, _emptyFunc, _startAtRevertConfig, _revertConfigNoKill, _revertConfig, _reservedProps, _lazyTweens, _lazyLookup, _lastRenderedFrame, _plugins, _effects, _nextGCFrame, _harnessPlugins, _callbackNames, _harness, _getCache, _getProperty, _forEachName, _round, _roundPrecise, _parseRelative, _arrayContainsAny, _lazyRender, _lazySafeRender, _numericIfPossible, _passThrough, _setDefaults, _setKeyframeDefaults, _merge, _mergeDeep, _copyExcluding, _inheritDefaults, _arraysMatch, _addLinkedListItem, _removeLinkedListItem, _removeFromParent, _uncache, _recacheAncestors, _rewindStartAt, _hasNoPausedAncestors, _elapsedCycleDuration, _animationCycle, _parentToChildTotalTime, _setEnd, _alignPlayhead, _postAddChecks, _addToTimeline, _scrollTrigger, _attemptInitTween, _parentPlayheadIsBeforeStart, _isFromOrFromStart, _renderZeroDurationTween, _findNextPauseTween, _setDuration, _onUpdateTotalDuration, _zeroPosition, _parsePosition, _createTweenType, _conditionalReturn, _clamp, getUnit, clamp, _slice, _isArrayLike, _flatten, toArray, selector, shuffle, distribute, _roundModifier, snap, random, pipe, unitize, normalize, _wrapArray, wrap, wrapYoyo, _replaceRandom, mapRange, interpolate, _getLabelInDirection, _callback, _interrupt, _quickTween, _registerPluginQueue, _createPlugin, _255, _colorLookup, _hue, splitColor, _colorOrderData, _formatColors, _colorExp, _hslExp, _colorStringFilter, _tickerActive, _ticker, _wake, _easeMap, _customEaseExp, _quotesExp, _parseObjectInString, _valueInParentheses, _configEaseFromString, _invertEase, _propagateYoyoEase, _parseEase, _insertEase, _easeInOutFromOut, _configElastic, _configBack, GSCache, Animation, Timeline, _addComplexStringPropTween, _addPropTween, _processVars, _checkPlugin, _overwritingTween, _forceAllPropTweens, _initTween, _updatePropTweens, _addAliasesToVars, _parseKeyframe, _parseFuncOrString, _staggerTweenProps, _staggerPropsToSkip, Tween, _setterPlain, _setterFunc, _setterFuncWithParam, _setterAttribute, _getSetter, _renderPlain, _renderBoolean, _renderComplexString, _renderPropTweens, _addPluginModifier, _killPropTweensOf, _setterWithModifier, _sortPropTweensByPriority, PropTween, _media, _listeners, _emptyArray, _lastMediaTime, _contextID, _dispatch, _onMediaChange, Context, MatchMedia, _gsap, _getPluginPropTween, _addModifiers, _buildModifierPlugin, gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ;
  var init_gsap_core = __esm({
    "node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js"() {
      _config = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
          lineHeight: ""
        }
      };
      _defaults = {
        duration: 0.5,
        overwrite: false,
        delay: 0
      };
      _bigNum = 1e8;
      _tinyNum = 1 / _bigNum;
      _2PI = Math.PI * 2;
      _HALF_PI = _2PI / 4;
      _gsID = 0;
      _sqrt = Math.sqrt;
      _cos = Math.cos;
      _sin = Math.sin;
      _isString = function _isString2(value) {
        return typeof value === "string";
      };
      _isFunction = function _isFunction2(value) {
        return typeof value === "function";
      };
      _isNumber = function _isNumber2(value) {
        return typeof value === "number";
      };
      _isUndefined = function _isUndefined2(value) {
        return typeof value === "undefined";
      };
      _isObject = function _isObject2(value) {
        return typeof value === "object";
      };
      _isNotFalse = function _isNotFalse2(value) {
        return value !== false;
      };
      _windowExists = function _windowExists2() {
        return typeof window !== "undefined";
      };
      _isFuncOrString = function _isFuncOrString2(value) {
        return _isFunction(value) || _isString(value);
      };
      _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
      };
      _isArray = Array.isArray;
      _strictNumExp = /(?:-?\.?\d|\.)+/gi;
      _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
      _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
      _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
      _relExp = /[+-]=-?[.\d]+/;
      _delimitedValueExp = /[^,'"\[\]\s]+/gi;
      _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
      _globals = {};
      _installScope = {};
      _install = function _install2(scope) {
        return (_installScope = _merge(scope, _globals)) && gsap;
      };
      _missingPlugin = function _missingPlugin2(property, value) {
        return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
      };
      _warn = function _warn2(message, suppress) {
        return !suppress && console.warn(message);
      };
      _addGlobal = function _addGlobal2(name, obj) {
        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
      };
      _emptyFunc = function _emptyFunc2() {
        return 0;
      };
      _startAtRevertConfig = {
        suppressEvents: true,
        isStart: true,
        kill: false
      };
      _revertConfigNoKill = {
        suppressEvents: true,
        kill: false
      };
      _revertConfig = {
        suppressEvents: true
      };
      _reservedProps = {};
      _lazyTweens = [];
      _lazyLookup = {};
      _plugins = {};
      _effects = {};
      _nextGCFrame = 30;
      _harnessPlugins = [];
      _callbackNames = "";
      _harness = function _harness2(targets) {
        var target = targets[0], harnessPlugin, i3;
        _isObject(target) || _isFunction(target) || (targets = [targets]);
        if (!(harnessPlugin = (target._gsap || {}).harness)) {
          i3 = _harnessPlugins.length;
          while (i3-- && !_harnessPlugins[i3].targetTest(target)) {
          }
          harnessPlugin = _harnessPlugins[i3];
        }
        i3 = targets.length;
        while (i3--) {
          targets[i3] && (targets[i3]._gsap || (targets[i3]._gsap = new GSCache(targets[i3], harnessPlugin))) || targets.splice(i3, 1);
        }
        return targets;
      };
      _getCache = function _getCache2(target) {
        return target._gsap || _harness(toArray(target))[0]._gsap;
      };
      _getProperty = function _getProperty2(target, property, v2) {
        return (v2 = target[property]) && _isFunction(v2) ? target[property]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property) || v2;
      };
      _forEachName = function _forEachName2(names, func) {
        return (names = names.split(",")).forEach(func) || names;
      };
      _round = function _round2(value) {
        return Math.round(value * 1e5) / 1e5 || 0;
      };
      _roundPrecise = function _roundPrecise2(value) {
        return Math.round(value * 1e7) / 1e7 || 0;
      };
      _parseRelative = function _parseRelative2(start, value) {
        var operator = value.charAt(0), end = parseFloat(value.substr(2));
        start = parseFloat(start);
        return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
      };
      _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
        var l2 = toFind.length, i3 = 0;
        for (; toSearch.indexOf(toFind[i3]) < 0 && ++i3 < l2; ) {
        }
        return i3 < l2;
      };
      _lazyRender = function _lazyRender2() {
        var l2 = _lazyTweens.length, a2 = _lazyTweens.slice(0), i3, tween;
        _lazyLookup = {};
        _lazyTweens.length = 0;
        for (i3 = 0; i3 < l2; i3++) {
          tween = a2[i3];
          tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
        }
      };
      _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
        _lazyTweens.length && !_reverting && _lazyRender();
        animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
        _lazyTweens.length && !_reverting && _lazyRender();
      };
      _numericIfPossible = function _numericIfPossible2(value) {
        var n2 = parseFloat(value);
        return (n2 || n2 === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n2 : _isString(value) ? value.trim() : value;
      };
      _passThrough = function _passThrough2(p3) {
        return p3;
      };
      _setDefaults = function _setDefaults2(obj, defaults2) {
        for (var p3 in defaults2) {
          p3 in obj || (obj[p3] = defaults2[p3]);
        }
        return obj;
      };
      _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
        return function(obj, defaults2) {
          for (var p3 in defaults2) {
            p3 in obj || p3 === "duration" && excludeDuration || p3 === "ease" || (obj[p3] = defaults2[p3]);
          }
        };
      };
      _merge = function _merge2(base, toMerge) {
        for (var p3 in toMerge) {
          base[p3] = toMerge[p3];
        }
        return base;
      };
      _mergeDeep = function _mergeDeep2(base, toMerge) {
        for (var p3 in toMerge) {
          p3 !== "__proto__" && p3 !== "constructor" && p3 !== "prototype" && (base[p3] = _isObject(toMerge[p3]) ? _mergeDeep2(base[p3] || (base[p3] = {}), toMerge[p3]) : toMerge[p3]);
        }
        return base;
      };
      _copyExcluding = function _copyExcluding2(obj, excluding) {
        var copy = {}, p3;
        for (p3 in obj) {
          p3 in excluding || (copy[p3] = obj[p3]);
        }
        return copy;
      };
      _inheritDefaults = function _inheritDefaults2(vars) {
        var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
        if (_isNotFalse(vars.inherit)) {
          while (parent) {
            func(vars, parent.vars.defaults);
            parent = parent.parent || parent._dp;
          }
        }
        return vars;
      };
      _arraysMatch = function _arraysMatch2(a1, a2) {
        var i3 = a1.length, match = i3 === a2.length;
        while (match && i3-- && a1[i3] === a2[i3]) {
        }
        return i3 < 0;
      };
      _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
        if (firstProp === void 0) {
          firstProp = "_first";
        }
        if (lastProp === void 0) {
          lastProp = "_last";
        }
        var prev = parent[lastProp], t2;
        if (sortBy) {
          t2 = child[sortBy];
          while (prev && prev[sortBy] > t2) {
            prev = prev._prev;
          }
        }
        if (prev) {
          child._next = prev._next;
          prev._next = child;
        } else {
          child._next = parent[firstProp];
          parent[firstProp] = child;
        }
        if (child._next) {
          child._next._prev = child;
        } else {
          parent[lastProp] = child;
        }
        child._prev = prev;
        child.parent = child._dp = parent;
        return child;
      };
      _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
        if (firstProp === void 0) {
          firstProp = "_first";
        }
        if (lastProp === void 0) {
          lastProp = "_last";
        }
        var prev = child._prev, next = child._next;
        if (prev) {
          prev._next = next;
        } else if (parent[firstProp] === child) {
          parent[firstProp] = next;
        }
        if (next) {
          next._prev = prev;
        } else if (parent[lastProp] === child) {
          parent[lastProp] = prev;
        }
        child._next = child._prev = child.parent = null;
      };
      _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
        child._act = 0;
      };
      _uncache = function _uncache2(animation, child) {
        if (animation && (!child || child._end > animation._dur || child._start < 0)) {
          var a2 = animation;
          while (a2) {
            a2._dirty = 1;
            a2 = a2.parent;
          }
        }
        return animation;
      };
      _recacheAncestors = function _recacheAncestors2(animation) {
        var parent = animation.parent;
        while (parent && parent.parent) {
          parent._dirty = 1;
          parent.totalDuration();
          parent = parent.parent;
        }
        return animation;
      };
      _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
        return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
      };
      _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
        return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
      };
      _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
      };
      _animationCycle = function _animationCycle2(tTime, cycleDuration) {
        var whole = Math.floor(tTime /= cycleDuration);
        return tTime && whole === tTime ? whole - 1 : whole;
      };
      _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
      };
      _setEnd = function _setEnd2(animation) {
        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
      };
      _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
        var parent = animation._dp;
        if (parent && parent.smoothChildTiming && animation._ts) {
          animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
          _setEnd(animation);
          parent._dirty || _uncache(parent, animation);
        }
        return animation;
      };
      _postAddChecks = function _postAddChecks2(timeline2, child) {
        var t2;
        if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
          t2 = _parentToChildTotalTime(timeline2.rawTime(), child);
          if (!child._dur || _clamp(0, child.totalDuration(), t2) - child._tTime > _tinyNum) {
            child.render(t2, true);
          }
        }
        if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
          if (timeline2._dur < timeline2.duration()) {
            t2 = timeline2;
            while (t2._dp) {
              t2.rawTime() >= 0 && t2.totalTime(t2._tTime);
              t2 = t2._dp;
            }
          }
          timeline2._zTime = -_tinyNum;
        }
      };
      _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
        child.parent && _removeFromParent(child);
        child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
        child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
        _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
        _isFromOrFromStart(child) || (timeline2._recent = child);
        skipChecks || _postAddChecks(timeline2, child);
        timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
        return timeline2;
      };
      _scrollTrigger = function _scrollTrigger2(animation, trigger) {
        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
      };
      _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
        _initTween(tween, time, tTime);
        if (!tween._initted) {
          return 1;
        }
        if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
          _lazyTweens.push(tween);
          tween._lazy = [tTime, suppressEvents];
          return 1;
        }
      };
      _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
        var parent = _ref.parent;
        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
      };
      _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
        var data = _ref2.data;
        return data === "isFromStart" || data === "isStart";
      };
      _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
        var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
        if (repeatDelay && tween._repeat) {
          tTime = _clamp(0, tween._tDur, totalTime);
          iteration = _animationCycle(tTime, repeatDelay);
          tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
          if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
            prevRatio = 1 - ratio;
            tween.vars.repeatRefresh && tween._initted && tween.invalidate();
          }
        }
        if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
          if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
            return;
          }
          prevIteration = tween._zTime;
          tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
          suppressEvents || (suppressEvents = totalTime && !prevIteration);
          tween.ratio = ratio;
          tween._from && (ratio = 1 - ratio);
          tween._time = 0;
          tween._tTime = tTime;
          pt = tween._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
          tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
          tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
          if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
            ratio && _removeFromParent(tween, 1);
            if (!suppressEvents && !_reverting) {
              _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
              tween._prom && tween._prom();
            }
          }
        } else if (!tween._zTime) {
          tween._zTime = totalTime;
        }
      };
      _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
        var child;
        if (time > prevTime) {
          child = animation._first;
          while (child && child._start <= time) {
            if (child.data === "isPause" && child._start > prevTime) {
              return child;
            }
            child = child._next;
          }
        } else {
          child = animation._last;
          while (child && child._start >= time) {
            if (child.data === "isPause" && child._start < prevTime) {
              return child;
            }
            child = child._prev;
          }
        }
      };
      _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
        var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
        totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
        animation._dur = dur;
        animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
        totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
        animation.parent && _setEnd(animation);
        skipUncache || _uncache(animation.parent, animation);
        return animation;
      };
      _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
      };
      _zeroPosition = {
        _start: 0,
        endTime: _emptyFunc,
        totalDuration: _emptyFunc
      };
      _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
        var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i3, offset, isPercent;
        if (_isString(position) && (isNaN(position) || position in labels)) {
          offset = position.charAt(0);
          isPercent = position.substr(-1) === "%";
          i3 = position.indexOf("=");
          if (offset === "<" || offset === ">") {
            i3 >= 0 && (position = position.replace(/=/, ""));
            return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i3 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
          }
          if (i3 < 0) {
            position in labels || (labels[position] = clippedDuration);
            return labels[position];
          }
          offset = parseFloat(position.charAt(i3 - 1) + position.substr(i3 + 1));
          if (isPercent && percentAnimation) {
            offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
          }
          return i3 > 1 ? _parsePosition2(animation, position.substr(0, i3 - 1), percentAnimation) + offset : clippedDuration + offset;
        }
        return position == null ? clippedDuration : +position;
      };
      _createTweenType = function _createTweenType2(type, params, timeline2) {
        var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
        isLegacy && (vars.duration = params[1]);
        vars.parent = timeline2;
        if (type) {
          irVars = vars;
          parent = timeline2;
          while (parent && !("immediateRender" in irVars)) {
            irVars = parent.vars.defaults || {};
            parent = _isNotFalse(parent.vars.inherit) && parent.parent;
          }
          vars.immediateRender = _isNotFalse(irVars.immediateRender);
          type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
        }
        return new Tween(params[0], vars, params[varsIndex + 1]);
      };
      _conditionalReturn = function _conditionalReturn2(value, func) {
        return value || value === 0 ? func(value) : func;
      };
      _clamp = function _clamp2(min, max, value) {
        return value < min ? min : value > max ? max : value;
      };
      getUnit = function getUnit2(value, v2) {
        return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
      };
      clamp = function clamp2(min, max, value) {
        return _conditionalReturn(value, function(v2) {
          return _clamp(min, max, v2);
        });
      };
      _slice = [].slice;
      _isArrayLike = function _isArrayLike2(value, nonEmpty) {
        return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
      };
      _flatten = function _flatten2(ar, leaveStrings, accumulator) {
        if (accumulator === void 0) {
          accumulator = [];
        }
        return ar.forEach(function(value) {
          var _accumulator;
          return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
        }) || accumulator;
      };
      toArray = function toArray2(value, scope, leaveStrings) {
        return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
      };
      selector = function selector2(value) {
        value = toArray(value)[0] || _warn("Invalid scope") || {};
        return function(v2) {
          var el = value.current || value.nativeElement || value;
          return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
        };
      };
      shuffle = function shuffle2(a2) {
        return a2.sort(function() {
          return 0.5 - Math.random();
        });
      };
      distribute = function distribute2(v2) {
        if (_isFunction(v2)) {
          return v2;
        }
        var vars = _isObject(v2) ? v2 : {
          each: v2
        }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
        if (_isString(from)) {
          ratioX = ratioY = {
            center: 0.5,
            edges: 0.5,
            end: 1
          }[from] || 0;
        } else if (!isDecimal && ratios) {
          ratioX = from[0];
          ratioY = from[1];
        }
        return function(i3, target, a2) {
          var l2 = (a2 || vars).length, distances = cache[l2], originX, originY, x2, y2, d2, j2, max, min, wrapAt;
          if (!distances) {
            wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
            if (!wrapAt) {
              max = -_bigNum;
              while (max < (max = a2[wrapAt++].getBoundingClientRect().left) && wrapAt < l2) {
              }
              wrapAt < l2 && wrapAt--;
            }
            distances = cache[l2] = [];
            originX = ratios ? Math.min(wrapAt, l2) * ratioX - 0.5 : from % wrapAt;
            originY = wrapAt === _bigNum ? 0 : ratios ? l2 * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
            max = 0;
            min = _bigNum;
            for (j2 = 0; j2 < l2; j2++) {
              x2 = j2 % wrapAt - originX;
              y2 = originY - (j2 / wrapAt | 0);
              distances[j2] = d2 = !axis ? _sqrt(x2 * x2 + y2 * y2) : Math.abs(axis === "y" ? y2 : x2);
              d2 > max && (max = d2);
              d2 < min && (min = d2);
            }
            from === "random" && shuffle(distances);
            distances.max = max - min;
            distances.min = min;
            distances.v = l2 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l2 ? l2 - 1 : !axis ? Math.max(wrapAt, l2 / wrapAt) : axis === "y" ? l2 / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
            distances.b = l2 < 0 ? base - l2 : base;
            distances.u = getUnit(vars.amount || vars.each) || 0;
            ease = ease && l2 < 0 ? _invertEase(ease) : ease;
          }
          l2 = (distances[i3] - distances.min) / distances.max || 0;
          return _roundPrecise(distances.b + (ease ? ease(l2) : l2) * distances.v) + distances.u;
        };
      };
      _roundModifier = function _roundModifier2(v2) {
        var p3 = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
        return function(raw) {
          var n2 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p3);
          return (n2 - n2 % 1) / p3 + (_isNumber(raw) ? 0 : getUnit(raw));
        };
      };
      snap = function snap2(snapTo, value) {
        var isArray = _isArray(snapTo), radius, is2D;
        if (!isArray && _isObject(snapTo)) {
          radius = isArray = snapTo.radius || _bigNum;
          if (snapTo.values) {
            snapTo = toArray(snapTo.values);
            if (is2D = !_isNumber(snapTo[0])) {
              radius *= radius;
            }
          } else {
            snapTo = _roundModifier(snapTo.increment);
          }
        }
        return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
          is2D = snapTo(raw);
          return Math.abs(is2D - raw) <= radius ? is2D : raw;
        } : function(raw) {
          var x2 = parseFloat(is2D ? raw.x : raw), y2 = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i3 = snapTo.length, dx, dy;
          while (i3--) {
            if (is2D) {
              dx = snapTo[i3].x - x2;
              dy = snapTo[i3].y - y2;
              dx = dx * dx + dy * dy;
            } else {
              dx = Math.abs(snapTo[i3] - x2);
            }
            if (dx < min) {
              min = dx;
              closest = i3;
            }
          }
          closest = !radius || min <= radius ? snapTo[closest] : raw;
          return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
        });
      };
      random = function random2(min, max, roundingIncrement, returnFunction) {
        return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
          return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
        });
      };
      pipe = function pipe2() {
        for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
          functions[_key] = arguments[_key];
        }
        return function(value) {
          return functions.reduce(function(v2, f2) {
            return f2(v2);
          }, value);
        };
      };
      unitize = function unitize2(func, unit) {
        return function(value) {
          return func(parseFloat(value)) + (unit || getUnit(value));
        };
      };
      normalize = function normalize2(min, max, value) {
        return mapRange(min, max, 0, 1, value);
      };
      _wrapArray = function _wrapArray2(a2, wrapper, value) {
        return _conditionalReturn(value, function(index) {
          return a2[~~wrapper(index)];
        });
      };
      wrap = function wrap2(min, max, value) {
        var range = max - min;
        return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
          return (range + (value2 - min) % range) % range + min;
        });
      };
      wrapYoyo = function wrapYoyo2(min, max, value) {
        var range = max - min, total = range * 2;
        return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
          value2 = (total + (value2 - min) % total) % total || 0;
          return min + (value2 > range ? total - value2 : value2);
        });
      };
      _replaceRandom = function _replaceRandom2(value) {
        var prev = 0, s2 = "", i3, nums, end, isArray;
        while (~(i3 = value.indexOf("random(", prev))) {
          end = value.indexOf(")", i3);
          isArray = value.charAt(i3 + 7) === "[";
          nums = value.substr(i3 + 7, end - i3 - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
          s2 += value.substr(prev, i3 - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
          prev = end + 1;
        }
        return s2 + value.substr(prev, value.length - prev);
      };
      mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
        var inRange = inMax - inMin, outRange = outMax - outMin;
        return _conditionalReturn(value, function(value2) {
          return outMin + ((value2 - inMin) / inRange * outRange || 0);
        });
      };
      interpolate = function interpolate2(start, end, progress, mutate) {
        var func = isNaN(start + end) ? 0 : function(p4) {
          return (1 - p4) * start + p4 * end;
        };
        if (!func) {
          var isString = _isString(start), master = {}, p3, i3, interpolators, l2, il;
          progress === true && (mutate = 1) && (progress = null);
          if (isString) {
            start = {
              p: start
            };
            end = {
              p: end
            };
          } else if (_isArray(start) && !_isArray(end)) {
            interpolators = [];
            l2 = start.length;
            il = l2 - 2;
            for (i3 = 1; i3 < l2; i3++) {
              interpolators.push(interpolate2(start[i3 - 1], start[i3]));
            }
            l2--;
            func = function func2(p4) {
              p4 *= l2;
              var i4 = Math.min(il, ~~p4);
              return interpolators[i4](p4 - i4);
            };
            progress = end;
          } else if (!mutate) {
            start = _merge(_isArray(start) ? [] : {}, start);
          }
          if (!interpolators) {
            for (p3 in end) {
              _addPropTween.call(master, start, p3, "get", end[p3]);
            }
            func = function func2(p4) {
              return _renderPropTweens(p4, master) || (isString ? start.p : start);
            };
          }
        }
        return _conditionalReturn(progress, func);
      };
      _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
        var labels = timeline2.labels, min = _bigNum, p3, distance, label;
        for (p3 in labels) {
          distance = labels[p3] - fromTime;
          if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
            label = p3;
            min = distance;
          }
        }
        return label;
      };
      _callback = function _callback2(animation, type, executeLazyFirst) {
        var v2 = animation.vars, callback = v2[type], prevContext = _context, context4 = animation._ctx, params, scope, result;
        if (!callback) {
          return;
        }
        params = v2[type + "Params"];
        scope = v2.callbackScope || animation;
        executeLazyFirst && _lazyTweens.length && _lazyRender();
        context4 && (_context = context4);
        result = params ? callback.apply(scope, params) : callback.call(scope);
        _context = prevContext;
        return result;
      };
      _interrupt = function _interrupt2(animation) {
        _removeFromParent(animation);
        animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
        animation.progress() < 1 && _callback(animation, "onInterrupt");
        return animation;
      };
      _registerPluginQueue = [];
      _createPlugin = function _createPlugin2(config3) {
        if (!config3)
          return;
        config3 = !config3.name && config3["default"] || config3;
        if (_windowExists() || config3.headless) {
          var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
            this._props = [];
          } : config3, instanceDefaults = {
            init: _emptyFunc,
            render: _renderPropTweens,
            add: _addPropTween,
            kill: _killPropTweensOf,
            modifier: _addPluginModifier,
            rawVars: 0
          }, statics = {
            targetTest: 0,
            get: 0,
            getSetter: _getSetter,
            aliases: {},
            register: 0
          };
          _wake();
          if (config3 !== Plugin) {
            if (_plugins[name]) {
              return;
            }
            _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
            _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
            _plugins[Plugin.prop = name] = Plugin;
            if (config3.targetTest) {
              _harnessPlugins.push(Plugin);
              _reservedProps[name] = 1;
            }
            name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
          }
          _addGlobal(name, Plugin);
          config3.register && config3.register(gsap, Plugin, PropTween);
        } else {
          _registerPluginQueue.push(config3);
        }
      };
      _255 = 255;
      _colorLookup = {
        aqua: [0, _255, _255],
        lime: [0, _255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, _255],
        navy: [0, 0, 128],
        white: [_255, _255, _255],
        olive: [128, 128, 0],
        yellow: [_255, _255, 0],
        orange: [_255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [_255, 0, 0],
        pink: [_255, 192, 203],
        cyan: [0, _255, _255],
        transparent: [_255, _255, _255, 0]
      };
      _hue = function _hue2(h2, m1, m2) {
        h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
        return (h2 * 6 < 1 ? m1 + (m2 - m1) * h2 * 6 : h2 < 0.5 ? m2 : h2 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
      };
      splitColor = function splitColor2(v2, toHSL, forceAlpha) {
        var a2 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r2, g2, b2, h2, s2, l2, max, min, d2, wasHSL;
        if (!a2) {
          if (v2.substr(-1) === ",") {
            v2 = v2.substr(0, v2.length - 1);
          }
          if (_colorLookup[v2]) {
            a2 = _colorLookup[v2];
          } else if (v2.charAt(0) === "#") {
            if (v2.length < 6) {
              r2 = v2.charAt(1);
              g2 = v2.charAt(2);
              b2 = v2.charAt(3);
              v2 = "#" + r2 + r2 + g2 + g2 + b2 + b2 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
            }
            if (v2.length === 9) {
              a2 = parseInt(v2.substr(1, 6), 16);
              return [a2 >> 16, a2 >> 8 & _255, a2 & _255, parseInt(v2.substr(7), 16) / 255];
            }
            v2 = parseInt(v2.substr(1), 16);
            a2 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
          } else if (v2.substr(0, 3) === "hsl") {
            a2 = wasHSL = v2.match(_strictNumExp);
            if (!toHSL) {
              h2 = +a2[0] % 360 / 360;
              s2 = +a2[1] / 100;
              l2 = +a2[2] / 100;
              g2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
              r2 = l2 * 2 - g2;
              a2.length > 3 && (a2[3] *= 1);
              a2[0] = _hue(h2 + 1 / 3, r2, g2);
              a2[1] = _hue(h2, r2, g2);
              a2[2] = _hue(h2 - 1 / 3, r2, g2);
            } else if (~v2.indexOf("=")) {
              a2 = v2.match(_numExp);
              forceAlpha && a2.length < 4 && (a2[3] = 1);
              return a2;
            }
          } else {
            a2 = v2.match(_strictNumExp) || _colorLookup.transparent;
          }
          a2 = a2.map(Number);
        }
        if (toHSL && !wasHSL) {
          r2 = a2[0] / _255;
          g2 = a2[1] / _255;
          b2 = a2[2] / _255;
          max = Math.max(r2, g2, b2);
          min = Math.min(r2, g2, b2);
          l2 = (max + min) / 2;
          if (max === min) {
            h2 = s2 = 0;
          } else {
            d2 = max - min;
            s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
            h2 = max === r2 ? (g2 - b2) / d2 + (g2 < b2 ? 6 : 0) : max === g2 ? (b2 - r2) / d2 + 2 : (r2 - g2) / d2 + 4;
            h2 *= 60;
          }
          a2[0] = ~~(h2 + 0.5);
          a2[1] = ~~(s2 * 100 + 0.5);
          a2[2] = ~~(l2 * 100 + 0.5);
        }
        forceAlpha && a2.length < 4 && (a2[3] = 1);
        return a2;
      };
      _colorOrderData = function _colorOrderData2(v2) {
        var values = [], c2 = [], i3 = -1;
        v2.split(_colorExp).forEach(function(v3) {
          var a2 = v3.match(_numWithUnitExp) || [];
          values.push.apply(values, a2);
          c2.push(i3 += a2.length + 1);
        });
        values.c = c2;
        return values;
      };
      _formatColors = function _formatColors2(s2, toHSL, orderMatchData) {
        var result = "", colors2 = (s2 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i3 = 0, c2, shell, d2, l2;
        if (!colors2) {
          return s2;
        }
        colors2 = colors2.map(function(color) {
          return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
        });
        if (orderMatchData) {
          d2 = _colorOrderData(s2);
          c2 = orderMatchData.c;
          if (c2.join(result) !== d2.c.join(result)) {
            shell = s2.replace(_colorExp, "1").split(_numWithUnitExp);
            l2 = shell.length - 1;
            for (; i3 < l2; i3++) {
              result += shell[i3] + (~c2.indexOf(i3) ? colors2.shift() || type + "0,0,0,0)" : (d2.length ? d2 : colors2.length ? colors2 : orderMatchData).shift());
            }
          }
        }
        if (!shell) {
          shell = s2.split(_colorExp);
          l2 = shell.length - 1;
          for (; i3 < l2; i3++) {
            result += shell[i3] + colors2[i3];
          }
        }
        return result + shell[l2];
      };
      _colorExp = function() {
        var s2 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p3;
        for (p3 in _colorLookup) {
          s2 += "|" + p3 + "\\b";
        }
        return new RegExp(s2 + ")", "gi");
      }();
      _hslExp = /hsl[a]?\(/;
      _colorStringFilter = function _colorStringFilter2(a2) {
        var combined = a2.join(" "), toHSL;
        _colorExp.lastIndex = 0;
        if (_colorExp.test(combined)) {
          toHSL = _hslExp.test(combined);
          a2[1] = _formatColors(a2[1], toHSL);
          a2[0] = _formatColors(a2[0], toHSL, _colorOrderData(a2[1]));
          return true;
        }
      };
      _ticker = function() {
        var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick2 = function _tick3(v2) {
          var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch, time, frame;
          (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
          _lastUpdate += elapsed;
          time = _lastUpdate - _startTime;
          overlap = time - _nextTime;
          if (overlap > 0 || manual) {
            frame = ++_self.frame;
            _delta = time - _self.time * 1e3;
            _self.time = time = time / 1e3;
            _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
            dispatch = 1;
          }
          manual || (_id = _req(_tick3));
          if (dispatch) {
            for (_i = 0; _i < _listeners2.length; _i++) {
              _listeners2[_i](time, _delta, frame, v2);
            }
          }
        };
        _self = {
          time: 0,
          frame: 0,
          tick: function tick() {
            _tick2(true);
          },
          deltaRatio: function deltaRatio(fps) {
            return _delta / (1e3 / (fps || 60));
          },
          wake: function wake() {
            if (_coreReady) {
              if (!_coreInitted && _windowExists()) {
                _win = _coreInitted = window;
                _doc = _win.document || {};
                _globals.gsap = gsap;
                (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                _registerPluginQueue.forEach(_createPlugin);
              }
              _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
              _id && _self.sleep();
              _req = _raf || function(f2) {
                return setTimeout(f2, _nextTime - _self.time * 1e3 + 1 | 0);
              };
              _tickerActive = 1;
              _tick2(2);
            }
          },
          sleep: function sleep() {
            (_raf ? cancelAnimationFrame : clearTimeout)(_id);
            _tickerActive = 0;
            _req = _emptyFunc;
          },
          lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
            _lagThreshold = threshold || Infinity;
            _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
          },
          fps: function fps(_fps) {
            _gap = 1e3 / (_fps || 240);
            _nextTime = _self.time * 1e3 + _gap;
          },
          add: function add(callback, once, prioritize) {
            var func = once ? function(t2, d2, f2, v2) {
              callback(t2, d2, f2, v2);
              _self.remove(func);
            } : callback;
            _self.remove(callback);
            _listeners2[prioritize ? "unshift" : "push"](func);
            _wake();
            return func;
          },
          remove: function remove(callback, i3) {
            ~(i3 = _listeners2.indexOf(callback)) && _listeners2.splice(i3, 1) && _i >= i3 && _i--;
          },
          _listeners: _listeners2
        };
        return _self;
      }();
      _wake = function _wake2() {
        return !_tickerActive && _ticker.wake();
      };
      _easeMap = {};
      _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
      _quotesExp = /["']/g;
      _parseObjectInString = function _parseObjectInString2(value) {
        var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i3 = 1, l2 = split.length, index, val, parsedVal;
        for (; i3 < l2; i3++) {
          val = split[i3];
          index = i3 !== l2 - 1 ? val.lastIndexOf(",") : val.length;
          parsedVal = val.substr(0, index);
          obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
          key = val.substr(index + 1).trim();
        }
        return obj;
      };
      _valueInParentheses = function _valueInParentheses2(value) {
        var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
        return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
      };
      _configEaseFromString = function _configEaseFromString2(name) {
        var split = (name + "").split("("), ease = _easeMap[split[0]];
        return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
      };
      _invertEase = function _invertEase2(ease) {
        return function(p3) {
          return 1 - ease(1 - p3);
        };
      };
      _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
        var child = timeline2._first, ease;
        while (child) {
          if (child instanceof Timeline) {
            _propagateYoyoEase2(child, isYoyo);
          } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
            if (child.timeline) {
              _propagateYoyoEase2(child.timeline, isYoyo);
            } else {
              ease = child._ease;
              child._ease = child._yEase;
              child._yEase = ease;
              child._yoyo = isYoyo;
            }
          }
          child = child._next;
        }
      };
      _parseEase = function _parseEase2(ease, defaultEase) {
        return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
      };
      _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
        if (easeOut === void 0) {
          easeOut = function easeOut2(p3) {
            return 1 - easeIn(1 - p3);
          };
        }
        if (easeInOut === void 0) {
          easeInOut = function easeInOut2(p3) {
            return p3 < 0.5 ? easeIn(p3 * 2) / 2 : 1 - easeIn((1 - p3) * 2) / 2;
          };
        }
        var ease = {
          easeIn,
          easeOut,
          easeInOut
        }, lowercaseName;
        _forEachName(names, function(name) {
          _easeMap[name] = _globals[name] = ease;
          _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
          for (var p3 in ease) {
            _easeMap[lowercaseName + (p3 === "easeIn" ? ".in" : p3 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p3] = ease[p3];
          }
        });
        return ease;
      };
      _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
        return function(p3) {
          return p3 < 0.5 ? (1 - easeOut(1 - p3 * 2)) / 2 : 0.5 + easeOut((p3 - 0.5) * 2) / 2;
        };
      };
      _configElastic = function _configElastic2(type, amplitude, period) {
        var p1 = amplitude >= 1 ? amplitude : 1, p22 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p22 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
          return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p22) + 1;
        }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
          return 1 - easeOut(1 - p4);
        } : _easeInOutFromOut(easeOut);
        p22 = _2PI / p22;
        ease.config = function(amplitude2, period2) {
          return _configElastic2(type, amplitude2, period2);
        };
        return ease;
      };
      _configBack = function _configBack2(type, overshoot) {
        if (overshoot === void 0) {
          overshoot = 1.70158;
        }
        var easeOut = function easeOut2(p3) {
          return p3 ? --p3 * p3 * ((overshoot + 1) * p3 + overshoot) + 1 : 0;
        }, ease = type === "out" ? easeOut : type === "in" ? function(p3) {
          return 1 - easeOut(1 - p3);
        } : _easeInOutFromOut(easeOut);
        ease.config = function(overshoot2) {
          return _configBack2(type, overshoot2);
        };
        return ease;
      };
      _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i3) {
        var power = i3 < 5 ? i3 + 1 : i3;
        _insertEase(name + ",Power" + (power - 1), i3 ? function(p3) {
          return Math.pow(p3, power);
        } : function(p3) {
          return p3;
        }, function(p3) {
          return 1 - Math.pow(1 - p3, power);
        }, function(p3) {
          return p3 < 0.5 ? Math.pow(p3 * 2, power) / 2 : 1 - Math.pow((1 - p3) * 2, power) / 2;
        });
      });
      _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
      _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
      (function(n2, c2) {
        var n1 = 1 / c2, n22 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p3) {
          return p3 < n1 ? n2 * p3 * p3 : p3 < n22 ? n2 * Math.pow(p3 - 1.5 / c2, 2) + 0.75 : p3 < n3 ? n2 * (p3 -= 2.25 / c2) * p3 + 0.9375 : n2 * Math.pow(p3 - 2.625 / c2, 2) + 0.984375;
        };
        _insertEase("Bounce", function(p3) {
          return 1 - easeOut(1 - p3);
        }, easeOut);
      })(7.5625, 2.75);
      _insertEase("Expo", function(p3) {
        return p3 ? Math.pow(2, 10 * (p3 - 1)) : 0;
      });
      _insertEase("Circ", function(p3) {
        return -(_sqrt(1 - p3 * p3) - 1);
      });
      _insertEase("Sine", function(p3) {
        return p3 === 1 ? 1 : -_cos(p3 * _HALF_PI) + 1;
      });
      _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
      _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
        config: function config(steps, immediateStart) {
          if (steps === void 0) {
            steps = 1;
          }
          var p1 = 1 / steps, p22 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
          return function(p4) {
            return ((p22 * _clamp(0, max, p4) | 0) + p3) * p1;
          };
        }
      };
      _defaults.ease = _easeMap["quad.out"];
      _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
        return _callbackNames += name + "," + name + "Params,";
      });
      GSCache = function GSCache2(target, harness) {
        this.id = _gsID++;
        target._gsap = this;
        this.target = target;
        this.harness = harness;
        this.get = harness ? harness.get : _getProperty;
        this.set = harness ? harness.getSetter : _getSetter;
      };
      Animation = /* @__PURE__ */ function() {
        function Animation2(vars) {
          this.vars = vars;
          this._delay = +vars.delay || 0;
          if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
            this._rDelay = vars.repeatDelay || 0;
            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
          }
          this._ts = 1;
          _setDuration(this, +vars.duration, 1, 1);
          this.data = vars.data;
          if (_context) {
            this._ctx = _context;
            _context.data.push(this);
          }
          _tickerActive || _ticker.wake();
        }
        var _proto = Animation2.prototype;
        _proto.delay = function delay(value) {
          if (value || value === 0) {
            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
            this._delay = value;
            return this;
          }
          return this._delay;
        };
        _proto.duration = function duration(value) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
        };
        _proto.totalDuration = function totalDuration(value) {
          if (!arguments.length) {
            return this._tDur;
          }
          this._dirty = 0;
          return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
        };
        _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
          _wake();
          if (!arguments.length) {
            return this._tTime;
          }
          var parent = this._dp;
          if (parent && parent.smoothChildTiming && this._ts) {
            _alignPlayhead(this, _totalTime);
            !parent._dp || parent.parent || _postAddChecks(parent, this);
            while (parent && parent.parent) {
              if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
                parent.totalTime(parent._tTime, true);
              }
              parent = parent.parent;
            }
            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
              _addToTimeline(this._dp, this, this._start - this._delay);
            }
          }
          if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
            this._ts || (this._pTime = _totalTime);
            _lazySafeRender(this, _totalTime, suppressEvents);
          }
          return this;
        };
        _proto.time = function time(value, suppressEvents) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
        };
        _proto.totalProgress = function totalProgress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
        };
        _proto.progress = function progress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
        };
        _proto.iteration = function iteration(value, suppressEvents) {
          var cycleDuration = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
        };
        _proto.timeScale = function timeScale(value, suppressEvents) {
          if (!arguments.length) {
            return this._rts === -_tinyNum ? 0 : this._rts;
          }
          if (this._rts === value) {
            return this;
          }
          var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
          this._rts = +value || 0;
          this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
          this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
          _setEnd(this);
          return _recacheAncestors(this);
        };
        _proto.paused = function paused(value) {
          if (!arguments.length) {
            return this._ps;
          }
          if (this._ps !== value) {
            this._ps = value;
            if (value) {
              this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
              this._ts = this._act = 0;
            } else {
              _wake();
              this._ts = this._rts;
              this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
            }
          }
          return this;
        };
        _proto.startTime = function startTime(value) {
          if (arguments.length) {
            this._start = value;
            var parent = this.parent || this._dp;
            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
            return this;
          }
          return this._start;
        };
        _proto.endTime = function endTime(includeRepeats) {
          return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
        };
        _proto.rawTime = function rawTime(wrapRepeats) {
          var parent = this.parent || this._dp;
          return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
        };
        _proto.revert = function revert(config3) {
          if (config3 === void 0) {
            config3 = _revertConfig;
          }
          var prevIsReverting = _reverting;
          _reverting = config3;
          if (this._initted || this._startAt) {
            this.timeline && this.timeline.revert(config3);
            this.totalTime(-0.01, config3.suppressEvents);
          }
          this.data !== "nested" && config3.kill !== false && this.kill();
          _reverting = prevIsReverting;
          return this;
        };
        _proto.globalTime = function globalTime(rawTime) {
          var animation = this, time = arguments.length ? rawTime : animation.rawTime();
          while (animation) {
            time = animation._start + time / (Math.abs(animation._ts) || 1);
            animation = animation._dp;
          }
          return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
        };
        _proto.repeat = function repeat(value) {
          if (arguments.length) {
            this._repeat = value === Infinity ? -2 : value;
            return _onUpdateTotalDuration(this);
          }
          return this._repeat === -2 ? Infinity : this._repeat;
        };
        _proto.repeatDelay = function repeatDelay(value) {
          if (arguments.length) {
            var time = this._time;
            this._rDelay = value;
            _onUpdateTotalDuration(this);
            return time ? this.time(time) : this;
          }
          return this._rDelay;
        };
        _proto.yoyo = function yoyo(value) {
          if (arguments.length) {
            this._yoyo = value;
            return this;
          }
          return this._yoyo;
        };
        _proto.seek = function seek(position, suppressEvents) {
          return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
        };
        _proto.restart = function restart(includeDelay, suppressEvents) {
          return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
        };
        _proto.play = function play(from, suppressEvents) {
          from != null && this.seek(from, suppressEvents);
          return this.reversed(false).paused(false);
        };
        _proto.reverse = function reverse(from, suppressEvents) {
          from != null && this.seek(from || this.totalDuration(), suppressEvents);
          return this.reversed(true).paused(false);
        };
        _proto.pause = function pause(atTime, suppressEvents) {
          atTime != null && this.seek(atTime, suppressEvents);
          return this.paused(true);
        };
        _proto.resume = function resume() {
          return this.paused(false);
        };
        _proto.reversed = function reversed(value) {
          if (arguments.length) {
            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
            return this;
          }
          return this._rts < 0;
        };
        _proto.invalidate = function invalidate() {
          this._initted = this._act = 0;
          this._zTime = -_tinyNum;
          return this;
        };
        _proto.isActive = function isActive() {
          var parent = this.parent || this._dp, start = this._start, rawTime;
          return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
        };
        _proto.eventCallback = function eventCallback(type, callback, params) {
          var vars = this.vars;
          if (arguments.length > 1) {
            if (!callback) {
              delete vars[type];
            } else {
              vars[type] = callback;
              params && (vars[type + "Params"] = params);
              type === "onUpdate" && (this._onUpdate = callback);
            }
            return this;
          }
          return vars[type];
        };
        _proto.then = function then(onFulfilled) {
          var self2 = this;
          return new Promise(function(resolve) {
            var f2 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
              var _then = self2.then;
              self2.then = null;
              _isFunction(f2) && (f2 = f2(self2)) && (f2.then || f2 === self2) && (self2.then = _then);
              resolve(f2);
              self2.then = _then;
            };
            if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
              _resolve();
            } else {
              self2._prom = _resolve;
            }
          });
        };
        _proto.kill = function kill() {
          _interrupt(this);
        };
        return Animation2;
      }();
      _setDefaults(Animation.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: false,
        parent: null,
        _initted: false,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -_tinyNum,
        _prom: 0,
        _ps: false,
        _rts: 1
      });
      Timeline = /* @__PURE__ */ function(_Animation) {
        _inheritsLoose(Timeline2, _Animation);
        function Timeline2(vars, position) {
          var _this;
          if (vars === void 0) {
            vars = {};
          }
          _this = _Animation.call(this, vars) || this;
          _this.labels = {};
          _this.smoothChildTiming = !!vars.smoothChildTiming;
          _this.autoRemoveChildren = !!vars.autoRemoveChildren;
          _this._sort = _isNotFalse(vars.sortChildren);
          _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
          vars.reversed && _this.reverse();
          vars.paused && _this.paused(true);
          vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
          return _this;
        }
        var _proto2 = Timeline2.prototype;
        _proto2.to = function to(targets, vars, position) {
          _createTweenType(0, arguments, this);
          return this;
        };
        _proto2.from = function from(targets, vars, position) {
          _createTweenType(1, arguments, this);
          return this;
        };
        _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
          _createTweenType(2, arguments, this);
          return this;
        };
        _proto2.set = function set(targets, vars, position) {
          vars.duration = 0;
          vars.parent = this;
          _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
          vars.immediateRender = !!vars.immediateRender;
          new Tween(targets, vars, _parsePosition(this, position), 1);
          return this;
        };
        _proto2.call = function call(callback, params, position) {
          return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
        };
        _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.duration = duration;
          vars.stagger = vars.stagger || stagger;
          vars.onComplete = onCompleteAll;
          vars.onCompleteParams = onCompleteAllParams;
          vars.parent = this;
          new Tween(targets, vars, _parsePosition(this, position));
          return this;
        };
        _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.runBackwards = 1;
          _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
          return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
        };
        _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
          toVars.startAt = fromVars;
          _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
          return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
        };
        _proto2.render = function render3(totalTime, suppressEvents, force) {
          var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
          this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
          if (tTime !== this._tTime || force || crossingStart) {
            if (prevTime !== this._time && dur) {
              tTime += this._time - prevTime;
              totalTime += this._time - prevTime;
            }
            time = tTime;
            prevStart = this._start;
            timeScale = this._ts;
            prevPaused = !timeScale;
            if (crossingStart) {
              dur || (prevTime = this._zTime);
              (totalTime || !suppressEvents) && (this._zTime = totalTime);
            }
            if (this._repeat) {
              yoyo = this._yoyo;
              cycleDuration = dur + this._rDelay;
              if (this._repeat < -1 && totalTime < 0) {
                return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
              }
              time = _roundPrecise(tTime % cycleDuration);
              if (tTime === tDur) {
                iteration = this._repeat;
                time = dur;
              } else {
                iteration = ~~(tTime / cycleDuration);
                if (iteration && iteration === tTime / cycleDuration) {
                  time = dur;
                  iteration--;
                }
                time > dur && (time = dur);
              }
              prevIteration = _animationCycle(this._tTime, cycleDuration);
              !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
              if (yoyo && iteration & 1) {
                time = dur - time;
                isYoyo = 1;
              }
              if (iteration !== prevIteration && !this._lock) {
                var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
                iteration < prevIteration && (rewinding = !rewinding);
                prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
                this._lock = 1;
                this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                this._tTime = tTime;
                !suppressEvents && this.parent && _callback(this, "onRepeat");
                this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                  return this;
                }
                dur = this._dur;
                tDur = this._tDur;
                if (doesWrap) {
                  this._lock = 2;
                  prevTime = rewinding ? dur : -1e-4;
                  this.render(prevTime, true);
                  this.vars.repeatRefresh && !isYoyo && this.invalidate();
                }
                this._lock = 0;
                if (!this._ts && !prevPaused) {
                  return this;
                }
                _propagateYoyoEase(this, isYoyo);
              }
            }
            if (this._hasPause && !this._forcing && this._lock < 2) {
              pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
              if (pauseTween) {
                tTime -= time - (time = pauseTween._start);
              }
            }
            this._tTime = tTime;
            this._time = time;
            this._act = !timeScale;
            if (!this._initted) {
              this._onUpdate = this.vars.onUpdate;
              this._initted = 1;
              this._zTime = totalTime;
              prevTime = 0;
            }
            if (!prevTime && time && !suppressEvents && !iteration) {
              _callback(this, "onStart");
              if (this._tTime !== tTime) {
                return this;
              }
            }
            if (time >= prevTime && totalTime >= 0) {
              child = this._first;
              while (child) {
                next = child._next;
                if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                  if (child.parent !== this) {
                    return this.render(totalTime, suppressEvents, force);
                  }
                  child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                  if (time !== this._time || !this._ts && !prevPaused) {
                    pauseTween = 0;
                    next && (tTime += this._zTime = -_tinyNum);
                    break;
                  }
                }
                child = next;
              }
            } else {
              child = this._last;
              var adjustedTime = totalTime < 0 ? totalTime : time;
              while (child) {
                next = child._prev;
                if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                  if (child.parent !== this) {
                    return this.render(totalTime, suppressEvents, force);
                  }
                  child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
                  if (time !== this._time || !this._ts && !prevPaused) {
                    pauseTween = 0;
                    next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                    break;
                  }
                }
                child = next;
              }
            }
            if (pauseTween && !suppressEvents) {
              this.pause();
              pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
              if (this._ts) {
                this._start = prevStart;
                _setEnd(this);
                return this.render(totalTime, suppressEvents, force);
              }
            }
            this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
            if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
              if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
                if (!this._lock) {
                  (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                  if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                    _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                  }
                }
              }
            }
          }
          return this;
        };
        _proto2.add = function add(child, position) {
          var _this2 = this;
          _isNumber(position) || (position = _parsePosition(this, position, child));
          if (!(child instanceof Animation)) {
            if (_isArray(child)) {
              child.forEach(function(obj) {
                return _this2.add(obj, position);
              });
              return this;
            }
            if (_isString(child)) {
              return this.addLabel(child, position);
            }
            if (_isFunction(child)) {
              child = Tween.delayedCall(0, child);
            } else {
              return this;
            }
          }
          return this !== child ? _addToTimeline(this, child, position) : this;
        };
        _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
          if (nested === void 0) {
            nested = true;
          }
          if (tweens === void 0) {
            tweens = true;
          }
          if (timelines === void 0) {
            timelines = true;
          }
          if (ignoreBeforeTime === void 0) {
            ignoreBeforeTime = -_bigNum;
          }
          var a2 = [], child = this._first;
          while (child) {
            if (child._start >= ignoreBeforeTime) {
              if (child instanceof Tween) {
                tweens && a2.push(child);
              } else {
                timelines && a2.push(child);
                nested && a2.push.apply(a2, child.getChildren(true, tweens, timelines));
              }
            }
            child = child._next;
          }
          return a2;
        };
        _proto2.getById = function getById2(id) {
          var animations = this.getChildren(1, 1, 1), i3 = animations.length;
          while (i3--) {
            if (animations[i3].vars.id === id) {
              return animations[i3];
            }
          }
        };
        _proto2.remove = function remove(child) {
          if (_isString(child)) {
            return this.removeLabel(child);
          }
          if (_isFunction(child)) {
            return this.killTweensOf(child);
          }
          _removeLinkedListItem(this, child);
          if (child === this._recent) {
            this._recent = this._last;
          }
          return _uncache(this);
        };
        _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
          if (!arguments.length) {
            return this._tTime;
          }
          this._forcing = 1;
          if (!this._dp && this._ts) {
            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
          }
          _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
          this._forcing = 0;
          return this;
        };
        _proto2.addLabel = function addLabel(label, position) {
          this.labels[label] = _parsePosition(this, position);
          return this;
        };
        _proto2.removeLabel = function removeLabel(label) {
          delete this.labels[label];
          return this;
        };
        _proto2.addPause = function addPause(position, callback, params) {
          var t2 = Tween.delayedCall(0, callback || _emptyFunc, params);
          t2.data = "isPause";
          this._hasPause = 1;
          return _addToTimeline(this, t2, _parsePosition(this, position));
        };
        _proto2.removePause = function removePause(position) {
          var child = this._first;
          position = _parsePosition(this, position);
          while (child) {
            if (child._start === position && child.data === "isPause") {
              _removeFromParent(child);
            }
            child = child._next;
          }
        };
        _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          var tweens = this.getTweensOf(targets, onlyActive), i3 = tweens.length;
          while (i3--) {
            _overwritingTween !== tweens[i3] && tweens[i3].kill(targets, props);
          }
          return this;
        };
        _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
          var a2 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
          while (child) {
            if (child instanceof Tween) {
              if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
                a2.push(child);
              }
            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
              a2.push.apply(a2, children);
            }
            child = child._next;
          }
          return a2;
        };
        _proto2.tweenTo = function tweenTo(position, vars) {
          vars = vars || {};
          var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
            ease: vars.ease || "none",
            lazy: false,
            immediateRender: false,
            time: endTime,
            overwrite: "auto",
            duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
            onStart: function onStart() {
              tl.pause();
              if (!initted) {
                var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                initted = 1;
              }
              _onStart && _onStart.apply(tween, onStartParams || []);
            }
          }, vars));
          return immediateRender ? tween.render(0) : tween;
        };
        _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
          return this.tweenTo(toPosition, _setDefaults({
            startAt: {
              time: _parsePosition(this, fromPosition)
            }
          }, vars));
        };
        _proto2.recent = function recent() {
          return this._recent;
        };
        _proto2.nextLabel = function nextLabel(afterTime) {
          if (afterTime === void 0) {
            afterTime = this._time;
          }
          return _getLabelInDirection(this, _parsePosition(this, afterTime));
        };
        _proto2.previousLabel = function previousLabel(beforeTime) {
          if (beforeTime === void 0) {
            beforeTime = this._time;
          }
          return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
        };
        _proto2.currentLabel = function currentLabel(value) {
          return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
        };
        _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
          if (ignoreBeforeTime === void 0) {
            ignoreBeforeTime = 0;
          }
          var child = this._first, labels = this.labels, p3;
          while (child) {
            if (child._start >= ignoreBeforeTime) {
              child._start += amount;
              child._end += amount;
            }
            child = child._next;
          }
          if (adjustLabels) {
            for (p3 in labels) {
              if (labels[p3] >= ignoreBeforeTime) {
                labels[p3] += amount;
              }
            }
          }
          return _uncache(this);
        };
        _proto2.invalidate = function invalidate(soft) {
          var child = this._first;
          this._lock = 0;
          while (child) {
            child.invalidate(soft);
            child = child._next;
          }
          return _Animation.prototype.invalidate.call(this, soft);
        };
        _proto2.clear = function clear(includeLabels) {
          if (includeLabels === void 0) {
            includeLabels = true;
          }
          var child = this._first, next;
          while (child) {
            next = child._next;
            this.remove(child);
            child = next;
          }
          this._dp && (this._time = this._tTime = this._pTime = 0);
          includeLabels && (this.labels = {});
          return _uncache(this);
        };
        _proto2.totalDuration = function totalDuration(value) {
          var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
          if (arguments.length) {
            return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
          }
          if (self2._dirty) {
            parent = self2.parent;
            while (child) {
              prev = child._prev;
              child._dirty && child.totalDuration();
              start = child._start;
              if (start > prevStart && self2._sort && child._ts && !self2._lock) {
                self2._lock = 1;
                _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
              } else {
                prevStart = start;
              }
              if (start < 0 && child._ts) {
                max -= start;
                if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
                  self2._start += start / self2._ts;
                  self2._time -= start;
                  self2._tTime -= start;
                }
                self2.shiftChildren(-start, false, -Infinity);
                prevStart = 0;
              }
              child._end > max && child._ts && (max = child._end);
              child = prev;
            }
            _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
            self2._dirty = 0;
          }
          return self2._tDur;
        };
        Timeline2.updateRoot = function updateRoot(time) {
          if (_globalTimeline._ts) {
            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
            _lastRenderedFrame = _ticker.frame;
          }
          if (_ticker.frame >= _nextGCFrame) {
            _nextGCFrame += _config.autoSleep || 120;
            var child = _globalTimeline._first;
            if (!child || !child._ts) {
              if (_config.autoSleep && _ticker._listeners.length < 2) {
                while (child && !child._ts) {
                  child = child._next;
                }
                child || _ticker.sleep();
              }
            }
          }
        };
        return Timeline2;
      }(Animation);
      _setDefaults(Timeline.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
      });
      _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
        var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a2;
        pt.b = start;
        pt.e = end;
        start += "";
        end += "";
        if (hasRandom = ~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }
        if (stringFilter) {
          a2 = [start, end];
          stringFilter(a2, target, prop);
          start = a2[0];
          end = a2[1];
        }
        startNums = start.match(_complexStringNumExp) || [];
        while (result = _complexStringNumExp.exec(end)) {
          endNum = result[0];
          chunk = end.substring(index, result.index);
          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(") {
            color = 1;
          }
          if (endNum !== startNums[matchIndex++]) {
            startNum = parseFloat(startNums[matchIndex - 1]) || 0;
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
              s: startNum,
              c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
              m: color && color < 4 ? Math.round : 0
            };
            index = _complexStringNumExp.lastIndex;
          }
        }
        pt.c = index < end.length ? end.substring(index, end.length) : "";
        pt.fp = funcParam;
        if (_relExp.test(end) || hasRandom) {
          pt.e = 0;
        }
        this._pt = pt;
        return pt;
      };
      _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
        _isFunction(end) && (end = end(index || 0, target, targets));
        var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
        if (_isString(end)) {
          if (~end.indexOf("random(")) {
            end = _replaceRandom(end);
          }
          if (end.charAt(1) === "=") {
            pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
            if (pt || pt === 0) {
              end = pt;
            }
          }
        }
        if (!optional || parsedStart !== end || _forceAllPropTweens) {
          if (!isNaN(parsedStart * end) && end !== "") {
            pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
            funcParam && (pt.fp = funcParam);
            modifier && pt.modifier(modifier, this, target);
            return this._pt = pt;
          }
          !currentValue && !(prop in target) && _missingPlugin(prop, end);
          return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
        }
      };
      _processVars = function _processVars2(vars, index, target, targets, tween) {
        _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
        if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
          return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
        }
        var copy = {}, p3;
        for (p3 in vars) {
          copy[p3] = _parseFuncOrString(vars[p3], tween, index, target, targets);
        }
        return copy;
      };
      _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
        var plugin, pt, ptLookup, i3;
        if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
          if (tween !== _quickTween) {
            ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
            i3 = plugin._props.length;
            while (i3--) {
              ptLookup[plugin._props[i3]] = pt;
            }
          }
        }
        return plugin;
      };
      _initTween = function _initTween2(tween, time, tTime) {
        var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i3, p3, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
        tl && (!keyframes || !ease) && (ease = "none");
        tween._ease = _parseEase(ease, _defaults.ease);
        tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
        if (yoyoEase && tween._yoyo && !tween._repeat) {
          yoyoEase = tween._yEase;
          tween._yEase = tween._ease;
          tween._ease = yoyoEase;
        }
        tween._from = !tl && !!vars.runBackwards;
        if (!tl || keyframes && !vars.stagger) {
          harness = targets[0] ? _getCache(targets[0]).harness : 0;
          harnessVars = harness && vars[harness.prop];
          cleanVars = _copyExcluding(vars, _reservedProps);
          if (prevStartAt) {
            prevStartAt._zTime < 0 && prevStartAt.progress(1);
            time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
            prevStartAt._lazy = 0;
          }
          if (startAt) {
            _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
              data: "isStart",
              overwrite: false,
              parent,
              immediateRender: true,
              lazy: !prevStartAt && _isNotFalse(lazy),
              startAt: null,
              delay: 0,
              onUpdate: onUpdate && function() {
                return _callback(tween, "onUpdate");
              },
              stagger: 0
            }, startAt)));
            tween._startAt._dp = 0;
            tween._startAt._sat = tween;
            time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
            if (immediateRender) {
              if (dur && time <= 0 && tTime <= 0) {
                time && (tween._zTime = time);
                return;
              }
            }
          } else if (runBackwards && dur) {
            if (!prevStartAt) {
              time && (immediateRender = false);
              p3 = _setDefaults({
                overwrite: false,
                data: "isFromStart",
                //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
                lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
                immediateRender,
                //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
                stagger: 0,
                parent
                //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
              }, cleanVars);
              harnessVars && (p3[harness.prop] = harnessVars);
              _removeFromParent(tween._startAt = Tween.set(targets, p3));
              tween._startAt._dp = 0;
              tween._startAt._sat = tween;
              time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
              tween._zTime = time;
              if (!immediateRender) {
                _initTween2(tween._startAt, _tinyNum, _tinyNum);
              } else if (!time) {
                return;
              }
            }
          }
          tween._pt = tween._ptCache = 0;
          lazy = dur && _isNotFalse(lazy) || lazy && !dur;
          for (i3 = 0; i3 < targets.length; i3++) {
            target = targets[i3];
            gsData = target._gsap || _harness(targets)[i3]._gsap;
            tween._ptLookup[i3] = ptLookup = {};
            _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
            index = fullTargets === targets ? i3 : fullTargets.indexOf(target);
            if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
              tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
              plugin._props.forEach(function(name) {
                ptLookup[name] = pt;
              });
              plugin.priority && (hasPriority = 1);
            }
            if (!harness || harnessVars) {
              for (p3 in cleanVars) {
                if (_plugins[p3] && (plugin = _checkPlugin(p3, cleanVars, tween, index, target, fullTargets))) {
                  plugin.priority && (hasPriority = 1);
                } else {
                  ptLookup[p3] = pt = _addPropTween.call(tween, target, p3, "get", cleanVars[p3], index, fullTargets, 0, vars.stringFilter);
                }
              }
            }
            tween._op && tween._op[i3] && tween.kill(target, tween._op[i3]);
            if (autoOverwrite && tween._pt) {
              _overwritingTween = tween;
              _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
              overwritten = !tween.parent;
              _overwritingTween = 0;
            }
            tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
          }
          hasPriority && _sortPropTweensByPriority(tween);
          tween._onInit && tween._onInit(tween);
        }
        tween._onUpdate = onUpdate;
        tween._initted = (!tween._op || tween._pt) && !overwritten;
        keyframes && time <= 0 && tl.render(_bigNum, true, true);
      };
      _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
        var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i3;
        if (!ptCache) {
          ptCache = tween._ptCache[property] = [];
          lookup = tween._ptLookup;
          i3 = tween._targets.length;
          while (i3--) {
            pt = lookup[i3][property];
            if (pt && pt.d && pt.d._pt) {
              pt = pt.d._pt;
              while (pt && pt.p !== property && pt.fp !== property) {
                pt = pt._next;
              }
            }
            if (!pt) {
              _forceAllPropTweens = 1;
              tween.vars[property] = "+=0";
              _initTween(tween, time);
              _forceAllPropTweens = 0;
              return skipRecursion ? _warn(property + " not eligible for reset") : 1;
            }
            ptCache.push(pt);
          }
        }
        i3 = ptCache.length;
        while (i3--) {
          rootPT = ptCache[i3];
          pt = rootPT._pt || rootPT;
          pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
          pt.c = value - pt.s;
          rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
          rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
        }
      };
      _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
        var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p3, i3, aliases;
        if (!propertyAliases) {
          return vars;
        }
        copy = _merge({}, vars);
        for (p3 in propertyAliases) {
          if (p3 in copy) {
            aliases = propertyAliases[p3].split(",");
            i3 = aliases.length;
            while (i3--) {
              copy[aliases[i3]] = copy[p3];
            }
          }
        }
        return copy;
      };
      _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
        var ease = obj.ease || easeEach || "power1.inOut", p3, a2;
        if (_isArray(obj)) {
          a2 = allProps[prop] || (allProps[prop] = []);
          obj.forEach(function(value, i3) {
            return a2.push({
              t: i3 / (obj.length - 1) * 100,
              v: value,
              e: ease
            });
          });
        } else {
          for (p3 in obj) {
            a2 = allProps[p3] || (allProps[p3] = []);
            p3 === "ease" || a2.push({
              t: parseFloat(prop),
              v: obj[p3],
              e: ease
            });
          }
        }
      };
      _parseFuncOrString = function _parseFuncOrString2(value, tween, i3, target, targets) {
        return _isFunction(value) ? value.call(tween, i3, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
      };
      _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
      _staggerPropsToSkip = {};
      _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
        return _staggerPropsToSkip[name] = 1;
      });
      Tween = /* @__PURE__ */ function(_Animation2) {
        _inheritsLoose(Tween2, _Animation2);
        function Tween2(targets, vars, position, skipInherit) {
          var _this3;
          if (typeof vars === "number") {
            position.duration = vars;
            vars = position;
            position = null;
          }
          _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
          var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i3, copy, l2, p3, curTarget, staggerFunc, staggerVarsToMerge;
          _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
          _this3._ptLookup = [];
          _this3._overwrite = overwrite;
          if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
            vars = _this3.vars;
            tl = _this3.timeline = new Timeline({
              data: "nested",
              defaults: defaults2 || {},
              targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
            });
            tl.kill();
            tl.parent = tl._dp = _assertThisInitialized(_this3);
            tl._start = 0;
            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
              l2 = parsedTargets.length;
              staggerFunc = stagger && distribute(stagger);
              if (_isObject(stagger)) {
                for (p3 in stagger) {
                  if (~_staggerTweenProps.indexOf(p3)) {
                    staggerVarsToMerge || (staggerVarsToMerge = {});
                    staggerVarsToMerge[p3] = stagger[p3];
                  }
                }
              }
              for (i3 = 0; i3 < l2; i3++) {
                copy = _copyExcluding(vars, _staggerPropsToSkip);
                copy.stagger = 0;
                yoyoEase && (copy.yoyoEase = yoyoEase);
                staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                curTarget = parsedTargets[i3];
                copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i3, curTarget, parsedTargets);
                copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i3, curTarget, parsedTargets) || 0) - _this3._delay;
                if (!stagger && l2 === 1 && copy.delay) {
                  _this3._delay = delay = copy.delay;
                  _this3._start += delay;
                  copy.delay = 0;
                }
                tl.to(curTarget, copy, staggerFunc ? staggerFunc(i3, curTarget, parsedTargets) : 0);
                tl._ease = _easeMap.none;
              }
              tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
            } else if (keyframes) {
              _inheritDefaults(_setDefaults(tl.vars.defaults, {
                ease: "none"
              }));
              tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
              var time = 0, a2, kf, v2;
              if (_isArray(keyframes)) {
                keyframes.forEach(function(frame) {
                  return tl.to(parsedTargets, frame, ">");
                });
                tl.duration();
              } else {
                copy = {};
                for (p3 in keyframes) {
                  p3 === "ease" || p3 === "easeEach" || _parseKeyframe(p3, keyframes[p3], copy, keyframes.easeEach);
                }
                for (p3 in copy) {
                  a2 = copy[p3].sort(function(a3, b2) {
                    return a3.t - b2.t;
                  });
                  time = 0;
                  for (i3 = 0; i3 < a2.length; i3++) {
                    kf = a2[i3];
                    v2 = {
                      ease: kf.e,
                      duration: (kf.t - (i3 ? a2[i3 - 1].t : 0)) / 100 * duration
                    };
                    v2[p3] = kf.v;
                    tl.to(parsedTargets, v2, time);
                    time += v2.duration;
                  }
                }
                tl.duration() < duration && tl.to({}, {
                  duration: duration - tl.duration()
                });
              }
            }
            duration || _this3.duration(duration = tl.duration());
          } else {
            _this3.timeline = 0;
          }
          if (overwrite === true && !_suppressOverwrites) {
            _overwritingTween = _assertThisInitialized(_this3);
            _globalTimeline.killTweensOf(parsedTargets);
            _overwritingTween = 0;
          }
          _addToTimeline(parent, _assertThisInitialized(_this3), position);
          vars.reversed && _this3.reverse();
          vars.paused && _this3.paused(true);
          if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
            _this3._tTime = -_tinyNum;
            _this3.render(Math.max(0, -delay) || 0);
          }
          scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
          return _this3;
        }
        var _proto3 = Tween2.prototype;
        _proto3.render = function render3(totalTime, suppressEvents, force) {
          var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
          if (!dur) {
            _renderZeroDurationTween(this, totalTime, suppressEvents, force);
          } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
            time = tTime;
            timeline2 = this.timeline;
            if (this._repeat) {
              cycleDuration = dur + this._rDelay;
              if (this._repeat < -1 && isNegative) {
                return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
              }
              time = _roundPrecise(tTime % cycleDuration);
              if (tTime === tDur) {
                iteration = this._repeat;
                time = dur;
              } else {
                iteration = ~~(tTime / cycleDuration);
                if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
                  time = dur;
                  iteration--;
                }
                time > dur && (time = dur);
              }
              isYoyo = this._yoyo && iteration & 1;
              if (isYoyo) {
                yoyoEase = this._yEase;
                time = dur - time;
              }
              prevIteration = _animationCycle(this._tTime, cycleDuration);
              if (time === prevTime && !force && this._initted && iteration === prevIteration) {
                this._tTime = tTime;
                return this;
              }
              if (iteration !== prevIteration) {
                timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
                if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
                  this._lock = force = 1;
                  this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
                }
              }
            }
            if (!this._initted) {
              if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
                this._tTime = 0;
                return this;
              }
              if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
                return this;
              }
              if (dur !== this._dur) {
                return this.render(totalTime, suppressEvents, force);
              }
            }
            this._tTime = tTime;
            this._time = time;
            if (!this._act && this._ts) {
              this._act = 1;
              this._lazy = 0;
            }
            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
            if (this._from) {
              this.ratio = ratio = 1 - ratio;
            }
            if (time && !prevTime && !suppressEvents && !iteration) {
              _callback(this, "onStart");
              if (this._tTime !== tTime) {
                return this;
              }
            }
            pt = this._pt;
            while (pt) {
              pt.r(ratio, pt.d);
              pt = pt._next;
            }
            timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
            if (this._onUpdate && !suppressEvents) {
              isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
              _callback(this, "onUpdate");
            }
            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
              isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
              (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
                _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
          return this;
        };
        _proto3.targets = function targets() {
          return this._targets;
        };
        _proto3.invalidate = function invalidate(soft) {
          (!soft || !this.vars.runBackwards) && (this._startAt = 0);
          this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
          this._ptLookup = [];
          this.timeline && this.timeline.invalidate(soft);
          return _Animation2.prototype.invalidate.call(this, soft);
        };
        _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
          _tickerActive || _ticker.wake();
          this._ts || this.play();
          var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
          this._initted || _initTween(this, time);
          ratio = this._ease(time / this._dur);
          if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
            return this.resetTo(property, value, start, startIsRelative, 1);
          }
          _alignPlayhead(this, 0);
          this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
          return this.render(0);
        };
        _proto3.kill = function kill(targets, vars) {
          if (vars === void 0) {
            vars = "all";
          }
          if (!targets && (!vars || vars === "all")) {
            this._lazy = this._pt = 0;
            return this.parent ? _interrupt(this) : this;
          }
          if (this.timeline) {
            var tDur = this.timeline.totalDuration();
            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
            return this;
          }
          var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p3, pt, i3;
          if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
            vars === "all" && (this._pt = 0);
            return _interrupt(this);
          }
          overwrittenProps = this._op = this._op || [];
          if (vars !== "all") {
            if (_isString(vars)) {
              p3 = {};
              _forEachName(vars, function(name) {
                return p3[name] = 1;
              });
              vars = p3;
            }
            vars = _addAliasesToVars(parsedTargets, vars);
          }
          i3 = parsedTargets.length;
          while (i3--) {
            if (~killingTargets.indexOf(parsedTargets[i3])) {
              curLookup = propTweenLookup[i3];
              if (vars === "all") {
                overwrittenProps[i3] = vars;
                props = curLookup;
                curOverwriteProps = {};
              } else {
                curOverwriteProps = overwrittenProps[i3] = overwrittenProps[i3] || {};
                props = vars;
              }
              for (p3 in props) {
                pt = curLookup && curLookup[p3];
                if (pt) {
                  if (!("kill" in pt.d) || pt.d.kill(p3) === true) {
                    _removeLinkedListItem(this, pt, "_pt");
                  }
                  delete curLookup[p3];
                }
                if (curOverwriteProps !== "all") {
                  curOverwriteProps[p3] = 1;
                }
              }
            }
          }
          this._initted && !this._pt && firstPT && _interrupt(this);
          return this;
        };
        Tween2.to = function to(targets, vars) {
          return new Tween2(targets, vars, arguments[2]);
        };
        Tween2.from = function from(targets, vars) {
          return _createTweenType(1, arguments);
        };
        Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
          return new Tween2(callback, 0, {
            immediateRender: false,
            lazy: false,
            overwrite: false,
            delay,
            onComplete: callback,
            onReverseComplete: callback,
            onCompleteParams: params,
            onReverseCompleteParams: params,
            callbackScope: scope
          });
        };
        Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
          return _createTweenType(2, arguments);
        };
        Tween2.set = function set(targets, vars) {
          vars.duration = 0;
          vars.repeatDelay || (vars.repeat = 0);
          return new Tween2(targets, vars);
        };
        Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          return _globalTimeline.killTweensOf(targets, props, onlyActive);
        };
        return Tween2;
      }(Animation);
      _setDefaults(Tween.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
      });
      _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
        Tween[name] = function() {
          var tl = new Timeline(), params = _slice.call(arguments, 0);
          params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
          return tl[name].apply(tl, params);
        };
      });
      _setterPlain = function _setterPlain2(target, property, value) {
        return target[property] = value;
      };
      _setterFunc = function _setterFunc2(target, property, value) {
        return target[property](value);
      };
      _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
        return target[property](data.fp, value);
      };
      _setterAttribute = function _setterAttribute2(target, property, value) {
        return target.setAttribute(property, value);
      };
      _getSetter = function _getSetter2(target, property) {
        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
      };
      _renderPlain = function _renderPlain2(ratio, data) {
        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
      };
      _renderBoolean = function _renderBoolean2(ratio, data) {
        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
      };
      _renderComplexString = function _renderComplexString2(ratio, data) {
        var pt = data._pt, s2 = "";
        if (!ratio && data.b) {
          s2 = data.b;
        } else if (ratio === 1 && data.e) {
          s2 = data.e;
        } else {
          while (pt) {
            s2 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s2;
            pt = pt._next;
          }
          s2 += data.c;
        }
        data.set(data.t, data.p, s2, data);
      };
      _renderPropTweens = function _renderPropTweens2(ratio, data) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      };
      _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
        var pt = this._pt, next;
        while (pt) {
          next = pt._next;
          pt.p === property && pt.modifier(modifier, tween, target);
          pt = next;
        }
      };
      _killPropTweensOf = function _killPropTweensOf2(property) {
        var pt = this._pt, hasNonDependentRemaining, next;
        while (pt) {
          next = pt._next;
          if (pt.p === property && !pt.op || pt.op === property) {
            _removeLinkedListItem(this, pt, "_pt");
          } else if (!pt.dep) {
            hasNonDependentRemaining = 1;
          }
          pt = next;
        }
        return !hasNonDependentRemaining;
      };
      _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
      };
      _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
        var pt = parent._pt, next, pt2, first, last;
        while (pt) {
          next = pt._next;
          pt2 = first;
          while (pt2 && pt2.pr > pt.pr) {
            pt2 = pt2._next;
          }
          if (pt._prev = pt2 ? pt2._prev : last) {
            pt._prev._next = pt;
          } else {
            first = pt;
          }
          if (pt._next = pt2) {
            pt2._prev = pt;
          } else {
            last = pt;
          }
          pt = next;
        }
        parent._pt = first;
      };
      PropTween = /* @__PURE__ */ function() {
        function PropTween3(next, target, prop, start, change, renderer, data, setter, priority) {
          this.t = target;
          this.s = start;
          this.c = change;
          this.p = prop;
          this.r = renderer || _renderPlain;
          this.d = data || this;
          this.set = setter || _setterPlain;
          this.pr = priority || 0;
          this._next = next;
          if (next) {
            next._prev = this;
          }
        }
        var _proto4 = PropTween3.prototype;
        _proto4.modifier = function modifier(func, tween, target) {
          this.mSet = this.mSet || this.set;
          this.set = _setterWithModifier;
          this.m = func;
          this.mt = target;
          this.tween = tween;
        };
        return PropTween3;
      }();
      _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
        return _reservedProps[name] = 1;
      });
      _globals.TweenMax = _globals.TweenLite = Tween;
      _globals.TimelineLite = _globals.TimelineMax = Timeline;
      _globalTimeline = new Timeline({
        sortChildren: false,
        defaults: _defaults,
        autoRemoveChildren: true,
        id: "root",
        smoothChildTiming: true
      });
      _config.stringFilter = _colorStringFilter;
      _media = [];
      _listeners = {};
      _emptyArray = [];
      _lastMediaTime = 0;
      _contextID = 0;
      _dispatch = function _dispatch2(type) {
        return (_listeners[type] || _emptyArray).map(function(f2) {
          return f2();
        });
      };
      _onMediaChange = function _onMediaChange2() {
        var time = Date.now(), matches = [];
        if (time - _lastMediaTime > 2) {
          _dispatch("matchMediaInit");
          _media.forEach(function(c2) {
            var queries = c2.queries, conditions = c2.conditions, match, p3, anyMatch, toggled;
            for (p3 in queries) {
              match = _win.matchMedia(queries[p3]).matches;
              match && (anyMatch = 1);
              if (match !== conditions[p3]) {
                conditions[p3] = match;
                toggled = 1;
              }
            }
            if (toggled) {
              c2.revert();
              anyMatch && matches.push(c2);
            }
          });
          _dispatch("matchMediaRevert");
          matches.forEach(function(c2) {
            return c2.onMatch(c2, function(func) {
              return c2.add(null, func);
            });
          });
          _lastMediaTime = time;
          _dispatch("matchMedia");
        }
      };
      Context = /* @__PURE__ */ function() {
        function Context2(func, scope) {
          this.selector = scope && selector(scope);
          this.data = [];
          this._r = [];
          this.isReverted = false;
          this.id = _contextID++;
          func && this.add(func);
        }
        var _proto5 = Context2.prototype;
        _proto5.add = function add(name, func, scope) {
          if (_isFunction(name)) {
            scope = func;
            func = name;
            name = _isFunction;
          }
          var self2 = this, f2 = function f3() {
            var prev = _context, prevSelector = self2.selector, result;
            prev && prev !== self2 && prev.data.push(self2);
            scope && (self2.selector = selector(scope));
            _context = self2;
            result = func.apply(self2, arguments);
            _isFunction(result) && self2._r.push(result);
            _context = prev;
            self2.selector = prevSelector;
            self2.isReverted = false;
            return result;
          };
          self2.last = f2;
          return name === _isFunction ? f2(self2, function(func2) {
            return self2.add(null, func2);
          }) : name ? self2[name] = f2 : f2;
        };
        _proto5.ignore = function ignore(func) {
          var prev = _context;
          _context = null;
          func(this);
          _context = prev;
        };
        _proto5.getTweens = function getTweens() {
          var a2 = [];
          this.data.forEach(function(e2) {
            return e2 instanceof Context2 ? a2.push.apply(a2, e2.getTweens()) : e2 instanceof Tween && !(e2.parent && e2.parent.data === "nested") && a2.push(e2);
          });
          return a2;
        };
        _proto5.clear = function clear() {
          this._r.length = this.data.length = 0;
        };
        _proto5.kill = function kill(revert, matchMedia2) {
          var _this4 = this;
          if (revert) {
            (function() {
              var tweens = _this4.getTweens(), i4 = _this4.data.length, t2;
              while (i4--) {
                t2 = _this4.data[i4];
                if (t2.data === "isFlip") {
                  t2.revert();
                  t2.getChildren(true, true, false).forEach(function(tween) {
                    return tweens.splice(tweens.indexOf(tween), 1);
                  });
                }
              }
              tweens.map(function(t3) {
                return {
                  g: t3._dur || t3._delay || t3._sat && !t3._sat.vars.immediateRender ? t3.globalTime(0) : -Infinity,
                  t: t3
                };
              }).sort(function(a2, b2) {
                return b2.g - a2.g || -Infinity;
              }).forEach(function(o2) {
                return o2.t.revert(revert);
              });
              i4 = _this4.data.length;
              while (i4--) {
                t2 = _this4.data[i4];
                if (t2 instanceof Timeline) {
                  if (t2.data !== "nested") {
                    t2.scrollTrigger && t2.scrollTrigger.revert();
                    t2.kill();
                  }
                } else {
                  !(t2 instanceof Tween) && t2.revert && t2.revert(revert);
                }
              }
              _this4._r.forEach(function(f2) {
                return f2(revert, _this4);
              });
              _this4.isReverted = true;
            })();
          } else {
            this.data.forEach(function(e2) {
              return e2.kill && e2.kill();
            });
          }
          this.clear();
          if (matchMedia2) {
            var i3 = _media.length;
            while (i3--) {
              _media[i3].id === this.id && _media.splice(i3, 1);
            }
          }
        };
        _proto5.revert = function revert(config3) {
          this.kill(config3 || {});
        };
        return Context2;
      }();
      MatchMedia = /* @__PURE__ */ function() {
        function MatchMedia2(scope) {
          this.contexts = [];
          this.scope = scope;
          _context && _context.data.push(this);
        }
        var _proto6 = MatchMedia2.prototype;
        _proto6.add = function add(conditions, func, scope) {
          _isObject(conditions) || (conditions = {
            matches: conditions
          });
          var context4 = new Context(0, scope || this.scope), cond = context4.conditions = {}, mq, p3, active;
          _context && !context4.selector && (context4.selector = _context.selector);
          this.contexts.push(context4);
          func = context4.add("onMatch", func);
          context4.queries = conditions;
          for (p3 in conditions) {
            if (p3 === "all") {
              active = 1;
            } else {
              mq = _win.matchMedia(conditions[p3]);
              if (mq) {
                _media.indexOf(context4) < 0 && _media.push(context4);
                (cond[p3] = mq.matches) && (active = 1);
                mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
              }
            }
          }
          active && func(context4, function(f2) {
            return context4.add(null, f2);
          });
          return this;
        };
        _proto6.revert = function revert(config3) {
          this.kill(config3 || {});
        };
        _proto6.kill = function kill(revert) {
          this.contexts.forEach(function(c2) {
            return c2.kill(revert, true);
          });
        };
        return MatchMedia2;
      }();
      _gsap = {
        registerPlugin: function registerPlugin() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          args.forEach(function(config3) {
            return _createPlugin(config3);
          });
        },
        timeline: function timeline(vars) {
          return new Timeline(vars);
        },
        getTweensOf: function getTweensOf(targets, onlyActive) {
          return _globalTimeline.getTweensOf(targets, onlyActive);
        },
        getProperty: function getProperty(target, property, unit, uncache) {
          _isString(target) && (target = toArray(target)[0]);
          var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
          unit === "native" && (unit = "");
          return !target ? target : !property ? function(property2, unit2, uncache2) {
            return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
          } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
        },
        quickSetter: function quickSetter(target, property, unit) {
          target = toArray(target);
          if (target.length > 1) {
            var setters = target.map(function(t2) {
              return gsap.quickSetter(t2, property, unit);
            }), l2 = setters.length;
            return function(value) {
              var i3 = l2;
              while (i3--) {
                setters[i3](value);
              }
            };
          }
          target = target[0] || {};
          var Plugin = _plugins[property], cache = _getCache(target), p3 = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
            var p4 = new Plugin();
            _quickTween._pt = 0;
            p4.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
            p4.render(1, p4);
            _quickTween._pt && _renderPropTweens(1, _quickTween);
          } : cache.set(target, p3);
          return Plugin ? setter : function(value) {
            return setter(target, p3, unit ? value + unit : value, cache, 1);
          };
        },
        quickTo: function quickTo(target, property, vars) {
          var _merge22;
          var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
            return tween.resetTo(property, value, start, startIsRelative);
          };
          func.tween = tween;
          return func;
        },
        isTweening: function isTweening(targets) {
          return _globalTimeline.getTweensOf(targets, true).length > 0;
        },
        defaults: function defaults(value) {
          value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
          return _mergeDeep(_defaults, value || {});
        },
        config: function config2(value) {
          return _mergeDeep(_config, value || {});
        },
        registerEffect: function registerEffect(_ref3) {
          var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
          (plugins || "").split(",").forEach(function(pluginName) {
            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
          });
          _effects[name] = function(targets, vars, tl) {
            return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
          };
          if (extendTimeline) {
            Timeline.prototype[name] = function(targets, vars, position) {
              return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
            };
          }
        },
        registerEase: function registerEase(name, ease) {
          _easeMap[name] = _parseEase(ease);
        },
        parseEase: function parseEase(ease, defaultEase) {
          return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
        },
        getById: function getById(id) {
          return _globalTimeline.getById(id);
        },
        exportRoot: function exportRoot(vars, includeDelayedCalls) {
          if (vars === void 0) {
            vars = {};
          }
          var tl = new Timeline(vars), child, next;
          tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
          _globalTimeline.remove(tl);
          tl._dp = 0;
          tl._time = tl._tTime = _globalTimeline._time;
          child = _globalTimeline._first;
          while (child) {
            next = child._next;
            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
              _addToTimeline(tl, child, child._start - child._delay);
            }
            child = next;
          }
          _addToTimeline(_globalTimeline, tl, 0);
          return tl;
        },
        context: function context2(func, scope) {
          return func ? new Context(func, scope) : _context;
        },
        matchMedia: function matchMedia(scope) {
          return new MatchMedia(scope);
        },
        matchMediaRefresh: function matchMediaRefresh() {
          return _media.forEach(function(c2) {
            var cond = c2.conditions, found, p3;
            for (p3 in cond) {
              if (cond[p3]) {
                cond[p3] = false;
                found = 1;
              }
            }
            found && c2.revert();
          }) || _onMediaChange();
        },
        addEventListener: function addEventListener(type, callback) {
          var a2 = _listeners[type] || (_listeners[type] = []);
          ~a2.indexOf(callback) || a2.push(callback);
        },
        removeEventListener: function removeEventListener(type, callback) {
          var a2 = _listeners[type], i3 = a2 && a2.indexOf(callback);
          i3 >= 0 && a2.splice(i3, 1);
        },
        utils: {
          wrap,
          wrapYoyo,
          distribute,
          random,
          snap,
          normalize,
          getUnit,
          clamp,
          splitColor,
          toArray,
          selector,
          mapRange,
          pipe,
          unitize,
          interpolate,
          shuffle
        },
        install: _install,
        effects: _effects,
        ticker: _ticker,
        updateRoot: Timeline.updateRoot,
        plugins: _plugins,
        globalTimeline: _globalTimeline,
        core: {
          PropTween,
          globals: _addGlobal,
          Tween,
          Timeline,
          Animation,
          getCache: _getCache,
          _removeLinkedListItem,
          reverting: function reverting() {
            return _reverting;
          },
          context: function context3(toAdd) {
            if (toAdd && _context) {
              _context.data.push(toAdd);
              toAdd._ctx = _context;
            }
            return _context;
          },
          suppressOverwrites: function suppressOverwrites(value) {
            return _suppressOverwrites = value;
          }
        }
      };
      _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
        return _gsap[name] = Tween[name];
      });
      _ticker.add(Timeline.updateRoot);
      _quickTween = _gsap.to({}, {
        duration: 0
      });
      _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
        var pt = plugin._pt;
        while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
          pt = pt._next;
        }
        return pt;
      };
      _addModifiers = function _addModifiers2(tween, modifiers) {
        var targets = tween._targets, p3, i3, pt;
        for (p3 in modifiers) {
          i3 = targets.length;
          while (i3--) {
            pt = tween._ptLookup[i3][p3];
            if (pt && (pt = pt.d)) {
              if (pt._pt) {
                pt = _getPluginPropTween(pt, p3);
              }
              pt && pt.modifier && pt.modifier(modifiers[p3], tween, targets[i3], p3);
            }
          }
        }
      };
      _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
        return {
          name,
          rawVars: 1,
          //don't pre-process function-based values or "random()" strings.
          init: function init6(target, vars, tween) {
            tween._onInit = function(tween2) {
              var temp, p3;
              if (_isString(vars)) {
                temp = {};
                _forEachName(vars, function(name2) {
                  return temp[name2] = 1;
                });
                vars = temp;
              }
              if (modifier) {
                temp = {};
                for (p3 in vars) {
                  temp[p3] = modifier(vars[p3]);
                }
                vars = temp;
              }
              _addModifiers(tween2, vars);
            };
          }
        };
      };
      gsap = _gsap.registerPlugin({
        name: "attr",
        init: function init2(target, vars, tween, index, targets) {
          var p3, pt, v2;
          this.tween = tween;
          for (p3 in vars) {
            v2 = target.getAttribute(p3) || "";
            pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p3], index, targets, 0, 0, p3);
            pt.op = p3;
            pt.b = v2;
            this._props.push(p3);
          }
        },
        render: function render(ratio, data) {
          var pt = data._pt;
          while (pt) {
            _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
            pt = pt._next;
          }
        }
      }, {
        name: "endArray",
        init: function init3(target, value) {
          var i3 = value.length;
          while (i3--) {
            this.add(target, i3, target[i3] || 0, value[i3], 0, 0, 0, 0, 0, 1);
          }
        }
      }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
      Tween.version = Timeline.version = gsap.version = "3.12.5";
      _coreReady = 1;
      _windowExists() && _wake();
      Power0 = _easeMap.Power0;
      Power1 = _easeMap.Power1;
      Power2 = _easeMap.Power2;
      Power3 = _easeMap.Power3;
      Power4 = _easeMap.Power4;
      Linear = _easeMap.Linear;
      Quad = _easeMap.Quad;
      Cubic = _easeMap.Cubic;
      Quart = _easeMap.Quart;
      Quint = _easeMap.Quint;
      Strong = _easeMap.Strong;
      Elastic = _easeMap.Elastic;
      Back = _easeMap.Back;
      SteppedEase = _easeMap.SteppedEase;
      Bounce = _easeMap.Bounce;
      Sine = _easeMap.Sine;
      Expo = _easeMap.Expo;
      Circ = _easeMap.Circ;
    }
  });

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js
  var _win2, _doc2, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting2, _windowExists3, _transformProps, _RAD2DEG, _DEG2RAD, _atan2, _bigNum2, _capsExp, _horizontalExp, _complexExp, _propertyAliases, _renderCSSProp, _renderPropWithEnd, _renderCSSPropWithBeginning, _renderRoundedCSSProp, _renderNonTweeningValue, _renderNonTweeningValueOnlyAtEnd, _setterCSSStyle, _setterCSSProp, _setterTransform, _setterScale, _setterScaleWithRender, _setterTransformWithRender, _transformProp, _transformOriginProp, _saveStyle, _removeIndependentTransforms, _revertStyle, _getStyleSaver, _supports3D, _createElement, _getComputedProperty, _prefixes, _checkPropPrefix, _initCore, _getBBoxHack, _getAttributeFallbacks, _getBBox, _isSVG, _removeProperty, _addNonTweeningPT, _nonConvertibleUnits, _nonStandardLayouts, _convertToUnit, _get, _tweenComplexCSSString, _keywordToPercent, _convertKeywordsToPercentages, _renderClearProps, _specialProps, _identity2DMatrix, _rotationalProperties, _isNullTransform, _getComputedTransformMatrixAsArray, _getMatrix, _applySVGOrigin, _parseTransform, _firstTwoOnly, _addPxTranslate, _renderNon3DTransforms, _zeroDeg, _zeroPx, _endParenthesis, _renderCSSTransforms, _renderSVGTransforms, _addRotationalPropTween, _assign, _addRawTransformPTs, CSSPlugin;
  var init_CSSPlugin = __esm({
    "node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js"() {
      init_gsap_core();
      _windowExists3 = function _windowExists4() {
        return typeof window !== "undefined";
      };
      _transformProps = {};
      _RAD2DEG = 180 / Math.PI;
      _DEG2RAD = Math.PI / 180;
      _atan2 = Math.atan2;
      _bigNum2 = 1e8;
      _capsExp = /([A-Z])/g;
      _horizontalExp = /(left|right|width|margin|padding|x)/i;
      _complexExp = /[\s,\(]\S/;
      _propertyAliases = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
      };
      _renderCSSProp = function _renderCSSProp2(ratio, data) {
        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
      };
      _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
      };
      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
      };
      _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
        var value = data.s + data.c * ratio;
        data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
      };
      _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
        return data.set(data.t, data.p, ratio ? data.e : data.b, data);
      };
      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
      };
      _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
        return target.style[property] = value;
      };
      _setterCSSProp = function _setterCSSProp2(target, property, value) {
        return target.style.setProperty(property, value);
      };
      _setterTransform = function _setterTransform2(target, property, value) {
        return target._gsap[property] = value;
      };
      _setterScale = function _setterScale2(target, property, value) {
        return target._gsap.scaleX = target._gsap.scaleY = value;
      };
      _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
        var cache = target._gsap;
        cache.scaleX = cache.scaleY = value;
        cache.renderTransform(ratio, cache);
      };
      _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
        var cache = target._gsap;
        cache[property] = value;
        cache.renderTransform(ratio, cache);
      };
      _transformProp = "transform";
      _transformOriginProp = _transformProp + "Origin";
      _saveStyle = function _saveStyle2(property, isNotCSS) {
        var _this = this;
        var target = this.target, style = target.style, cache = target._gsap;
        if (property in _transformProps && style) {
          this.tfm = this.tfm || {};
          if (property !== "transform") {
            property = _propertyAliases[property] || property;
            ~property.indexOf(",") ? property.split(",").forEach(function(a2) {
              return _this.tfm[a2] = _get(target, a2);
            }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
            property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
          } else {
            return _propertyAliases.transform.split(",").forEach(function(p3) {
              return _saveStyle2.call(_this, p3, isNotCSS);
            });
          }
          if (this.props.indexOf(_transformProp) >= 0) {
            return;
          }
          if (cache.svg) {
            this.svgo = target.getAttribute("data-svg-origin");
            this.props.push(_transformOriginProp, isNotCSS, "");
          }
          property = _transformProp;
        }
        (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
      };
      _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
        if (style.translate) {
          style.removeProperty("translate");
          style.removeProperty("scale");
          style.removeProperty("rotate");
        }
      };
      _revertStyle = function _revertStyle2() {
        var props = this.props, target = this.target, style = target.style, cache = target._gsap, i3, p3;
        for (i3 = 0; i3 < props.length; i3 += 3) {
          props[i3 + 1] ? target[props[i3]] = props[i3 + 2] : props[i3 + 2] ? style[props[i3]] = props[i3 + 2] : style.removeProperty(props[i3].substr(0, 2) === "--" ? props[i3] : props[i3].replace(_capsExp, "-$1").toLowerCase());
        }
        if (this.tfm) {
          for (p3 in this.tfm) {
            cache[p3] = this.tfm[p3];
          }
          if (cache.svg) {
            cache.renderTransform();
            target.setAttribute("data-svg-origin", this.svgo || "");
          }
          i3 = _reverting2();
          if ((!i3 || !i3.isStart) && !style[_transformProp]) {
            _removeIndependentTransforms(style);
            if (cache.zOrigin && style[_transformOriginProp]) {
              style[_transformOriginProp] += " " + cache.zOrigin + "px";
              cache.zOrigin = 0;
              cache.renderTransform();
            }
            cache.uncache = 1;
          }
        }
      };
      _getStyleSaver = function _getStyleSaver2(target, properties) {
        var saver = {
          target,
          props: [],
          revert: _revertStyle,
          save: _saveStyle
        };
        target._gsap || gsap.core.getCache(target);
        properties && properties.split(",").forEach(function(p3) {
          return saver.save(p3);
        });
        return saver;
      };
      _createElement = function _createElement2(type, ns) {
        var e2 = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
        return e2 && e2.style ? e2 : _doc2.createElement(type);
      };
      _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
        var cs = getComputedStyle(target);
        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
      };
      _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
      _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
        var e2 = element || _tempDiv, s2 = e2.style, i3 = 5;
        if (property in s2 && !preferPrefix) {
          return property;
        }
        property = property.charAt(0).toUpperCase() + property.substr(1);
        while (i3-- && !(_prefixes[i3] + property in s2)) {
        }
        return i3 < 0 ? null : (i3 === 3 ? "ms" : i3 >= 0 ? _prefixes[i3] : "") + property;
      };
      _initCore = function _initCore2() {
        if (_windowExists3() && window.document) {
          _win2 = window;
          _doc2 = _win2.document;
          _docElement = _doc2.documentElement;
          _tempDiv = _createElement("div") || {
            style: {}
          };
          _tempDivStyler = _createElement("div");
          _transformProp = _checkPropPrefix(_transformProp);
          _transformOriginProp = _transformProp + "Origin";
          _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
          _supports3D = !!_checkPropPrefix("perspective");
          _reverting2 = gsap.core.reverting;
          _pluginInitted = 1;
        }
      };
      _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
        var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
        _docElement.appendChild(svg);
        svg.appendChild(this);
        this.style.display = "block";
        if (swapIfPossible) {
          try {
            bbox = this.getBBox();
            this._gsapBBox = this.getBBox;
            this.getBBox = _getBBoxHack2;
          } catch (e2) {
          }
        } else if (this._gsapBBox) {
          bbox = this._gsapBBox();
        }
        if (oldParent) {
          if (oldSibling) {
            oldParent.insertBefore(this, oldSibling);
          } else {
            oldParent.appendChild(this);
          }
        }
        _docElement.removeChild(svg);
        this.style.cssText = oldCSS;
        return bbox;
      };
      _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
        var i3 = attributesArray.length;
        while (i3--) {
          if (target.hasAttribute(attributesArray[i3])) {
            return target.getAttribute(attributesArray[i3]);
          }
        }
      };
      _getBBox = function _getBBox2(target) {
        var bounds;
        try {
          bounds = target.getBBox();
        } catch (error) {
          bounds = _getBBoxHack.call(target, true);
        }
        bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
        return bounds && !bounds.width && !bounds.x && !bounds.y ? {
          x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
          y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
          width: 0,
          height: 0
        } : bounds;
      };
      _isSVG = function _isSVG2(e2) {
        return !!(e2.getCTM && (!e2.parentNode || e2.ownerSVGElement) && _getBBox(e2));
      };
      _removeProperty = function _removeProperty2(target, property) {
        if (property) {
          var style = target.style, first2Chars;
          if (property in _transformProps && property !== _transformOriginProp) {
            property = _transformProp;
          }
          if (style.removeProperty) {
            first2Chars = property.substr(0, 2);
            if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
              property = "-" + property;
            }
            style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
          } else {
            style.removeAttribute(property);
          }
        }
      };
      _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
        var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
        plugin._pt = pt;
        pt.b = beginning;
        pt.e = end;
        plugin._props.push(property);
        return pt;
      };
      _nonConvertibleUnits = {
        deg: 1,
        rad: 1,
        turn: 1
      };
      _nonStandardLayouts = {
        grid: 1,
        flex: 1
      };
      _convertToUnit = function _convertToUnit2(target, property, value, unit) {
        var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
        if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
          return curValue;
        }
        curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
        isSVG = target.getCTM && _isSVG(target);
        if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
          px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
          return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
        }
        style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
        parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
        if (isSVG) {
          parent = (target.ownerSVGElement || {}).parentNode;
        }
        if (!parent || parent === _doc2 || !parent.appendChild) {
          parent = _doc2.body;
        }
        cache = parent._gsap;
        if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
          return _round(curValue / cache.width * amount);
        } else {
          if (toPercent && (property === "height" || property === "width")) {
            var v2 = target.style[property];
            target.style[property] = amount + unit;
            px = target[measureProperty];
            v2 ? target.style[property] = v2 : _removeProperty(target, property);
          } else {
            (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
            parent === target && (style.position = "static");
            parent.appendChild(_tempDiv);
            px = _tempDiv[measureProperty];
            parent.removeChild(_tempDiv);
            style.position = "absolute";
          }
          if (horizontal && toPercent) {
            cache = _getCache(parent);
            cache.time = _ticker.time;
            cache.width = parent[measureProperty];
          }
        }
        return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
      };
      _get = function _get2(target, property, unit, uncache) {
        var value;
        _pluginInitted || _initCore();
        if (property in _propertyAliases && property !== "transform") {
          property = _propertyAliases[property];
          if (~property.indexOf(",")) {
            property = property.split(",")[0];
          }
        }
        if (_transformProps[property] && property !== "transform") {
          value = _parseTransform(target, uncache);
          value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
        } else {
          value = target.style[property];
          if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
            value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
          }
        }
        return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
      };
      _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
        if (!start || start === "none") {
          var p3 = _checkPropPrefix(prop, target, 1), s2 = p3 && _getComputedProperty(target, p3, 1);
          if (s2 && s2 !== start) {
            prop = p3;
            start = s2;
          } else if (prop === "borderColor") {
            start = _getComputedProperty(target, "borderTopColor");
          }
        }
        var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a2, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
        pt.b = start;
        pt.e = end;
        start += "";
        end += "";
        if (end === "auto") {
          startValue = target.style[prop];
          target.style[prop] = end;
          end = _getComputedProperty(target, prop) || end;
          startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
        }
        a2 = [start, end];
        _colorStringFilter(a2);
        start = a2[0];
        end = a2[1];
        startValues = start.match(_numWithUnitExp) || [];
        endValues = end.match(_numWithUnitExp) || [];
        if (endValues.length) {
          while (result = _numWithUnitExp.exec(end)) {
            endValue = result[0];
            chunk = end.substring(index, result.index);
            if (color) {
              color = (color + 1) % 5;
            } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
              color = 1;
            }
            if (endValue !== (startValue = startValues[matchIndex++] || "")) {
              startNum = parseFloat(startValue) || 0;
              startUnit = startValue.substr((startNum + "").length);
              endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
              endNum = parseFloat(endValue);
              endUnit = endValue.substr((endNum + "").length);
              index = _numWithUnitExp.lastIndex - endUnit.length;
              if (!endUnit) {
                endUnit = endUnit || _config.units[prop] || startUnit;
                if (index === end.length) {
                  end += endUnit;
                  pt.e += endUnit;
                }
              }
              if (startUnit !== endUnit) {
                startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
              }
              pt._pt = {
                _next: pt._pt,
                p: chunk || matchIndex === 1 ? chunk : ",",
                //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
                s: startNum,
                c: endNum - startNum,
                m: color && color < 4 || prop === "zIndex" ? Math.round : 0
              };
            }
          }
          pt.c = index < end.length ? end.substring(index, end.length) : "";
        } else {
          pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
        }
        _relExp.test(end) && (pt.e = 0);
        this._pt = pt;
        return pt;
      };
      _keywordToPercent = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
      };
      _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
        var split = value.split(" "), x2 = split[0], y2 = split[1] || "50%";
        if (x2 === "top" || x2 === "bottom" || y2 === "left" || y2 === "right") {
          value = x2;
          x2 = y2;
          y2 = value;
        }
        split[0] = _keywordToPercent[x2] || x2;
        split[1] = _keywordToPercent[y2] || y2;
        return split.join(" ");
      };
      _renderClearProps = function _renderClearProps2(ratio, data) {
        if (data.tween && data.tween._time === data.tween._dur) {
          var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i3;
          if (props === "all" || props === true) {
            style.cssText = "";
            clearTransforms = 1;
          } else {
            props = props.split(",");
            i3 = props.length;
            while (--i3 > -1) {
              prop = props[i3];
              if (_transformProps[prop]) {
                clearTransforms = 1;
                prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
              }
              _removeProperty(target, prop);
            }
          }
          if (clearTransforms) {
            _removeProperty(target, _transformProp);
            if (cache) {
              cache.svg && target.removeAttribute("transform");
              _parseTransform(target, 1);
              cache.uncache = 1;
              _removeIndependentTransforms(style);
            }
          }
        }
      };
      _specialProps = {
        clearProps: function clearProps(plugin, target, property, endValue, tween) {
          if (tween.data !== "isFromStart") {
            var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
            pt.u = endValue;
            pt.pr = -10;
            pt.tween = tween;
            plugin._props.push(property);
            return 1;
          }
        }
        /* className feature (about 0.4kb gzipped).
        , className(plugin, target, property, endValue, tween) {
        	let _renderClassName = (ratio, data) => {
        			data.css.render(ratio, data.css);
        			if (!ratio || ratio === 1) {
        				let inline = data.rmv,
        					target = data.t,
        					p;
        				target.setAttribute("class", ratio ? data.e : data.b);
        				for (p in inline) {
        					_removeProperty(target, p);
        				}
        			}
        		},
        		_getAllStyles = (target) => {
        			let styles = {},
        				computed = getComputedStyle(target),
        				p;
        			for (p in computed) {
        				if (isNaN(p) && p !== "cssText" && p !== "length") {
        					styles[p] = computed[p];
        				}
        			}
        			_setDefaults(styles, _parseTransform(target, 1));
        			return styles;
        		},
        		startClassList = target.getAttribute("class"),
        		style = target.style,
        		cssText = style.cssText,
        		cache = target._gsap,
        		classPT = cache.classPT,
        		inlineToRemoveAtEnd = {},
        		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
        		changingVars = {},
        		startVars = _getAllStyles(target),
        		transformRelated = /(transform|perspective)/i,
        		endVars, p;
        	if (classPT) {
        		classPT.r(1, classPT.d);
        		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
        	}
        	target.setAttribute("class", data.e);
        	endVars = _getAllStyles(target, true);
        	target.setAttribute("class", startClassList);
        	for (p in endVars) {
        		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
        			changingVars[p] = endVars[p];
        			if (!style[p] && style[p] !== "0") {
        				inlineToRemoveAtEnd[p] = 1;
        			}
        		}
        	}
        	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
        	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
        		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
        	}
        	_parseTransform(target, true); //to clear the caching of transforms
        	data.css = new gsap.plugins.css();
        	data.css.init(target, changingVars, tween);
        	plugin._props.push(...data.css._props);
        	return 1;
        }
        */
      };
      _identity2DMatrix = [1, 0, 0, 1, 0, 0];
      _rotationalProperties = {};
      _isNullTransform = function _isNullTransform2(value) {
        return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
      };
      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
        var matrixString = _getComputedProperty(target, _transformProp);
        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
      };
      _getMatrix = function _getMatrix2(target, force2D) {
        var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
        if (cache.svg && target.getAttribute("transform")) {
          temp = target.transform.baseVal.consolidate().matrix;
          matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
          return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
          temp = style.display;
          style.display = "block";
          parent = target.parentNode;
          if (!parent || !target.offsetParent) {
            addedToDOM = 1;
            nextSibling = target.nextElementSibling;
            _docElement.appendChild(target);
          }
          matrix = _getComputedTransformMatrixAsArray(target);
          temp ? style.display = temp : _removeProperty(target, "display");
          if (addedToDOM) {
            nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
          }
        }
        return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
      };
      _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
        var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a2 = matrix[0], b2 = matrix[1], c2 = matrix[2], d2 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x2, y2;
        if (!originIsAbsolute) {
          bounds = _getBBox(target);
          xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
          yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
        } else if (matrix !== _identity2DMatrix && (determinant = a2 * d2 - b2 * c2)) {
          x2 = xOrigin * (d2 / determinant) + yOrigin * (-c2 / determinant) + (c2 * ty - d2 * tx) / determinant;
          y2 = xOrigin * (-b2 / determinant) + yOrigin * (a2 / determinant) - (a2 * ty - b2 * tx) / determinant;
          xOrigin = x2;
          yOrigin = y2;
        }
        if (smooth || smooth !== false && cache.smooth) {
          tx = xOrigin - xOriginOld;
          ty = yOrigin - yOriginOld;
          cache.xOffset = xOffsetOld + (tx * a2 + ty * c2) - tx;
          cache.yOffset = yOffsetOld + (tx * b2 + ty * d2) - ty;
        } else {
          cache.xOffset = cache.yOffset = 0;
        }
        cache.xOrigin = xOrigin;
        cache.yOrigin = yOrigin;
        cache.smooth = !!smooth;
        cache.origin = origin;
        cache.originIsAbsolute = !!originIsAbsolute;
        target.style[_transformOriginProp] = "0px 0px";
        if (pluginToAddPropTweensTo) {
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
        }
        target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
      };
      _parseTransform = function _parseTransform2(target, uncache) {
        var cache = target._gsap || new GSCache(target);
        if ("x" in cache && !uncache && !cache.uncache) {
          return cache;
        }
        var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x2, y2, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a2, b2, c2, d2, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
        x2 = y2 = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
        scaleX = scaleY = 1;
        cache.svg = !!(target.getCTM && _isSVG(target));
        if (cs.translate) {
          if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
            style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
          }
          style.scale = style.rotate = style.translate = "none";
        }
        matrix = _getMatrix(target, cache.svg);
        if (cache.svg) {
          if (cache.uncache) {
            t2 = target.getBBox();
            origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
            t1 = "";
          } else {
            t1 = !uncache && target.getAttribute("data-svg-origin");
          }
          _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
        }
        xOrigin = cache.xOrigin || 0;
        yOrigin = cache.yOrigin || 0;
        if (matrix !== _identity2DMatrix) {
          a2 = matrix[0];
          b2 = matrix[1];
          c2 = matrix[2];
          d2 = matrix[3];
          x2 = a12 = matrix[4];
          y2 = a22 = matrix[5];
          if (matrix.length === 6) {
            scaleX = Math.sqrt(a2 * a2 + b2 * b2);
            scaleY = Math.sqrt(d2 * d2 + c2 * c2);
            rotation = a2 || b2 ? _atan2(b2, a2) * _RAD2DEG : 0;
            skewX = c2 || d2 ? _atan2(c2, d2) * _RAD2DEG + rotation : 0;
            skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
            if (cache.svg) {
              x2 -= xOrigin - (xOrigin * a2 + yOrigin * c2);
              y2 -= yOrigin - (xOrigin * b2 + yOrigin * d2);
            }
          } else {
            a32 = matrix[6];
            a42 = matrix[7];
            a13 = matrix[8];
            a23 = matrix[9];
            a33 = matrix[10];
            a43 = matrix[11];
            x2 = matrix[12];
            y2 = matrix[13];
            z = matrix[14];
            angle = _atan2(a32, a33);
            rotationX = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a12 * cos + a13 * sin;
              t2 = a22 * cos + a23 * sin;
              t3 = a32 * cos + a33 * sin;
              a13 = a12 * -sin + a13 * cos;
              a23 = a22 * -sin + a23 * cos;
              a33 = a32 * -sin + a33 * cos;
              a43 = a42 * -sin + a43 * cos;
              a12 = t1;
              a22 = t2;
              a32 = t3;
            }
            angle = _atan2(-c2, a33);
            rotationY = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a2 * cos - a13 * sin;
              t2 = b2 * cos - a23 * sin;
              t3 = c2 * cos - a33 * sin;
              a43 = d2 * sin + a43 * cos;
              a2 = t1;
              b2 = t2;
              c2 = t3;
            }
            angle = _atan2(b2, a2);
            rotation = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(angle);
              sin = Math.sin(angle);
              t1 = a2 * cos + b2 * sin;
              t2 = a12 * cos + a22 * sin;
              b2 = b2 * cos - a2 * sin;
              a22 = a22 * cos - a12 * sin;
              a2 = t1;
              a12 = t2;
            }
            if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
              rotationX = rotation = 0;
              rotationY = 180 - rotationY;
            }
            scaleX = _round(Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2));
            scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
            angle = _atan2(a12, a22);
            skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
            perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
          }
          if (cache.svg) {
            t1 = target.getAttribute("transform");
            cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
            t1 && target.setAttribute("transform", t1);
          }
        }
        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
          if (invertedScaleX) {
            scaleX *= -1;
            skewX += rotation <= 0 ? 180 : -180;
            rotation += rotation <= 0 ? 180 : -180;
          } else {
            scaleY *= -1;
            skewX += skewX <= 0 ? 180 : -180;
          }
        }
        uncache = uncache || cache.uncache;
        cache.x = x2 - ((cache.xPercent = x2 && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x2) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
        cache.y = y2 - ((cache.yPercent = y2 && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y2) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
        cache.z = z + px;
        cache.scaleX = _round(scaleX);
        cache.scaleY = _round(scaleY);
        cache.rotation = _round(rotation) + deg;
        cache.rotationX = _round(rotationX) + deg;
        cache.rotationY = _round(rotationY) + deg;
        cache.skewX = skewX + deg;
        cache.skewY = skewY + deg;
        cache.transformPerspective = perspective + px;
        if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
          style[_transformOriginProp] = _firstTwoOnly(origin);
        }
        cache.xOffset = cache.yOffset = 0;
        cache.force3D = _config.force3D;
        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
        cache.uncache = 0;
        return cache;
      };
      _firstTwoOnly = function _firstTwoOnly2(value) {
        return (value = value.split(" "))[0] + " " + value[1];
      };
      _addPxTranslate = function _addPxTranslate2(target, start, value) {
        var unit = getUnit(start);
        return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
      };
      _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
        cache.z = "0px";
        cache.rotationY = cache.rotationX = "0deg";
        cache.force3D = 0;
        _renderCSSTransforms(ratio, cache);
      };
      _zeroDeg = "0deg";
      _zeroPx = "0px";
      _endParenthesis = ") ";
      _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
        var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x2 = _ref.x, y2 = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
          var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
          angle = parseFloat(rotationX) * _DEG2RAD;
          cos = Math.cos(angle);
          x2 = _addPxTranslate(target, x2, a13 * cos * -zOrigin);
          y2 = _addPxTranslate(target, y2, -Math.sin(angle) * -zOrigin);
          z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
        }
        if (transformPerspective !== _zeroPx) {
          transforms += "perspective(" + transformPerspective + _endParenthesis;
        }
        if (xPercent || yPercent) {
          transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
        }
        if (use3D || x2 !== _zeroPx || y2 !== _zeroPx || z !== _zeroPx) {
          transforms += z !== _zeroPx || use3D ? "translate3d(" + x2 + ", " + y2 + ", " + z + ") " : "translate(" + x2 + ", " + y2 + _endParenthesis;
        }
        if (rotation !== _zeroDeg) {
          transforms += "rotate(" + rotation + _endParenthesis;
        }
        if (rotationY !== _zeroDeg) {
          transforms += "rotateY(" + rotationY + _endParenthesis;
        }
        if (rotationX !== _zeroDeg) {
          transforms += "rotateX(" + rotationX + _endParenthesis;
        }
        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
          transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
        }
        if (scaleX !== 1 || scaleY !== 1) {
          transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
        }
        target.style[_transformProp] = transforms || "translate(0, 0)";
      };
      _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
        var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x2 = _ref2.x, y2 = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x2), ty = parseFloat(y2), a11, a21, a12, a22, temp;
        rotation = parseFloat(rotation);
        skewX = parseFloat(skewX);
        skewY = parseFloat(skewY);
        if (skewY) {
          skewY = parseFloat(skewY);
          skewX += skewY;
          rotation += skewY;
        }
        if (rotation || skewX) {
          rotation *= _DEG2RAD;
          skewX *= _DEG2RAD;
          a11 = Math.cos(rotation) * scaleX;
          a21 = Math.sin(rotation) * scaleX;
          a12 = Math.sin(rotation - skewX) * -scaleY;
          a22 = Math.cos(rotation - skewX) * scaleY;
          if (skewX) {
            skewY *= _DEG2RAD;
            temp = Math.tan(skewX - skewY);
            temp = Math.sqrt(1 + temp * temp);
            a12 *= temp;
            a22 *= temp;
            if (skewY) {
              temp = Math.tan(skewY);
              temp = Math.sqrt(1 + temp * temp);
              a11 *= temp;
              a21 *= temp;
            }
          }
          a11 = _round(a11);
          a21 = _round(a21);
          a12 = _round(a12);
          a22 = _round(a22);
        } else {
          a11 = scaleX;
          a22 = scaleY;
          a21 = a12 = 0;
        }
        if (tx && !~(x2 + "").indexOf("px") || ty && !~(y2 + "").indexOf("px")) {
          tx = _convertToUnit(target, "x", x2, "px");
          ty = _convertToUnit(target, "y", y2, "px");
        }
        if (xOrigin || yOrigin || xOffset || yOffset) {
          tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
          ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
        }
        if (xPercent || yPercent) {
          temp = target.getBBox();
          tx = _round(tx + xPercent / 100 * temp.width);
          ty = _round(ty + yPercent / 100 * temp.height);
        }
        temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
        target.setAttribute("transform", temp);
        forceCSS && (target.style[_transformProp] = temp);
      };
      _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
        var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
        if (isString) {
          direction = endValue.split("_")[1];
          if (direction === "short") {
            change %= cap;
            if (change !== change % (cap / 2)) {
              change += change < 0 ? cap : -cap;
            }
          }
          if (direction === "cw" && change < 0) {
            change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
          } else if (direction === "ccw" && change > 0) {
            change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
          }
        }
        plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
        pt.e = finalValue;
        pt.u = "deg";
        plugin._props.push(property);
        return pt;
      };
      _assign = function _assign2(target, source7) {
        for (var p3 in source7) {
          target[p3] = source7[p3];
        }
        return target;
      };
      _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
        var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p3, startValue, endValue, startNum, endNum, startUnit, endUnit;
        if (startCache.svg) {
          startValue = target.getAttribute("transform");
          target.setAttribute("transform", "");
          style[_transformProp] = transforms;
          endCache = _parseTransform(target, 1);
          _removeProperty(target, _transformProp);
          target.setAttribute("transform", startValue);
        } else {
          startValue = getComputedStyle(target)[_transformProp];
          style[_transformProp] = transforms;
          endCache = _parseTransform(target, 1);
          style[_transformProp] = startValue;
        }
        for (p3 in _transformProps) {
          startValue = startCache[p3];
          endValue = endCache[p3];
          if (startValue !== endValue && exclude.indexOf(p3) < 0) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
            startNum = startUnit !== endUnit ? _convertToUnit(target, p3, startValue, endUnit) : parseFloat(startValue);
            endNum = parseFloat(endValue);
            plugin._pt = new PropTween(plugin._pt, endCache, p3, startNum, endNum - startNum, _renderCSSProp);
            plugin._pt.u = endUnit || 0;
            plugin._props.push(p3);
          }
        }
        _assign(endCache, startCache);
      };
      _forEachName("padding,margin,Width,Radius", function(name, index) {
        var t2 = "Top", r2 = "Right", b2 = "Bottom", l2 = "Left", props = (index < 3 ? [t2, r2, b2, l2] : [t2 + l2, t2 + r2, b2 + r2, b2 + l2]).map(function(side) {
          return index < 2 ? name + side : "border" + side + name;
        });
        _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
          var a2, vars;
          if (arguments.length < 4) {
            a2 = props.map(function(prop) {
              return _get(plugin, prop, property);
            });
            vars = a2.join(" ");
            return vars.split(a2[0]).length === 5 ? a2[0] : vars;
          }
          a2 = (endValue + "").split(" ");
          vars = {};
          props.forEach(function(prop, i3) {
            return vars[prop] = a2[i3] = a2[i3] || a2[(i3 - 1) / 2 | 0];
          });
          plugin.init(target, vars, tween);
        };
      });
      CSSPlugin = {
        name: "css",
        register: _initCore,
        targetTest: function targetTest(target) {
          return target.style && target.nodeType;
        },
        init: function init4(target, vars, tween, index, targets) {
          var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p3, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
          _pluginInitted || _initCore();
          this.styles = this.styles || _getStyleSaver(target);
          inlineProps = this.styles.props;
          this.tween = tween;
          for (p3 in vars) {
            if (p3 === "autoRound") {
              continue;
            }
            endValue = vars[p3];
            if (_plugins[p3] && _checkPlugin(p3, vars, tween, index, target, targets)) {
              continue;
            }
            type = typeof endValue;
            specialProp = _specialProps[p3];
            if (type === "function") {
              endValue = endValue.call(tween, index, target, targets);
              type = typeof endValue;
            }
            if (type === "string" && ~endValue.indexOf("random(")) {
              endValue = _replaceRandom(endValue);
            }
            if (specialProp) {
              specialProp(this, target, p3, endValue, tween) && (hasPriority = 1);
            } else if (p3.substr(0, 2) === "--") {
              startValue = (getComputedStyle(target).getPropertyValue(p3) + "").trim();
              endValue += "";
              _colorExp.lastIndex = 0;
              if (!_colorExp.test(startValue)) {
                startUnit = getUnit(startValue);
                endUnit = getUnit(endValue);
              }
              endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p3, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
              this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p3);
              props.push(p3);
              inlineProps.push(p3, 0, style[p3]);
            } else if (type !== "undefined") {
              if (startAt && p3 in startAt) {
                startValue = typeof startAt[p3] === "function" ? startAt[p3].call(tween, index, target, targets) : startAt[p3];
                _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
                getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p3] || getUnit(_get(target, p3)) || "");
                (startValue + "").charAt(1) === "=" && (startValue = _get(target, p3));
              } else {
                startValue = _get(target, p3);
              }
              startNum = parseFloat(startValue);
              relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
              relative && (endValue = endValue.substr(2));
              endNum = parseFloat(endValue);
              if (p3 in _propertyAliases) {
                if (p3 === "autoAlpha") {
                  if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                    startNum = 0;
                  }
                  inlineProps.push("visibility", 0, style.visibility);
                  _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                }
                if (p3 !== "scale" && p3 !== "transform") {
                  p3 = _propertyAliases[p3];
                  ~p3.indexOf(",") && (p3 = p3.split(",")[0]);
                }
              }
              isTransformRelated = p3 in _transformProps;
              if (isTransformRelated) {
                this.styles.save(p3);
                if (!transformPropTween) {
                  cache = target._gsap;
                  cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                  smooth = vars.smoothOrigin !== false && cache.smooth;
                  transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                  transformPropTween.dep = 1;
                }
                if (p3 === "scale") {
                  this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                  this._pt.u = 0;
                  props.push("scaleY", p3);
                  p3 += "X";
                } else if (p3 === "transformOrigin") {
                  inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                  endValue = _convertKeywordsToPercentages(endValue);
                  if (cache.svg) {
                    _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                  } else {
                    endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                    endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                    _addNonTweeningPT(this, style, p3, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                  }
                  continue;
                } else if (p3 === "svgOrigin") {
                  _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                  continue;
                } else if (p3 in _rotationalProperties) {
                  _addRotationalPropTween(this, cache, p3, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
                  continue;
                } else if (p3 === "smoothOrigin") {
                  _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                  continue;
                } else if (p3 === "force3D") {
                  cache[p3] = endValue;
                  continue;
                } else if (p3 === "transform") {
                  _addRawTransformPTs(this, endValue, target);
                  continue;
                }
              } else if (!(p3 in style)) {
                p3 = _checkPropPrefix(p3) || p3;
              }
              if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p3 in style) {
                startUnit = (startValue + "").substr((startNum + "").length);
                endNum || (endNum = 0);
                endUnit = getUnit(endValue) || (p3 in _config.units ? _config.units[p3] : startUnit);
                startUnit !== endUnit && (startNum = _convertToUnit(target, p3, startValue, endUnit));
                this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p3, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p3 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                this._pt.u = endUnit || 0;
                if (startUnit !== endUnit && endUnit !== "%") {
                  this._pt.b = startValue;
                  this._pt.r = _renderCSSPropWithBeginning;
                }
              } else if (!(p3 in style)) {
                if (p3 in target) {
                  this.add(target, p3, startValue || target[p3], relative ? relative + endValue : endValue, index, targets);
                } else if (p3 !== "parseTransform") {
                  _missingPlugin(p3, endValue);
                  continue;
                }
              } else {
                _tweenComplexCSSString.call(this, target, p3, startValue, relative ? relative + endValue : endValue);
              }
              isTransformRelated || (p3 in style ? inlineProps.push(p3, 0, style[p3]) : inlineProps.push(p3, 1, startValue || target[p3]));
              props.push(p3);
            }
          }
          hasPriority && _sortPropTweensByPriority(this);
        },
        render: function render2(ratio, data) {
          if (data.tween._time || !_reverting2()) {
            var pt = data._pt;
            while (pt) {
              pt.r(ratio, pt.d);
              pt = pt._next;
            }
          } else {
            data.styles.revert();
          }
        },
        get: _get,
        aliases: _propertyAliases,
        getSetter: function getSetter(target, property, plugin) {
          var p3 = _propertyAliases[property];
          p3 && p3.indexOf(",") < 0 && (property = p3);
          return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
        },
        core: {
          _removeProperty,
          _getMatrix
        }
      };
      gsap.utils.checkPrefix = _checkPropPrefix;
      gsap.core.getStyleSaver = _getStyleSaver;
      (function(positionAndScale, rotation, others, aliases) {
        var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
          _transformProps[name] = 1;
        });
        _forEachName(rotation, function(name) {
          _config.units[name] = "deg";
          _rotationalProperties[name] = 1;
        });
        _propertyAliases[all[13]] = positionAndScale + "," + rotation;
        _forEachName(aliases, function(name) {
          var split = name.split(":");
          _propertyAliases[split[1]] = all[split[0]];
        });
      })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
      _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
        _config.units[name] = "px";
      });
      gsap.registerPlugin(CSSPlugin);
    }
  });

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js
  var gsapWithCSS, TweenMaxWithCSS;
  var init_gsap = __esm({
    "node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js"() {
      init_gsap_core();
      init_CSSPlugin();
      gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
      TweenMaxWithCSS = gsapWithCSS.core.Tween;
    }
  });

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js
  var gsap2, _splitColor, _coreInitted2, _PIXI, PropTween2, _getSetter3, _isV4, _windowExists5, _getGSAP, _isFunction3, _warn3, _idMatrix, _lumR, _lumG, _lumB, _filterClass, _applyMatrix, _setSaturation, _colorize, _setHue, _setContrast, _getFilter, _addColorMatrixFilterCacheTween, _applyBrightnessToMatrix, _copy, _CMFdefaults, _parseColorMatrixFilter, _renderColor, _renderDirtyCache, _renderAutoAlpha, _addColorTween, _colorProps, _xyContexts, _contexts, _colorMatrixFilterProps, _DEG2RAD2, _isString3, _degreesToRadians, _renderPropWithEnd3, _addRotationalPropTween3, _initCore3, i2, p2, PixiPlugin;
  var init_PixiPlugin = __esm({
    "node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/PixiPlugin.js"() {
      _windowExists5 = function _windowExists6() {
        return typeof window !== "undefined";
      };
      _getGSAP = function _getGSAP2() {
        return gsap2 || _windowExists5() && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
      };
      _isFunction3 = function _isFunction4(value) {
        return typeof value === "function";
      };
      _warn3 = function _warn4(message) {
        return console.warn(message);
      };
      _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
      _lumR = 0.212671;
      _lumG = 0.71516;
      _lumB = 0.072169;
      _filterClass = function _filterClass2(name) {
        return _isFunction3(_PIXI[name]) ? _PIXI[name] : _PIXI.filters[name];
      };
      _applyMatrix = function _applyMatrix2(m2, m22) {
        var temp = [], i3 = 0, z = 0, y2, x2;
        for (y2 = 0; y2 < 4; y2++) {
          for (x2 = 0; x2 < 5; x2++) {
            z = x2 === 4 ? m2[i3 + 4] : 0;
            temp[i3 + x2] = m2[i3] * m22[x2] + m2[i3 + 1] * m22[x2 + 5] + m2[i3 + 2] * m22[x2 + 10] + m2[i3 + 3] * m22[x2 + 15] + z;
          }
          i3 += 5;
        }
        return temp;
      };
      _setSaturation = function _setSaturation2(m2, n2) {
        var inv = 1 - n2, r2 = inv * _lumR, g2 = inv * _lumG, b2 = inv * _lumB;
        return _applyMatrix([r2 + n2, g2, b2, 0, 0, r2, g2 + n2, b2, 0, 0, r2, g2, b2 + n2, 0, 0, 0, 0, 0, 1, 0], m2);
      };
      _colorize = function _colorize2(m2, color, amount) {
        var c2 = _splitColor(color), r2 = c2[0] / 255, g2 = c2[1] / 255, b2 = c2[2] / 255, inv = 1 - amount;
        return _applyMatrix([inv + amount * r2 * _lumR, amount * r2 * _lumG, amount * r2 * _lumB, 0, 0, amount * g2 * _lumR, inv + amount * g2 * _lumG, amount * g2 * _lumB, 0, 0, amount * b2 * _lumR, amount * b2 * _lumG, inv + amount * b2 * _lumB, 0, 0, 0, 0, 0, 1, 0], m2);
      };
      _setHue = function _setHue2(m2, n2) {
        n2 *= Math.PI / 180;
        var c2 = Math.cos(n2), s2 = Math.sin(n2);
        return _applyMatrix([_lumR + c2 * (1 - _lumR) + s2 * -_lumR, _lumG + c2 * -_lumG + s2 * -_lumG, _lumB + c2 * -_lumB + s2 * (1 - _lumB), 0, 0, _lumR + c2 * -_lumR + s2 * 0.143, _lumG + c2 * (1 - _lumG) + s2 * 0.14, _lumB + c2 * -_lumB + s2 * -0.283, 0, 0, _lumR + c2 * -_lumR + s2 * -(1 - _lumR), _lumG + c2 * -_lumG + s2 * _lumG, _lumB + c2 * (1 - _lumB) + s2 * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m2);
      };
      _setContrast = function _setContrast2(m2, n2) {
        return _applyMatrix([n2, 0, 0, 0, 0.5 * (1 - n2), 0, n2, 0, 0, 0.5 * (1 - n2), 0, 0, n2, 0, 0.5 * (1 - n2), 0, 0, 0, 1, 0], m2);
      };
      _getFilter = function _getFilter2(target, type) {
        var filterClass = _filterClass(type), filters = target.filters || [], i3 = filters.length, filter;
        filterClass || _warn3(type + " not found. PixiPlugin.registerPIXI(PIXI)");
        while (--i3 > -1) {
          if (filters[i3] instanceof filterClass) {
            return filters[i3];
          }
        }
        filter = new filterClass();
        if (type === "BlurFilter") {
          filter.blur = 0;
        }
        filters.push(filter);
        target.filters = filters;
        return filter;
      };
      _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween2(p3, plugin, cache, vars) {
        plugin.add(cache, p3, cache[p3], vars[p3]);
        plugin._props.push(p3);
      };
      _applyBrightnessToMatrix = function _applyBrightnessToMatrix2(brightness, matrix) {
        var filterClass = _filterClass("ColorMatrixFilter"), temp = new filterClass();
        temp.matrix = matrix;
        temp.brightness(brightness, true);
        return temp.matrix;
      };
      _copy = function _copy2(obj) {
        var copy = {}, p3;
        for (p3 in obj) {
          copy[p3] = obj[p3];
        }
        return copy;
      };
      _CMFdefaults = {
        contrast: 1,
        saturation: 1,
        colorizeAmount: 0,
        colorize: "rgb(255,255,255)",
        hue: 0,
        brightness: 1
      };
      _parseColorMatrixFilter = function _parseColorMatrixFilter2(target, v2, pg) {
        var filter = _getFilter(target, "ColorMatrixFilter"), cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults), combine = v2.combineCMF && !("colorMatrixFilter" in v2 && !v2.colorMatrixFilter), i3, matrix, startMatrix;
        startMatrix = filter.matrix;
        if (v2.resolution) {
          filter.resolution = v2.resolution;
        }
        if (v2.matrix && v2.matrix.length === startMatrix.length) {
          matrix = v2.matrix;
          if (cache.contrast !== 1) {
            _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
          }
          if (cache.hue) {
            _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
          }
          if (cache.brightness !== 1) {
            _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
          }
          if (cache.colorizeAmount) {
            _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
            _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
          }
          if (cache.saturation !== 1) {
            _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
          }
        } else {
          matrix = _idMatrix.slice();
          if (v2.contrast != null) {
            matrix = _setContrast(matrix, +v2.contrast);
            _addColorMatrixFilterCacheTween("contrast", pg, cache, v2);
          } else if (cache.contrast !== 1) {
            if (combine) {
              matrix = _setContrast(matrix, cache.contrast);
            } else {
              _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
            }
          }
          if (v2.hue != null) {
            matrix = _setHue(matrix, +v2.hue);
            _addColorMatrixFilterCacheTween("hue", pg, cache, v2);
          } else if (cache.hue) {
            if (combine) {
              matrix = _setHue(matrix, cache.hue);
            } else {
              _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
            }
          }
          if (v2.brightness != null) {
            matrix = _applyBrightnessToMatrix(+v2.brightness, matrix);
            _addColorMatrixFilterCacheTween("brightness", pg, cache, v2);
          } else if (cache.brightness !== 1) {
            if (combine) {
              matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
            } else {
              _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
            }
          }
          if (v2.colorize != null) {
            v2.colorizeAmount = "colorizeAmount" in v2 ? +v2.colorizeAmount : 1;
            matrix = _colorize(matrix, v2.colorize, v2.colorizeAmount);
            _addColorMatrixFilterCacheTween("colorize", pg, cache, v2);
            _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v2);
          } else if (cache.colorizeAmount) {
            if (combine) {
              matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
            } else {
              _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
              _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
            }
          }
          if (v2.saturation != null) {
            matrix = _setSaturation(matrix, +v2.saturation);
            _addColorMatrixFilterCacheTween("saturation", pg, cache, v2);
          } else if (cache.saturation !== 1) {
            if (combine) {
              matrix = _setSaturation(matrix, cache.saturation);
            } else {
              _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
            }
          }
        }
        i3 = matrix.length;
        while (--i3 > -1) {
          if (matrix[i3] !== startMatrix[i3]) {
            pg.add(startMatrix, i3, startMatrix[i3], matrix[i3], "colorMatrixFilter");
          }
        }
        pg._props.push("colorMatrixFilter");
      };
      _renderColor = function _renderColor2(ratio, _ref) {
        var t2 = _ref.t, p3 = _ref.p, color = _ref.color, set = _ref.set;
        set(t2, p3, color[0] << 16 | color[1] << 8 | color[2]);
      };
      _renderDirtyCache = function _renderDirtyCache2(ratio, _ref2) {
        var g2 = _ref2.g;
        if (g2) {
          g2.dirty++;
          g2.clearDirty++;
        }
      };
      _renderAutoAlpha = function _renderAutoAlpha2(ratio, data) {
        data.t.visible = !!data.t.alpha;
      };
      _addColorTween = function _addColorTween2(target, p3, value, plugin) {
        var currentValue = target[p3], startColor = _splitColor(_isFunction3(currentValue) ? target[p3.indexOf("set") || !_isFunction3(target["get" + p3.substr(3)]) ? p3 : "get" + p3.substr(3)]() : currentValue), endColor = _splitColor(value);
        plugin._pt = new PropTween2(plugin._pt, target, p3, 0, 0, _renderColor, {
          t: target,
          p: p3,
          color: startColor,
          set: _getSetter3(target, p3)
        });
        plugin.add(startColor, 0, startColor[0], endColor[0]);
        plugin.add(startColor, 1, startColor[1], endColor[1]);
        plugin.add(startColor, 2, startColor[2], endColor[2]);
      };
      _colorProps = {
        tint: 1,
        lineColor: 1,
        fillColor: 1
      };
      _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(",");
      _contexts = {
        x: "position",
        y: "position",
        tileX: "tilePosition",
        tileY: "tilePosition"
      };
      _colorMatrixFilterProps = {
        colorMatrixFilter: 1,
        saturation: 1,
        contrast: 1,
        hue: 1,
        colorize: 1,
        colorizeAmount: 1,
        brightness: 1,
        combineCMF: 1
      };
      _DEG2RAD2 = Math.PI / 180;
      _isString3 = function _isString4(value) {
        return typeof value === "string";
      };
      _degreesToRadians = function _degreesToRadians2(value) {
        return _isString3(value) && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD2 : value * _DEG2RAD2;
      };
      _renderPropWithEnd3 = function _renderPropWithEnd4(ratio, data) {
        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e5) / 1e5, data);
      };
      _addRotationalPropTween3 = function _addRotationalPropTween4(plugin, target, property, startNum, endValue, radians) {
        var cap = 360 * (radians ? _DEG2RAD2 : 1), isString = _isString3(endValue), relative = isString && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0, endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD2 : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change, direction, pt;
        if (isString) {
          direction = endValue.split("_")[1];
          if (direction === "short") {
            change %= cap;
            if (change !== change % (cap / 2)) {
              change += change < 0 ? cap : -cap;
            }
          }
          if (direction === "cw" && change < 0) {
            change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;
          } else if (direction === "ccw" && change > 0) {
            change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;
          }
        }
        plugin._pt = pt = new PropTween2(plugin._pt, target, property, startNum, change, _renderPropWithEnd3);
        pt.e = finalValue;
        return pt;
      };
      _initCore3 = function _initCore4() {
        if (!_coreInitted2) {
          gsap2 = _getGSAP();
          _PIXI = _coreInitted2 = _PIXI || _windowExists5() && window.PIXI;
          _isV4 = _PIXI && _PIXI.VERSION && _PIXI.VERSION.charAt(0) === "4";
          _splitColor = function _splitColor2(color) {
            return gsap2.utils.splitColor((color + "").substr(0, 2) === "0x" ? "#" + color.substr(2) : color);
          };
        }
      };
      for (i2 = 0; i2 < _xyContexts.length; i2++) {
        p2 = _xyContexts[i2];
        _contexts[p2 + "X"] = p2;
        _contexts[p2 + "Y"] = p2;
      }
      PixiPlugin = {
        version: "3.12.5",
        name: "pixi",
        register: function register(core, Plugin, propTween) {
          gsap2 = core;
          PropTween2 = propTween;
          _getSetter3 = Plugin.getSetter;
          _initCore3();
        },
        headless: true,
        // doesn't need window
        registerPIXI: function registerPIXI(pixi) {
          _PIXI = pixi;
        },
        init: function init5(target, values, tween, index, targets) {
          _PIXI || _initCore3();
          if (!_PIXI) {
            _warn3("PIXI was not found. PixiPlugin.registerPIXI(PIXI);");
            return false;
          }
          var context4, axis, value, colorMatrix, filter, p3, padding, i3, data;
          for (p3 in values) {
            context4 = _contexts[p3];
            value = values[p3];
            if (context4) {
              axis = ~p3.charAt(p3.length - 1).toLowerCase().indexOf("x") ? "x" : "y";
              this.add(target[context4], axis, target[context4][axis], context4 === "skew" ? _degreesToRadians(value) : value, 0, 0, 0, 0, 0, 1);
            } else if (p3 === "scale" || p3 === "anchor" || p3 === "pivot" || p3 === "tileScale") {
              this.add(target[p3], "x", target[p3].x, value);
              this.add(target[p3], "y", target[p3].y, value);
            } else if (p3 === "rotation" || p3 === "angle") {
              _addRotationalPropTween3(this, target, p3, target[p3], value, p3 === "rotation");
            } else if (_colorMatrixFilterProps[p3]) {
              if (!colorMatrix) {
                _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);
                colorMatrix = true;
              }
            } else if (p3 === "blur" || p3 === "blurX" || p3 === "blurY" || p3 === "blurPadding") {
              filter = _getFilter(target, "BlurFilter");
              this.add(filter, p3, filter[p3], value);
              if (values.blurPadding !== 0) {
                padding = values.blurPadding || Math.max(filter[p3], value) * 2;
                i3 = target.filters.length;
                while (--i3 > -1) {
                  target.filters[i3].padding = Math.max(target.filters[i3].padding, padding);
                }
              }
            } else if (_colorProps[p3]) {
              if ((p3 === "lineColor" || p3 === "fillColor") && target instanceof _PIXI.Graphics) {
                data = (target.geometry || target).graphicsData;
                this._pt = new PropTween2(this._pt, target, p3, 0, 0, _renderDirtyCache, {
                  g: target.geometry || target
                });
                i3 = data.length;
                while (--i3 > -1) {
                  _addColorTween(_isV4 ? data[i3] : data[i3][p3.substr(0, 4) + "Style"], _isV4 ? p3 : "color", value, this);
                }
              } else {
                _addColorTween(target, p3, value, this);
              }
            } else if (p3 === "autoAlpha") {
              this._pt = new PropTween2(this._pt, target, "visible", 0, 0, _renderAutoAlpha);
              this.add(target, "alpha", target.alpha, value);
              this._props.push("alpha", "visible");
            } else if (p3 !== "resolution") {
              this.add(target, p3, "get", value);
            }
            this._props.push(p3);
          }
        }
      };
      _getGSAP() && gsap2.registerPlugin(PixiPlugin);
    }
  });

  // src/main.ts
  var require_main = __commonJS({
    "src/main.ts"(exports) {
      init_lib();
      init_gsap();
      init_PixiPlugin();
      PixiPlugin.registerPIXI(lib_exports);
      gsapWithCSS.registerPlugin(PixiPlugin);
      (() => __async(exports, null, function* () {
        const app = new Application();
        yield app.init({
          background: 0,
          resizeTo: window,
          resolution: window.devicePixelRatio,
          hello: true
        });
        document.body.appendChild(app.canvas);
        const tex = yield Assets.load("assets/sprites/l_1.jpg");
        const l_1 = new Sprite(tex);
        l_1.anchor.set(0.5);
        l_1.x = 500;
        l_1.y = 500;
        app.stage.addChild(l_1);
        gsapWithCSS.to(l_1, { pixi: { rotation: 360 }, duration: 1 });
      }))();
    }
  });
  return require_main();
})();
//# sourceMappingURL=frontend_dev_task.js.map
